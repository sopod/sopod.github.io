[{"content":" 프로세스와 스레드 프로세스(Process) 프로그램이 실행되어 메모리에 적재된 인스턴스이다. 스레드(Thread) 프로세스 내에서 실행되는 흐름의 단위이다. 운영체제가 CPU 시간을 할당하는 기본 단위이다. 멀티 스레드의 장점 응답성을 높일 수 있다. 자원 공유가 쉽다. 자원을 공유하므로 경제적이다. 멀티 스레드의 단점 구현이 까다롭다. 스레드를 너무 많이 사용하면 문맥교환이 잦아져서 오히려 성능이 더 저하된다. 스레드 시작하기 .NET은 스레드를 제어하는 System.Threading.Thread 클래스를 제공한다. Thread의 인스턴스를 생성한다. 인수로 실행할 메소드를 넘긴다. Thread.Start()메소드를 호출해서 스레드를 시작한다. Thread.Join()메소드를 호출해서 스레드가 끝날 때까지 기다린다. 스레드 임의로 종료시키기 Thread.Abort()메소드를 호출하면 즉시 종료되지는 않는다. CLR은 해당 스레드가 실행 중이던 코드에 ThreadAbortException을 던진다. 이 때 예외를 catch하는 코드가 있으면 처리한 다음 finally 블록까지 실행한 후에야 해당 스레드는 완전히 종료된다. 왠만하면 사용하지 않는 것이 좋다. 해당 스레드가 독점 자원을 잠근 후 종료되면, 그 자원은 해제되지 못하기 때문이다. 스레드의 상태 변화 .NET은 스레드의 상태를 ThreadState 열거형에 정의해두었다. 상태 설명 Unstarted 스레드 객체를 생성한 후 Thread.Start() 메소드가 호출되기 전의 상태이다. Running 스레드가 시작하여 동작 중인 상태이다. Unstarted에서 Thread.Start()하면 이 상태가 된다. Suspended 스레드의 일시 중단 상태이다. Thread.Suspend() 메소드를 통해 이 상태로 만들 수 있으며, Thread.Resume() 메소드를 통해 다시 Running 상태로 만들 수 있다. WaitSleepJoin 스레드가 블록(Block)된 상태이다. Monitor.Enter()나 Thread.Sleep()나 Thread.Join() 메소드를 호출하면 이 상태가 된다. Aborted 스레드가 취소된 상태이다. Thread.Abort() 메소드를 호출하면 이 상태가 된다. 이후 Stopped 상태로 전환되어 완전히 중지된다. Stopped 스레드가 중지된 상태이다. Thread.Abort() 메소드를 호출하거나 실행 중인 메소드가 종료되면 이 상태가 된다. Background 스레드가 백그라운드로 동작하고 있음을 나타낸다. 포어그라운드의 경우 스레드가 하나라도 살아 있으면 프로세스가 죽지 않는다. 반면 백그라운드의 경우 스레드가 살아 있는지와 관계없이 프로세스가 죽으면 스레드도 모두 죽는다. ThreadState 열거형은 Flags애트리뷰트를 갖고 있다. 따라서 이 열거형의 요소들의 집합으로 표현할 수 있다. 즉, 비트 필드(Bit field)로 처리할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 [Flags] enum MyEnum { Apple = 1 \u0026lt;\u0026lt; 0, Orange = 1 \u0026lt;\u0026lt; 1, Kiwi = 1 \u0026lt;\u0026lt; 2, Mango = 1 \u0026lt;\u0026lt; 3, }; Console.WriteLine((MyEnum) 1); // Apple Console.WriteLine((MyEnum) (1 | 4)); // Apple, Kiwi // Flags 애트리뷰트를 갖고 있는 열거형은 요소의 집합으로 표현될 수 있다. 비트 연산을 통해 ThreadState 필드의 값을 확인할 수 있다. 상태 10진수 2진수 Running 0 000000000 StopRequested 1 000000001 SuspendRequested 2 000000010 Background 4 000000100 Unstarted 8 000001000 Stopped 16 000010000 WaitSleepJoin 32 000100000 Suspended 64 001000000 AbortRequested 128 010000000 Aborted 256 100000000 1 2 3 4 5 6 Thread th = new Thread(...); if ((th.ThreadState \u0026amp; ThreadState.Aborted) == ThreadState.Aborted) Console.WriteLine(\u0026#34;스레드가 정지했습니다.\u0026#34;); else if ((th.ThreadState \u0026amp; ThreadState.Stopped) == ThreadState.Stopped) Console.WriteLine(\u0026#34;스레드가 취소되었습니다.\u0026#34;); 인터럽트: 스레드를 임의로 종료하는 다른 방법 Thread.Interrupt()메소드 Thread.Abort()메소드는 강제로 종료하지만, Thread.Interrupt()메소드는 스레드가 동작중인 상태(Running 상태)를 피해서 WaitJoinSleep상태에 들어갔을 때 ThreadInterruptedException 예외를 던져서 스레드를 중지시킨다. 절대로 중단되면 안 되는 작업을 하고 있을 때는 중단되지 않는다는 보장을 받을 수 있다. 스레드 간의 동기화 동기화(Synchronization) 스레드의 자원에 대한 접근을 제어하는 방법이다. 스레드 동기화에서 가장 중요한 것은 자원을 한 번에 하나의 스레드가 사용하도록 보장하는 것이다. .NET은 lock 키워드와 Monitor 클래스를 제공한다. lock 키워드로 동기화하기\nlock 키워드로 코드 영역을 감싸주면 크리티컬 섹션으로 바꿀 수 있다. 한 스레드가 그 코드를 실행하고 마칠 때까지 다른 스레드는 그 코드 영역을 실행할 수 없다. lock 키원드의 매개변수로 사용하는 객체로 부적절한 것들이 있다. 외부 코드에서도 접근할 수 있는 것은 안 된다.\nthis Type 형식 typeof 연산자나 GetType()메소드는 피하자. string 형식 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Counter { const int LOOP_COUNT = 100; private readonly object thisLock; private int count; public int Count { get =\u0026gt; count; } public Counter() { thisLock = new object(); count = 0; } public void Increase() { int loopCount = LOOP_COUNT; while (loopCount-- \u0026gt; 0) { lock (thisLock) // 여기는 크리티컬 섹션이다 { count++; Console.WriteLine($\u0026#34;Increase: {count}\u0026#34;); } Thread.Sleep(1); } } public void Decrease() { int loopCount = LOOP_COUNT; while (loopCount-- \u0026gt; 0) { lock (thisLock) // 여기는 크리티컬 섹션이다 { count--; Console.WriteLine($\u0026#34;Decrease: {count}\u0026#34;); } Thread.Sleep(1); } } } class MainApp { static void Main(string[] args) { Counter counter = new Counter(); // 두 개의 스레드 Thread inc = new Thread(new ThreadStart(counter.Increase)); Thread dec = new Thread(new ThreadStart(counter.Decrease)); // 스레드 시작 inc.Start(); dec.Start(); // 스레드가 끝날 때까지 기다린다 inc.Join(); dec.Join(); Console.WriteLine($\u0026#34;Count: {counter.Count}\u0026#34;); // 0 } } Monitor 클래스로 동기화하기 lock 키워드로 똑같은 기능을 하는 Monitor.Enter()(크리티컬 섹션 만들기)와 Monitor.Exit()(크리티컬 섹션 제거하기)이 있다. lock 키워드도 사실은 이 두 메서드들을 바탕으로 구현되어있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void Increase() { int loopCount = LOOP_COUNT; while (loopCount-- \u0026gt; 0) { Monitor.Enter(thisLock); try { count++; } finally { Monitor.Exit(thisLock); } Thread.Sleep(1); } } lock보다 좀 더 섬세하게 멀티 스레드 간의 동기화를 가능하게 해주는 메서드들\u0026hellip; Monitor.Wait()메서드 스레드를 WaitSleepJoin상태로 만든다. 해당 스레드는 갖고 있던 lock을 내려놓고 Waiting Queue에 입력된다. Monitor.Pulse()메서드 CLR은 Waiting Queue에서 첫 번째 위치에 있는 스레드를 꺼내서 Ready Queue에 입력시킨다. 그 스레드는 차례로 lock을 얻어서 Running상태에 들어간다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public void Increase() { int loopCount = LOOP_COUNT; while (loopCount-- \u0026gt; 0) { lock (thisLock) { // count가 0보다 크거나 // 다른 스레드에 의해 lockedCount가 true가 되면 // Wait()으로 블록된다. while (count \u0026gt; 0 || lockedCount == true) Monitor.Wait(thisLock); lockedCount = true; // 다른 스레드가 사용하지 못하도록한다. count++; lockedCount = false; Monitor.Pulse(thisLock); // 다른 스레드를 깨운다. } Thread.Sleep(1); } } Task와 Task 그리고 Parallel 지금까지 보았던 멀티 스레드는\u0026hellip; 여러 개의 작업을 각각 처리해야하는 상황이었다. (쪼갠 것 아님) 지금부터 볼 병렬 처리는\u0026hellip; 하나의 작업을 쪼갠 뒤 쪼개진 작업들을 동시에 처리하는 것이다. 비동기(Asynchronous) 처리는\u0026hellip; 메소드를 호출한 뒤에 메소드의 종료를 기다리지 않고 바로 다음 코드를 실행하는 것이다. System.Threading.Tasks.Task 클래스 Task 클래스 비동기적으로 실행되는 단일 작업이다. 인스턴스를 생성할 때 Action 대리자를 넘겨받는다. 즉, 반환형을 갖지 않는 메소드, 익명 메소드, 무명 함수 등을 넘겨받는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 실행할 작업물 Action action = () =\u0026gt; { Thread.Sleep(1000); // 이 코드에 상관없이 \u0026#34;동기\u0026#34;가 출력된다. Console.WriteLine(\u0026#34;비동기\u0026#34;); }; // Task로 할당 Task task = new Task(action); // 비동기로 실행한다. task.Start(); Console.WriteLine(\u0026#34;동기\u0026#34;); // 비동기 코드가 완료될 때까지 대기한다. task.Wait(); 1 2 3 4 5 6 7 8 9 10 11 12 // 위와 같은 코드인데 // Task의 생성과 시작을 한번에 한다. var task = Task.Run(() =\u0026gt; { Thread.Sleep(1000); Console.WriteLine(\u0026#34;비동기\u0026#34;); }); Console.WriteLine(\u0026#34;동기\u0026#34;); task.Wait(); 코드의 비동기 실행 결과를 주는 Task 클래스 Task\u0026lt;Result\u0026gt; 클래스 비동기 실행 결과를 손쉽게 얻을 수 있다. 인스턴스를 생성할 때 Func 대리자를 넘겨받아서 결과를 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var task = Task\u0026lt;List\u0026lt;int\u0026gt;\u0026gt;.Run(() =\u0026gt; { Thread.Sleep(1000); List\u0026lt;int\u0026gt; list = new List\u0026lt;int\u0026gt;(); list.Add(3); list.Add(4); list.Add(5); return list; }); task.Wait(); List\u0026lt;int\u0026gt; total = new List\u0026lt;int\u0026gt;(); total.Add(0); total.Add(1); total.Add(2); total.AddRange(task.Result.ToArray()); // 0, 1, 2, 3, 4, 5 손쉬운 병렬 처리를 가능케 하는 Parallel 클래스 System.Threading.Tasks.Parallel 클래스 For(), Foreach() 등의 메소드로 병렬 처리를 좀 더 쉽게 구현할 수 있다. 해당 메소드를 병렬로 호출할 때 몇 개의 스레드를 사용할지는 Parallel클래스가 내부적으로 판단하여 최적화한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 List\u0026lt;int\u0026gt; total = new List\u0026lt;int\u0026gt;(); // 0부터 100사이의 정수를 메소드의 인수로 넘긴다. // 병렬로 처리된다. Parallel.For(0, 100, (int i) =\u0026gt; { if (i % 2 == 0) lock (total) total.Add(i); }); for (int i = 0; i \u0026lt; total.Count; i++) Console.Write($\u0026#34;{total[i]} \u0026#34;); async 한정자와 await 연산자로 만드는 비동기 코드 async 한정자\n컴파일러에게 해당 메서드가 비동기 작업이 포함된 await를 가지고 있음을 알려준다. 내부에서 await 연산자를 찾으면 그곳에서 호출자에게 제어를 돌려준다. 내부에서 await 연산자를 만나지 못하면 제어를 돌려주지 않으므로, 그냥 동기적으로 실행하게 된다. 반환 형식 void: 실행하고 잊어버릴 작업을 수행하는 메소드일 때. 리턴형이 없으므로 비동기 메서드를 호출하는 쪽에서 비동기 제어를 할 수 없게 된다. Task: 리턴값이 없는 경우. Task\u0026lt;Result\u0026gt;: 리턴값이 있는 경우. await 연산자\n단항 연산자이며 awaitable 클래스(GetAwaiter()메서드를 갖는다)를 인수로 갖는다. 이것은 Task 혹은 Task\u0026lt;T\u0026gt; 가 일반적이다. 이 작업을 하는 동안 스레드가 차단되지 않도록(다른 일도 할 수 있도록)한다. 그리고 그 결과를 사용하기 전에 해당 Task가 끝날 때까지 기다린다. 완료 되면 다음 실행문부터 실행을 계속한다. async 메소드의 리턴형 종류 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // void public async void AsyncFunc() { } // Task public async Task AsyncFunc() { await Task.Delay(1000); } // Task\u0026lt;TResult\u0026gt; public async Task\u0026lt;int\u0026gt; AsyncFunc() { await Task.Delay(1000); return 1; } void 를 반환하는 async 메서드 1 2 3 4 5 6 7 8 9 10 11 public static void Main(string[] args) { TaskTest(); System.Console.WriteLine(\u0026#34;Main Thread is NOT Blocked\u0026#34;); Console.ReadLine(); } private static async void TaskTest() { await Task.Delay(5000); // 5초를 기다린다. System.Console.WriteLine(\u0026#34;TaskTest Done\u0026#34;); } Task를 반환하는 async 메서드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // async 한정자가 있으므로 await를 가질 수 있다. public static async Task Main(string[] args) { Task t = TaskTest1(); System.Console.WriteLine(\u0026#34;Do Something Before TaskTest\u0026#34;); await t; // 여기서 t가 끝날 때까지 기다린다. System.Console.WriteLine(\u0026#34;Do Something after TaskTest\u0026#34;); Console.ReadLine(); } private static async Task TaskTest1() { await Task.Delay(5000); // 5초를 기다린다. System.Console.WriteLine(\u0026#34;TaskTest Done\u0026#34;); } Task\u0026lt;TResult\u0026gt;를 반환하는 async 메서드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static async Task Main(string[] args) { Task\u0026lt;int\u0026gt; t = TaskTest(); for(int i = 0; i \u0026lt; 10; i++) { System.Console.WriteLine(\u0026#34;Do Something Before TaskTest\u0026#34;); } int UID = await t; // await을 통해서 반환값을 추출할 수 있다. Console.WriteLine($\u0026#34;UserID : {UID}\u0026#34;); Console.ReadLine(); } private static async Task\u0026lt;int\u0026gt; TaskTest() { int UID = await ...; // DB or server에서 UID 얻어오는 비동기 메서드 호출 System.Console.WriteLine(\u0026#34;TaskTest Done\u0026#34;); return UID; } await와 async 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 async static private void AsyncMethod(int count) { Console.WriteLine(\u0026#34;B\u0026#34;); // 호출자에게 제어를 돌려주고 아래 코드는 비동기적으로 처리된다. // 아래 Task가 끝나야지 다음 문장이 실행 된다. await Task.Run(async () =\u0026gt; { for (int i = 0; i \u0026lt; count; i++) { Console.WriteLine($\u0026#34;{i} / {count} ...\u0026#34;); await Task.Delay(100); // Thread.Sleep()의 비동기 버전이다. } }); Console.WriteLine(\u0026#34;D\u0026#34;); } static void Caller() { Console.WriteLine(\u0026#34;A\u0026#34;); AsyncMethod(3); Console.WriteLine(\u0026#34;C\u0026#34;); } static void Main(string[] args) { Caller(); Console.ReadLine(); // (프로그램 종료 방지) } 1 2 3 4 5 6 7 A B C 0 / 3 ... 1 / 3 ... 2 / 3 ... D ","date":"2022-05-08T16:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-19/","title":"[This is C#] Chapter 19. 스레드와 태스크"},{"content":" 람다식 람다식(Lambda Expression) Chapter 13에서도 보았던 익명 메소드를 만들기 위해 사용한다. 림다식으로 만드는 익명 메소드는 무명 함수(Anonymouse Function) 라고 부른다. C# 컴파일러는 형식 유추(Type Inference)라는 기능을 제공한다. 형식 유추를 사용하면 람다식에서 매개변수의 형식을 제거할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 delegate int Calculate(int a, int b); class MainApp { static void Main(string[] args) { // 익명 메소드 Calculate calc1 = delegate (int a, int b) { return a + b; }; // 람다식으로 만든 무명 함수 (형식 유추로 매개변수의 형식을 제거할 수 있다.) Calculate calc2 = (a, b) =\u0026gt; a + b; } } 문 형식의 람다식 문 형식의 람다 식(Statement Lambda) a + b같은 식이 아니라 if (a == b) return 0; else return 1;같은 문장을 사용할 수 있는 람다 식이다. =\u0026gt;연산자의 오른편이 { }과 같은 코드 블록을 만든다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 delegate void DoSomething(); class MainApp { static void Main(string[] args) { // 문 형식의 람다 식 DoSomething doIt = () =\u0026gt; { Console.WriteLine(\u0026#34;뭔가를\u0026#34;); Console.WriteLine(\u0026#34;출력해\u0026#34;); Console.WriteLine(\u0026#34;보자!\u0026#34;); }; doIt(); } } Func와 Action으로 더 간편하게 무명 함수 만들기 .NET 안에 미리 선언되어 있는 대리자들이다. Func 대리자 Func 대리자 결과를 반환하는 메소드를 참조하기 위해 만들어졌다. 1 2 3 4 5 6 static void Main(string[] args) { Func\u0026lt;int\u0026gt; func1 = () =\u0026gt; 1; Func\u0026lt;int, int\u0026gt; func2 = (a) =\u0026gt; a + 1; Func\u0026lt;int, int, int\u0026gt; func3 = (a, b) =\u0026gt; a + b + 1; } Action 대리자 Action 대리자 반환 형식이 없는 메소드를 참조하기 위해 만들어졌다. 1 2 3 4 5 6 7 8 9 static void Main(string[] args) { Action action1 = () =\u0026gt; Console.WriteLine(\u0026#34;Hello\u0026#34;); int result = 0; Action\u0026lt;int\u0026gt; action2 = (a) =\u0026gt; result = a; Action\u0026lt;int, int\u0026gt; action3 = (a, b) =\u0026gt; result = a + b; } 식 트리 식 트리(Expression Tree) 식을 트리 구조로 표현한 것이다. C#은 프로그래머가 코드로 직접 식 트리를 조립하고 컴파일해서 사용할 수 있다. 식 드리를 다루는 데 필요한 클래스들은 System.Linq.Expressions 네임스페이스 안에 준비되어 있다. 모두 Expression 클래스의 파생 클래스들이다. Expression 클래스 자신은 abstract 클래스여서 자신의 인스턴스를 만들 수는 없지만, 파생 클래스의 인스턴스를 생성하는 정적 팩토리 메소드를 제공한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Expression const1 = Expression.Constant(1); Expression const2 = Expression.Constant(2); Expression leftExp = Expression.Multiply(const1, const2); // 1 * 2 Expression param1 = Expression.Parameter(typeof(int)); // x Expression param2 = Expression.Parameter(typeof(int)); // y Expression righExp = Expression.Subtract(param1, param2); // x - y Expression exp = Expression.Add(leftExp, righExp); // (1 * 2) + (x - y) // body Expression\u0026lt;Func\u0026lt;int, int, int\u0026gt;\u0026gt; expression = Expression\u0026lt;Func\u0026lt;int, int, int\u0026gt;\u0026gt;.Lambda\u0026lt;Func\u0026lt;int, int, int\u0026gt;\u0026gt;( exp, new ParameterExpression[] {(ParameterExpression) param1, (ParameterExpression) param2} ); Func\u0026lt;int, int, int\u0026gt; func = expression.Compile(); Console.WriteLine($\u0026#34;{func(7, 8)}\u0026#34;); // 1 람다 식을 이용하면 더 간편하게 식 트리를 만들 수 있다. 다만 이 경우에는 동적으로 식 트리를 만들기는 어려워진다. 1 2 3 4 5 Expression\u0026lt;Func\u0026lt;int, int, int\u0026gt;\u0026gt; expression = (a, b) =\u0026gt; (1 * 2) + (a - b); Func\u0026lt;int, int, int\u0026gt; func = expression.Compile(); Console.WriteLine($\u0026#34;{func(7, 8)}\u0026#34;); // 1 식으로 이루어지는 멤버 클래스의 멤버 중에서 본문이 중괄호로 만들어져 있는 것들 메소드, 생성자, 종료자, 프로퍼티, 인덱서 이것은 모두 본문을 식으로만 구현할 수 있다. 이것을 식 본문 멤버(Expression-Bodied Member) 라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class MyList { private List\u0026lt;int\u0026gt; list = new List\u0026lt;int\u0026gt;(); // 읽기 전용 프로퍼티와 인덱서 public int Capacity =\u0026gt; list.Capacity; public int this[int idx] =\u0026gt; list[idx]; // 읽기, 쓰기 모두 가능한 프로퍼티와 인덱서 public int Capacity { get =\u0026gt; list.Capacity; set =\u0026gt; list.Capacity = value; } public int this[int idx] { get =\u0026gt; list[idx]; set =\u0026gt; list[idx] = value; } // 생성자와 소멸자 public MyList() =\u0026gt; Console.WriteLine(\u0026#34;Hello\u0026#34;); ~MyList() =\u0026gt; Console.WriteLine(\u0026#34;Bye\u0026#34;); // 메서드들 public void Add(int val) =\u0026gt; list.Add(val); public void Remove(int val) =\u0026gt; list.Remove(val); } ","date":"2022-05-08T11:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-14/","title":"[This is C#] Chapter 14. 람다식"},{"content":" 대리자 대리자(Delegate) 메소드에 대한 참조이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 델리게이트 형식(Type) delegate int MyDelegate(int a, int b); class Calc { public int Add(int x, int y) { return x + y; } public int Minus(int x, int y) { return x - y; } } class MainApp { static void Main(string[] args) { Calc calc = new Calc(); // 델리게이트 인스턴스 생성 및 등록 MyDelegate callback = new MyDelegate(calc.Add); // 델리게이트 호출 Console.WriteLine($\u0026#34;{callback(3, 4)}\u0026#34;); // 7 callback = new MyDelegate(calc.Minus); Console.WriteLine($\u0026#34;{callback(5, 4)}\u0026#34;); // 1 } } 대리자는 왜, 언제 사용할까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 delegate int Compare(int a, int b); class MainApp { static int AscendCompare(int a, int b) { if (a \u0026gt; b) return 1; else if (a == b) return 0; else return -1; } static int DescendCompare(int a, int b) { if (a \u0026lt; b) return 1; else if (a == b) return 0; else return -1; } // 델리게이트를 매개변수로 사용함 static void BubbleSort(int[] data, Compare comparer) { int temp = 0; for (int i = 0; i \u0026lt; data.Length - 1; i++) { for (int j = 0; j \u0026lt; data.Length - (i + 1); j++) { if (comparer(data[j], data[j + 1]) \u0026gt; 0) { temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; } } } } static void Main(string[] args) { int[] arr = {8, 7, 3, 5, 1}; BubbleSort(arr, new Compare(AscendCompare)); for (int i = 0; i \u0026lt; arr.Length; i++) Console.Write($\u0026#34;{arr[i]} \u0026#34;); // 1 3 5 7 8 } } 일반화 대리자 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 delegate int Compare\u0026lt;T\u0026gt;(T a, T b); class MainApp { // System.Int32와 같은 모든 수치 형식과 System.String은 모두 IComparable을 상속해서 CompareTo()를 구현하고 있다. // CompareTo()는 매개변수가 자신보다 크면 -1, 같으면 0, 작으면 1을 반환한다. static int AscendCompare\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { return a.CompareTo(b); } static int DescendCompare\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { return a.CompareTo(b) * -1; } // 델리게이트를 매개변수로 사용함 static void BubbleSort\u0026lt;T\u0026gt;(T[] data, Compare\u0026lt;T\u0026gt; comparer) { T temp; for (int i = 0; i \u0026lt; data.Length - 1; i++) { for (int j = 0; j \u0026lt; data.Length - (i + 1); j++) { if (comparer(data[j], data[j + 1]) \u0026gt; 0) { temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; } } } } static void Main(string[] args) { int[] arr = {8, 7, 3, 5, 1}; BubbleSort\u0026lt;int\u0026gt;(arr, new Compare\u0026lt;int\u0026gt;(AscendCompare)); for (int i = 0; i \u0026lt; arr.Length; i++) Console.Write($\u0026#34;{arr[i]} \u0026#34;); // 1 3 5 7 8 } } 대리자 체인 대리자 하나가 여러 개의 메소드를 동시에 참조할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 delegate void Notify(string mesg); class MainApp { static void Call119(string location) { Console.WriteLine(\u0026#34;Call119\u0026#34;); } static void ShotOut(string location) { Console.WriteLine(\u0026#34;ShotOut\u0026#34;); } static void Escape(string location) { Console.WriteLine(\u0026#34;Escape\u0026#34;); } static void Main(string[] args) { // 델리게이트 체인 (추가 방법1) Notify notify1 = new Notify(Call119); notify1 += ShotOut; notify1 += Escape; // (추가 방법2) Notify notify2 = new Notify(Call119) + new Notify(ShotOut) + new Notify(Escape); // (추가 방법3) Notify notify3 = (Notify) Delegate.Combine(new Notify(Call119), new Notify(ShotOut), new Notify(Escape)); // (삭제 방법1) notify1 -= Call119; // ShotOut Escape // (삭제 방법2) notify3에서 notify2에 있는 것을 뺀다. notify3 = (Notify) Delegate.Remove(notify3, notify1); // Call119 } } 익명 메소드 익명 메소드(Anonymous Method) 이름이 없는 메소드이다. 메소드가 델리게이트에 의해 참조 된 후로 사용할 일이 다시 없다고 한다면 익명 메소드로 선언하면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 delegate int Calculate(int a, int b); class MainApp { static void Main(string[] args) { // 익명 메소드 Calculate calc = delegate(int a, int b) { return a + b; }; calc(1, 3); // 4 } } 이벤트 이벤트\n델리게이트에 event 키워드를 붙여서 사용한다. 이벤트와 델리게이트의 차이점\n이벤트는 public 한정자로 선언돼 있어도 자신이 선언된 클래스 외부에서는 호출이 불가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 델리게이트 형식 delegate void Notify(string mesg); class MyClass { // 델리게이트 인스턴스 생성 + event 한정자 public event Notify OnSomethingHappened; public void DoSometing(int number) { // 이벤트 호출 if (number % 2 == 0) OnSomethingHappened(String.Format(\u0026#34;{0} : 짝\u0026#34;, number)); } } class MainApp { static public void PrintMesg(string mesg) { Console.WriteLine(mesg); } static void Main(string[] args) { MyClass myClass = new MyClass(); // 이벤트 등록 myClass.OnSomethingHappened += new Notify(PrintMesg); for (int i = 1; i \u0026lt; 30; i++) { myClass.DoSometing(i); } // event 한정자를 붙이면 클래스 밖에서 호출이 안 된다. myClass.OnSomethingHappened(\u0026#34;클래스 밖에서 호출해보기\u0026#34;); // 컴파일 에러! } } 미리 정의된 대리자들 델리게이트는 형식을 만들고, 인스턴스를 또 생성하여서 사용해야한다. 모든 타입의 형태로 미리 정의된 델리게이트를 간단하게 쓸 수 있는 기능이 바로 Action 과 Func 이다. 이것들은 별도로 미리 정의하지 않아도 한 줄로 표현 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // delegate의 경우 미리 정의해야 한다. delegate void MyDelegate(string mesg); public class MyClass { static void Main(string[] args) { // 그리고 인스턴스를 만들어서 사용한다. // C# 2.0에서는 new 없이 간단하게 인스턴스를 만들 수 있다. MyDelegate myDelegate = ShowMessage; myDelegate(\u0026#34;Hello\u0026#34;); } static void ShowMessage(string mesg) { Console.WriteLine(mesg); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class MyClass { static void Main(string[] args) { // Action의 경우 바로 쓸 수 있다. Action\u0026lt;string\u0026gt; myAction = ShowMessage; myAction(\u0026#34;Hello\u0026#34;); } static void ShowMessage(string mesg) { Console.WriteLine(mesg); } } Action 대리자 반환값이 없는 대리자이다. 매개변수를 16개까지 넣을 수 있다. Action, Action\u0026lt;T\u0026gt;, Action\u0026lt;T1, T2\u0026gt; \u0026hellip; Func 대리자 반환값이 1개 있는 대리자이다. 매개변수를 16개까지 넣을 수 있다. Func\u0026lt;TResult\u0026gt;, Func\u0026lt;T, TResult\u0026gt;, Func\u0026lt;T1, T2, TResult\u0026gt; \u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MyClass { static void Main(string[] args) { Func\u0026lt;int, int, int\u0026gt; myAction = Add; Console.WriteLine(myAction(1, 2)); } static int Add(int a, int b) { return a + b; } } EventHandler 대리자 형식이 지정된 대리자이다. 반환값은 없다. 첫 번째 매개변수는 object 이며 이벤트를 발생시키는 인스턴스를 참조한다. 두 번째 매개변수는 EventArgs 에서 파생된 것이며 이벤트 데이터를 보유한다. EventHandler 이벤트 데이터가 없는 이벤트를 처리할 때 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Publisher { // 이벤트 데이터가 없는 이벤트를 처리할 때 public event EventHandler MyEventHandler; public void DoSometing() { MyEventHandler(this, EventArgs.Empty); } } public class Subscriber { public void HanldeEvent(object sender, EventArgs e) { Console.WriteLine(\u0026#34;Something happened to \u0026#34; + sender.ToString()); Console.ReadLine(); } } public class MainApp { static void Main(string[] args) { Publisher publisher = new Publisher(); Subscriber subscriber = new Subscriber(); publisher.MyEventHandler += subscriber.HanldeEvent; publisher.DoSometing(); } } EventHandler\u0026lt;EventArgs\u0026gt; 이벤트 데이터가 있는 이벤트를 처리할 때 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 이벤트 데이터 public class MyEventArgs : EventArgs { public int Id { get; set; } public string Name { get; set; } } public class Publisher { // 이벤트 데이터가 있는 이벤트를 처리할 때 public event EventHandler\u0026lt;MyEventArgs\u0026gt; MyEventHandler; public void DoSometing() { MyEventArgs myArgs = new MyEventArgs(); myArgs.Id = 1; myArgs.Name = \u0026#34;Kim\u0026#34;; MyEventHandler(this, myArgs); } } public class Subscriber { public void HanldeEvent(object sender, MyEventArgs e) { Console.WriteLine(\u0026#34;Something happened to \u0026#34; + sender.ToString()); Console.WriteLine(\u0026#34;Name: \u0026#34; + e.Name + \u0026#34;, Id: \u0026#34; + e.Id); Console.ReadLine(); } } public class MainApp { static void Main(string[] args) { Publisher publisher = new Publisher(); Subscriber subscriber = new Subscriber(); publisher.MyEventHandler += subscriber.HanldeEvent; publisher.DoSometing(); } } 대리자를 호출하는 Invoke() 메서드 지금까지 우리는 단순히 대리자를 일반 메서드처럼 호출했지만, 본래는 Invoke() 메서드를 호출하는 것이다. 1 2 3 4 Action myAction = MyMethod; myAction.Invoke(); // Invoke() 메서드 사용 myAction(); // 생략 가능 이벤트 구독할 때 가비지를 발생시키지 않는 방법 참고 사이트 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private event Action cashedAction; private event Action myAction; void Awake() { // 미리 모두 캐시해 놓고 나중에 추가한다. cashedAction = MyMethod; // new Action(MyMethod)이므로 가비지발생 } void Start() { myAction += cashedAction; // 여기서는 가비지가 발생하지 않게된다. } void MyMethod() { //... } 중복으로 이벤트를 구독 할 위험을 줄여주는 방법 event 키워드가 있는 경우 add{} 와 remove{} 접근자를 정의할 수 있다. add{} 에서 이벤트를 구독할 때, 한번 뺀 후 추가함으로써 중복으로 구독할 위험을 줄여준다. 1 2 3 4 5 6 7 8 9 10 11 12 private event Action myAction { add { myAction -= value; // 중복으로 넣을 위험을 줄여준다. myAction += value; } remove { myAction -= value; } } ","date":"2022-05-08T10:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-13/","title":"[This is C#] Chapter 13. 대리자와 이벤트"},{"content":" 일반화 프로그래밍 일반화(Generalization) 공통된 개념을 찾아 묶는 것이다. 일반화 메소드 일반화 메소드(Generic Method) 데이터 형식을 일반화한 메소드이다. 구체적인 형식대신 형식 매개변수(Type Parameter) 가 들어간다. 1 2 3 4 5 6 // 일반화 메소드. T는 형식 매개변수이다. void CopyArr\u0026lt;T\u0026gt;(T[] source, T[] target) { for (int i = 0; i \u0026lt; source.Length; i++) target[i] = source[i]; } 일반화 클래스 일반화 클래스(Generic Class) 데이터 형식을 일반화한 클래스이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 제네릭 클래스 class GenericArr\u0026lt;T\u0026gt; { private T[] arr = new T[3]; // 인덱서 public T this[int idx] { get { return arr[idx]; } set { if (idx \u0026gt;= arr.Length) Array.Resize\u0026lt;T\u0026gt;(ref arr, idx + 1); arr[idx] = value; } } } class MainApp { static void Main(string[] args) { GenericArr\u0026lt;int\u0026gt; m = new GenericArr\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; 5; i++) m[i] = i; for (int i = 0; i \u0026lt; 5; i++) Console.WriteLine($\u0026#34;{m[i]}\u0026#34;); // 0, 1, 2, 3, 4 } } 형식 매개변수 제약시키기 형식 매개변수 T는 모든 데이터 형식을 대신할 수 있다. 이것은 where절을 추가함으로써 제약시킬 수 있다. 제약 설명 where T : struct T는 값 형식이어야 한다. where T : class T는 참조 형식이어야 한다. where T : new() T는 반드시 매개변수가 없는 생성자가 있어야 한다. where T : 기반 클래스 이름 T는 명시한 기반 클래스이거나 그의 파생 클래스여야 한다. where T : 인터페이스 이름 T는 명시한 인터페이스를 구현해야한다. 여러 개의 인터페이스를 명시할 수도 있다. where T : U T는 U로부터 상속받은 클래스여야한다. 일반화 컬렉션 System.Collections.Generic 네임스페이스는 다양한 일반화 컬렉션들을 담고 있다. 일반화 컬렉션은 박싱과 언박싱같은 형식 변환이 매번 일어나지 않기 때문에 좋다. 용도 제네릭 논-제네릭 인덱스 별로 엑세스 List\u0026lt;T\u0026gt; Array, ArrayList 순서대로 액세스 LinkedList\u0026lt;T\u0026gt; FIFO 방식으로 사용 Queue\u0026lt;T\u0026gt; Queue LIFO 방식으로 사용 Stack\u0026lt;T\u0026gt; Stack 키/값 쌍으로 저장 Dictionary\u0026lt;TKey, TValue\u0026gt; Hashtable 추가, 삭제 시 알림 표시 ObservableCollection\u0026lt;T\u0026gt; 정렬된 컬렉션 SortedList\u0026lt;TKey, TValue\u0026gt; SortedList 수학 함수용 집합 HashSet\u0026lt;T\u0026gt; foreach를 사용할 수 있는 일반화 클래스 IEnumerable\u0026lt;T\u0026gt;인터페이스를 구현하면 형식 변환 없이 일반화 클래스로 foreach를 사용할 수 있겠다. IEnumerator GetEnumerator() IEnumerator\u0026lt;T\u0026gt; GetEnumerator() bool MoveNext() void Reset() object Current {get;} T Currnet {get;} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class MyList\u0026lt;T\u0026gt; : IEnumerable\u0026lt;T\u0026gt;, IEnumerator\u0026lt;T\u0026gt; { private T[] arr = new T[3]; private int pos = -1; // 인덱서 public T this[int idx] { get { return arr[idx]; } set { if (idx \u0026gt;= arr.Length) Array.Resize\u0026lt;T\u0026gt;(ref arr, idx + 1); arr[idx] = value; } } // IEnumerator의 메소드 및 프로퍼티 object IEnumerator.Current { get { return arr[pos]; } } public T Current { get { return arr[pos]; } } public bool MoveNext() { if (pos == arr.Length - 1) { Reset(); return false; } pos++; return (pos \u0026lt; arr.Length); } public void Reset() { pos = -1; } // IEnumerable의 메소드 IEnumerator IEnumerable.GetEnumerator() { return this; } public IEnumerator\u0026lt;T\u0026gt; GetEnumerator() { return this; } public void Dispose() { //... } } class MainApp { static void Main(string[] args) { MyList\u0026lt;int\u0026gt; m = new MyList\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; 5; i++) m[i] = i; // foreach문이 가능! foreach (int number in m) Console.WriteLine($\u0026#34;{ number }\u0026#34;); // 0, 1, 2, 3, 4 } } ","date":"2022-05-07T13:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-11/","title":"[This is C#] Chapter 11. 일반화 프로그래밍"},{"content":" 배열 배열을 선언하는 방법 1 2 // 요소가 5개인 int형 배열 int[] arr = new int[5]; System.Index형식과 ^연산자 ^연산자는 컬렉션의 마지막부터 연순으로 인덱스를 지정하는 기능을 갖고 있다. 따라서 ^1은 컬렉션의 마지막요소를 나타내는 인덱스이다. Length - 1이라고 생각하면 쉽다. 1 2 3 4 5 6 // 배열의 마지막 요소에 접근하기 System.Index last = ^1; arr[last] = 5; // 이렇게 간결하게 할 수도 있다. arr[^1] = 5; 배열을 초기화하는 방법 세 가지 배열을 초기화하는 방법 세 가지 1 2 3 string[] arr1 = new string[3] { \u0026#34;Hi\u0026#34;, \u0026#34;Hello\u0026#34;, \u0026#34;What\u0026#39;s up\u0026#34; }; string[] arr2 = new string[] { \u0026#34;Hi\u0026#34;, \u0026#34;Hello\u0026#34;, \u0026#34;What\u0026#39;s up\u0026#34; }; string[] arr3 = { \u0026#34;Hi\u0026#34;, \u0026#34;Hello\u0026#34;, \u0026#34;What\u0026#39;s up\u0026#34; }; System.Array .NET의 CTS에서 배열은 System.Array에서 파생된 것이다. 따라서 System.Array 클래스에 있는 메소드와 프로퍼티를 이용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 private static void Print(int val) { Console.WriteLine($\u0026#34;{val} \u0026#34;); } private static bool CheckPassed(int score) { return score \u0026gt;= 60; } static void Main(string[] args) { int[] scores = new int[] {90, 80, 70, 60, 50}; // 정렬하기 Array.Sort(scores); // 출력하기 //Array.ForEach\u0026lt;int\u0026gt;(scores, new Action\u0026lt;int\u0026gt;(Print)); // 차원 int rank = scores.Rank; // 길이 int length = scores.Length; // 이진 탐색하기 int bs = Array.BinarySearch\u0026lt;int\u0026gt;(scores, 80); // 모든 요소가 조건에 부합하는지 bool isTrue = Array.TrueForAll\u0026lt;int\u0026gt;(scores, CheckPassed); // 조건에 부합하는 첫 번째 요소의 인덱스 찾기 int findIdx = Array.FindIndex\u0026lt;int\u0026gt;(scores, (score) =\u0026gt; score \u0026lt; 60); // 길이 변경하기 Array.Resize\u0026lt;int\u0026gt;(ref scores, 10); // 숫자는 0으로, 논리는 false로, 참조는 null로 초기화하기 // 3번째 인덱스부터 7개 요소를 초기화한다. Array.Clear(scores, 3, 7); // 복사하기 // scores의 0번째 인덱스부터 3개 요소를 sliced의 0번째 인덱스를 시작으로 복사한다. int[] sliced = new int[3]; Array.Copy(scores, 0, sliced, 0, 3); } 배열 분할하기 System.Range 객체를 사용하면 배열을 쉽게 분할할 수 있다. 시작 인덱스..마지막 인덱스 마지막 인덱스는 포함하지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int[] arr = new int[6]; // 배열 분할하기 System.Range range = 0..4; // 0~3 인덱스 int[] sliced1 = arr[range]; // 이렇게 간결하게 할 수도 있다. int[] sliced2 = arr[0..4]; // 생략하면 첫 시작과 끝을 의미한다. int[] sliced3 = arr[..]; // 0~5 전체 int[] sliced4 = arr[..4]; // 0~3 int[] sliced5 = arr[2..]; // 2~5 // ^연산자를 사용할수도 있다. int[] sliced6 = arr[..^3]; // 0~3 2차원 배열 2차원 배열 1 2 3 4 5 6 7 8 // 2차원 배열의 선언 int[,] arr2d = new int[2, 3]; // 2행 3열 arr2d[0, 2] = 1; // 1행 3열 // 2차원 배열의 초기화 int[,] arr2d1 = new int[2, 3] { { 1, 2, 3 }, { 4, 5, 6 } }; int[,] arr2d2 = new int[,] { { 1, 2, 3 }, { 4, 5, 6 } }; int[,] arr2d3 = { { 1, 2, 3 }, { 4, 5, 6 } }; 다차원 배열 3차원 배열 왠만하면 쓰지 않는 것이 좋다. 1 2 3 4 5 6 7 int[,,] arr3d = new int[4, 3, 2] { { {1, 2}, {3, 4}, {5, 6} }, { {1, 2}, {3, 4}, {5, 6} }, { {1, 2}, {3, 4}, {5, 6} }, { {1, 2}, {3, 4}, {5, 6} } }; 가변 배열 가변 배열(Jagged Array) 다양한 길이의 배열을 요소로 갖는 다차원 배열이다. \u0026lsquo;Jagged\u0026rsquo;란 \u0026lsquo;들쭉날쭉한\u0026rsquo;을 의미한다. 1 2 3 4 5 6 7 8 9 10 int[][] jagged = new int[3][]; jagged[0] = new int[5] {1, 2, 3, 4, 5}; jagged[1] = new int[3] {10, 20, 30}; jagged[2] = new int[2] {100, 200}; string[][] jagged2 = new string[2][] { new string[3] {\u0026#34;Hello\u0026#34;, \u0026#34;Hi\u0026#34;, \u0026#34;What\u0026#39;s up\u0026#34;}, new string[2] {\u0026#34;Good\u0026#34;, \u0026#34;Bye\u0026#34;} }; 컬렉션 맛보기 컬렉션(Collection)\n.NET이 제공하는 데이터를 담는 자료구조이다. ICollection 인터페이스를 상속해야한다. ArrayList는 다양한 형식을 객체를 담을 수 있다.\n이것은 매개변수로 object형식을 받고 있기 때문이다. 하지만 박싱과 언박싱은 오버헤드가 많아지므로 피하는 것이 좋다. 해결방법은? 나중에 일반화 컬렉션에서 찾아보도록 하자. 컬렉션 초기화 방법\nArrayList, Stack, Queue는 배열로 초기화할 수 있다. ArrayList는 컬렉션 초기자를 사용해서 초기화할 수 있다. Hashtable은 컬렉션 초기자나 딕셔너리 초기자를 사용해서 초기화할 수 있다. 컬렉션 초기자를 사용하기 위해서는 IEnumerable인터페이스와 Add()메소드를 구현해야한다. Stack과 Queue는 Add()메소드를 구현하지 않기 때문에 컬렉션 초기자를 사용하지 못한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int[] arr = {1, 2, 3}; // 배열을 이용한 초기화 ArrayList list = new ArrayList(arr); Stack stack = new Stack(arr); Queue queue = new Queue(arr); // 컬렉션 초기자를 이용한 초기화 ArrayList list2 = new ArrayList() {1, 2, 3}; Hashtable hashtable = new Hashtable() { { \u0026#34;하나\u0026#34;, 1 }, { \u0026#34;둘\u0026#34;, 2 } , { \u0026#34;셋\u0026#34;, 3 } }; // 딕셔너리 초기자를 이용한 초기화 Hashtable hashtable2 = new Hashtable() { [\u0026#34;하나\u0026#34;] = 1, [\u0026#34;둘\u0026#34;] = 2, [\u0026#34;셋\u0026#34;] = 3 }; 인덱서 인덱서(Indexer) 인덱스를 이용해서 객체 내의 데이터에 접근하게 해주는 프로퍼티이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class MyList { private int[] arr = new int[3]; // 인덱서 public int this[int idx] { get { return arr[idx]; } set { // 사이즈 보다 인덱스가 크면 늘린 후 저장한다. if (idx \u0026gt;= arr.Length) Array.Resize\u0026lt;int\u0026gt;(ref arr, idx + 1); arr[idx] = value; } } } class MainApp { static void Main(string[] args) { MyList m = new MyList(); for (int i = 0; i \u0026lt; 5; i++) m[i] = i; for (int i = 0; i \u0026lt; 5; i++) Console.WriteLine($\u0026#34;{m[i]}\u0026#34;); // 0, 1, 2, 3, 4 } } foreach가 가능한 객체 만들기 foreach가 가능하기 위해서는 IEnumerable을 상속해야한다. 이 인터페이스는 IEnumerator GetEnumerator()라는 메소드 하나만 갖고 있다. yield문을 이용하면 따로 구현하지 않아도 컴파일러가 자동으로 처리해준다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MyList : IEnumerable { private int[] arr = new int[3] {0, 1, 2}; public IEnumerator GetEnumerator() { yield return arr[0]; yield return arr[1]; yield return arr[2]; yield break; yield return arr[3]; // 이 코드는 실행되지 않는다. } } class MainApp { static void Main(string[] args) { MyList m = new MyList(); foreach (int number in m) Console.WriteLine($\u0026#34;{ number }\u0026#34;); // 0, 1, 2 } } yield문 없이 IEnumerator를 직접 구현해보자.\nIEnumerator의 메소드 및 프로퍼티\n메소드 및 프로퍼티 설명 bool MoveNext() 다음 요소로 이동한다. 컬렉션의 끝을 넘어선 경우에는 false, 이동이 성공한 경우에는 true를 반환한다. void Reset() 컬렉션의 첫 번째 위치의 \u0026lsquo;앞\u0026rsquo;으로 이동한다. 첫 번째 위치로 이동하는 것은 MoveNext()를 호출한 다음에 이루어지므로 -1이다. object Current {get;} 컬렉션의 현재 요소를 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class MyList : IEnumerable, IEnumerator { private int[] arr = new int[3]; private int pos = -1; // 인덱서 public int this[int idx] { get { return arr[idx]; } set { if (idx \u0026gt;= arr.Length) Array.Resize\u0026lt;int\u0026gt;(ref arr, idx + 1); arr[idx] = value; } } // IEnumerator의 메소드 및 프로퍼티 public object Current { get { return arr[pos]; } } public bool MoveNext() { if (pos == arr.Length - 1) { Reset(); return false; } pos++; return (pos \u0026lt; arr.Length); } public void Reset() { pos = -1; } // IEnumerable의 메소드 public IEnumerator GetEnumerator() { return this; } } class MainApp { static void Main(string[] args) { MyList m = new MyList(); for (int i = 0; i \u0026lt; 5; i++) m[i] = i; // foreach문이 가능! foreach (int number in m) Console.WriteLine($\u0026#34;{ number }\u0026#34;); // 0, 1, 2, 3, 4 } } ","date":"2022-05-07T12:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-10/","title":"[This is C#] Chapter 10. 배열과 컬렉션 그리고 인덱서"},{"content":" public 필드의 유혹 은닉성을 위해서 필드를 private 으로 선언했다. 어떻게 편리하게 접근하고 값을 변경할 수 있을까? 메소드보다 프로퍼티 getter와 setter를 만드는 대신 프로퍼티를 사용해볼 수 있겠다. 프로퍼티(Property) get{}, set{}을 일컬어 접근자(Accessor)라고 한다. 쓰기 전용 프로퍼티 → set{} 접근자를 구현하지 않으면 되겠다. 읽기 전용 프로퍼티 → get{} 접근자를 구현하지 않으면 되겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyClass { private int num; // 필드 public int Num // 프로퍼티 { get { return num; } // get 접근자 set { num = value; } // set 접근자 } } class MainApp { static void Main(string[] args) { MyClass a = new MyClass(); int num = a.Num; // get 접근자로 읽기 가능 a.Num = 1; // set 접근자로 쓰기 가능 } } 자동 구현 프로퍼티 자동 구현 프로퍼티(Auto-Implemented Property) get{} , set{} 접근자에 조건이 없는 단순한 경우 좀 더 간결하게 코드를 작성할 수 있는 방법이다. 다음과 같은 코드는 위의 코드와 같은 코드가 된다. 1 2 3 4 class MyClass { public int Num { get; set; } // 자동 구현 프로퍼티 } 자동구현 프로퍼티는 선언과 동시화 초기화를 할 수 있다. 1 2 3 4 class MyClass { public int Num { get; set; } = 29; // 선언과 동시에 초기화 가능 } 프로퍼티로 초기화하기 객체를 생성할 때 생성자에 매개변수를 넘기는 대신, 프로퍼티를 사용해서 각 필드를 초기화할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class MyClass { public int Age { get; set; } } class MainApp { static void Main(string[] args) { MyClass a = new MyClass() // 프로퍼티를 사용해 초기화할 수 있다 { Age = 1 }; } } 읽기 전용 프로퍼티 (1) 초기화 전용(Init-Only) 자동 구현 프로퍼티 (C# 9.0) init 접근자를 사용한다. 객체를 초기화할 때 한 번 초기화가 이루어진 이후에는 변경할 수 없는 읽기 전용 프로퍼티이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyClass { public string Name { get; init; } // init 접근자 사용 } class MainApp { static void Main(string[] args) { MyClass a = new MyClass() // 초기화를 하였다. { Name = \u0026#34;Kim\u0026#34; }; a.Name = \u0026#34;Lee\u0026#34;; // (X) 초기화 후에는 변경이 불가능하다. } } (2) set{} 접근자를 지정하지 않는다. 생성자에서만 초기화가 가능하다. init{} 접근자의 경우처럼 프로퍼티를 사용해서 초기화할 수 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyClass { public string Name { get; } // set 접근자가 없는 읽기 전용 프로퍼티는 public MyClass() { Name = \u0026#34;Kim\u0026#34;; // 생성자에서만 초기화할 수 있다. } } class MainApp { static void Main(string[] args) { MyClass a = new MyClass() { Name = \u0026#34;Kim\u0026#34; // (X) 프로퍼티를 사용해 초기화하는 것이 불가능하다 }; } } (3) private set{} 클래스 내 다른 메서드에서 값을 변경할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyClass { public string Name { get; private set; } // private set인 읽기 전용 프로퍼티 public MyClass() { Name = \u0026#34;Kim\u0026#34;; } public void ChangeName() { Name = \u0026#34;Lee\u0026#34;; // 클래스 내 다른 메서드에서 값을 변경할 수 있다. } } class MainApp { static void Main(string[] args) { MyClass a = new MyClass(); } } 레코드 형식으로 만드는 불변 객체 레코드(Record) 데이터 복사와 비교를 손쉽게 할 수 있는 불변 객체이다. 참조 형식이다. 레코드 선언하기 레코드 선언하기 record키워드와 초기화 전용 자동 구현 프로퍼티를 함께 이용해서 선언한다. 쓰기 기능한 프로퍼티와 필드도 넣을 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 record RTransaction { public string From { get; init; } public string To { get; init; } public int Amount { get; init; } } class MainApp { static void Main(string[] args) { RTransaction r1 = new RTransaction { From=\u0026#34;Alice\u0026#34;, To=\u0026#34;Bob\u0026#34;, Amount=100 }; RTransaction r2 = new RTransaction { From=\u0026#34;John\u0026#34;, To=\u0026#34;Max\u0026#34;, Amount=200 }; } } with을 이용한 레코드 복사 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 record RTransaction { public string From { get; set; } public string To { get; set; } public int Amount { get; set; } } class MainApp { static void Main(string[] args) { RTransaction r1 = new RTransaction { From=\u0026#34;Alice\u0026#34;, To=\u0026#34;Bob\u0026#34;, Amount=100 }; RTransaction r2 = r1 with { To=\u0026#34;Max\u0026#34; }; // To만 Max로 바꾸면서 r1을 r2에 복사한다. } } 레코드 객체 비교하기 컴파일러는 레코드의 상태를 비교하는 Equals() 메소드를 자동으로 구현한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 record RTransaction { public string From { get; set; } public string To { get; set; } public int Amount { get; set; } } class MainApp { static void Main(string[] args) { RTransaction r1 = new RTransaction { From=\u0026#34;Alice\u0026#34;, To=\u0026#34;Bob\u0026#34;, Amount=100 }; RTransaction r2 = r1 with { To=\u0026#34;Max\u0026#34; }; Console.WriteLine($\u0026#34;{r1.Equals(r2)}\u0026#34;); // False } } 무명 형식 무명 형식(Anonymous Type) int, MyClass같은 형식 이름이 없는 것이다. 괄호 사이에 임의의 프로퍼티 이름을 적고, 값을 할당하면 무명 형식의 프로퍼티가 만들어진다. 선언과 동시에 인스턴스를 할당한다. 1 var a = new { Name = \u0026#34;Kim\u0026#34;, Age = 1 }; // 선언과 동시에 인스턴스 할당 인스턴스가 한 번 만들어지고 난 후에는 변경이 불가능하다. 즉, 읽기만 가능하다. 1 2 3 4 5 6 var a = new { Name = \u0026#34;Kim\u0026#34;, Age = 1 }; string name = a.Name; // 프로퍼티애 접근해서 읽기 가능 int age = a.Age; a.Name = \u0026#34;Lee\u0026#34;; // (X) 인스턴스가 한 번 만들어진 후에는 변경이 불가능하다 인터페이스의 프로퍼티 인터페이스의 프로퍼티 당연히 인터페이스의 프로퍼티는 구현을 갖지 않는다. 그래서 클래스의 자동 구현 프로퍼티 선언과 그 모습이 동일하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 interface IMyInterface { string Name { get; } } class MyClass : IMyInterface { private string name; public string Name { get { return name; } } } 추상 클래스의 추상 프로퍼티 추상 프로퍼티는 어떻게 선언할 수 있을까? 인터페이스처럼 구현을 비워놓을 수는 없다. 그러면 C# 컴파일러가 자동 구현 프로퍼티로 간주하고 구현을 자동으로 채워 넣을 것이다. 따라서 abstract 한정자를 이용해서 선언한다. 추상 프로퍼티는 추상 메서드와 마찬가지로 자식 클래스에서 반드시 오버라이드 해야한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 abstract class MyAbstractClass { // 구현을 가지는 프로퍼티의 경우 private string name; public string Name { get { return name; } } // 구현이 없는 abstract 프로퍼티의 경우 public abstract int Number { get; set; } } class MyClass : MyAbstractClass { // abstract 프로퍼티는 반드시 재정의해야 한다. public override int Number { get; set; } } 람다식과 프로퍼티 프로퍼티는 본문을 간단하게 람다식으로 구현할 수 있다. 이것을 식 본문 멤버(Expression-Bodied Member) 라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MyClass { // 읽기, 쓰기 모두 가능한 프로퍼티 private string name; public string Name { get =\u0026gt; name; set =\u0026gt; name = value; } // 읽기 전용 프로퍼티 private int age; public int Age =\u0026gt; age; } ","date":"2022-05-07T11:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-09/","title":"[This is C#] Chapter 9. 프로퍼티"},{"content":" 인터페이스의 선언 인터페이스(Interface) 메소드, 이벤트, 인덱서, 프로퍼티만을 가질 수 있다. 인터페이스는 파생 클래스가 반드시 자신이 가진 것을 구현하도록 강제한다. 접근 제한 한정자를 사용할 수 없고, 모든 것이 public으로 선언된다. 인스턴스도 만들 수 없다. 참조는 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 interface IInterface { void Method(); } class MyClass : IInterface { public void Method() { //... } } class MainApp { static void Main(string[] args) { IInterface a = new MyClass(); a.Method(); } } 인터페이스를 상속하는 인터페이스 인터페이스를 상속할 수 있는 것 클래스 구조체 인터페이스 이미 해당 인터페이스를 상속하는 클래스들이 많거나, 상속하려는 인터페이스가 소스 코드가 아닌 어셈블리로만 제공되는 경우, 인터페이스를 상속하는 인터페이스를 만들 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 interface IBase { void BaseMethod(); } interface IDerived : IBase // 인터페이스를 상속하는 인터페이스 { void DerivedMethod(); } class MyClass : IDerived { public void BaseMethod() { //... } public void DerivedMethod() { //... } } class MainApp { static void Main(string[] args) { Derived d = new MyClass(); d.BaseMethod(); d.DerivedMethod(); } } 여러 개의 인터페이스, 한꺼번에 상속하기 C#은 여러 클래스를 한꺼번에 상속할 수 없다. 죽음의 다이아몬드 문제 때문이다. 하지만 여러 인터페이스를 상속할 순 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 interface IRun { void Run(); } interface IFly { void Fly(); } class FlyingCar : IRun, IFly { public void Run() { Console.WriteLine(\u0026#34;Run\u0026#34;); } public void Fly() { Console.WriteLine(\u0026#34;Fly\u0026#34;); } } class MainApp { static void Main(string[] args) { FlyingCar car = new FlyingCar(); car.Run(); car.Fly(); IRun run = new FlyingCar(); run.Run(); IFly fly = new FlyingCar(); fly.Fly(); } } 포함(Containment) 기법 다른 클래스의 기능을 새로운 클래스에 넣는 방법으로써, 물려받고 싶은 기능을 가진 클래스들을 필드로 선언해 넣는 것이다. 1 2 3 4 5 6 7 8 class MyVehicle { Car car = new Car(); Plane plane = new Plane(); public void Run() { car.Run(); } public void Fly() { plane.Fly(); } } 인터페이스의 기본 구현 메소드 기존 인터페이스에 메소드를 추가하고 싶다. 하지만 인터페이스를 상속하는 파생 클래스가 수 없이 많아서 일일이 다 수정하기에는 너무 번거롭다. 그렇다면, 인터페이스에 기본 구현을 제공하는 메소드를 만들자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 interface IInterface { void PreviousMethod(); void NewMethod() // 기본 구현 메소드 { Console.WriteLine(\u0026#34;New Method\u0026#34;); } } class Myclass : IInterface { public void PreviousMethod() { Console.WriteLine(\u0026#34;Previous Method\u0026#34;); } } class MainApp { static void Main(string[] args) { IInterface i = new Myclass(); i.PreviousMethod(); i.NewMethod(); Myclass m = new Myclass(); m.PreviousMethod(); m.NewMethod(); // 컴파일 에러! NewMethod()를 오버라이딩 하진 않았다. } } 명시적인 인터페이스 구현 암묵적 구현 public으로 구현하는 방식이다. 명시적 구현 private으로 구현하며 [인터페이스이름.함수명] 형식으로 함수 이름을 표시한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface IMyInterface { string Name { get; set; } int Age { get; set; } } public class MyClass : IMyInterface { // 암시적인 구현 = public public string Name { get; set; } // 명시적인 구현 = private = 인터페이스로 형변환 시에만 호출할 수 있다. int IMyInterface.Age { get; set; } } class Program { static void Main(string[] args) { MyClass a = new MyClass(); a.Name = \u0026#34;Kim\u0026#34;; a.Age = 1; // (X) 접근 불가 ((IMyInterface)a).Age = 1; // (O) 접근 가능 } } 여러 개의 인터페이스를 상속받을 때, 이름이 같은 서로 다른 멤버를 선언하는 사례도 해결할 수 있겠다. Microsoft 공식문서 1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface ILeft { int P { get;} } interface IRight { int P(); } class Middle : ILeft, IRight { public int P() { return 0; } int ILeft.P { get { return 0; } } } 추상 클래스: 인터페이스와 클래스 사이 추상 클래스(Abstract class) 구현을 가질 수 있지만, 인스턴스를 만들 수 없다. 추상 메소드를 가질 수 있다. 추상 메소드는 파생 클래스가 반드시 이 메소드를 구현하도록 강제한다. 추상 메소드는 반드시 public, protected, internal, protected internal 중에 하나여야 한다. private이면 안 된다. 1 2 3 4 5 6 7 8 9 10 11 12 abstract class AbstractBase { public abstract void AbstractMethod(); } class MyClass : AbstractBase { public override void AbstractMethod() { //... } } 추상 클래스가 또 다른 추상 클래스를 상속하는 경우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 abstract class AbstractBase { public abstract void AbstractMethod(); } abstract class AbstractDerived : AbstractBase { public abstract override void AbstractMethod(); } class MyClass : AbstractDerived { public override void AbstractMethod() { Console.WriteLine(\u0026#34;Hello\u0026#34;); } } class MainApp { static void Main(string[] args) { AbstractBase b = new MyClass(); b.AbstractMethod(); } } ","date":"2022-05-07T10:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-08/","title":"[This is C#] Chapter 8. 인터페이스와 추상 클래스"},{"content":" 객체지향 프로그래밍과 클래스 객체지향 프로그래밍(Object Oriented Programming; OOP) 문제 상황에 맞는 데이터형(클래스)을 만들어서 프로그래밍하는 방법이다. 클래스가 객체를 만들기 위한 청사진이라면, 객체는 그 실체(Instance)라고 볼 수 있다. 따라서 객체를 인스턴스라고 부르기도 한다. 클래스는 복합 데이터 형식이다. 객체는 속성(데이터), 기능(메소드)으로 이루어져 있다. 클래스의 선언과 객체의 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Cat { public string Name; public string Color; public void Meow() { Console.WriteLine(\u0026#34;{0} : 야옹\u0026#34;, Name); } } class MainApp { static void Main(string[] args) { Cat kitty1 = new Cat(); // Cat 객체를 생성한다. kitty1.Name = \u0026#34;키티\u0026#34;; kitty1.Color = \u0026#34;하얀색\u0026#34;; Cat kitty2; // null을 가진다. } } new 연산자와 생성자는 모든 데이터 형식에 사용할 수 있다. int a = new int(); // (O) 생성자와 종료자 생성자 형식 클래스와 이름이 같고, 반환 형식이 없다. 정의 명시적으로 생성자를 정의하지 않아도 컴파일러에서 생성자를 만들어 준다. 하지만 하나라도 생성자를 직접 정의하면, 기본 생성자를 제공하지 않는다. 오버로딩이 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Cat { public string Name; public string Color; public Cat() { Name = \u0026#34;\u0026#34;; Color = \u0026#34;\u0026#34;; } public Cat(string _Name, string _Color) { Name = _Name; Color = _Color; } public void Meow() { Console.WriteLine(\u0026#34;{0} : 야옹\u0026#34;, Name); } } 종료자 형식 클래스 이름 앞에 ~를 붙인다. 생성자와 달리 매개변수도 없고, 한정자도 없다. 정의 오버로딩이 불가능하다. 종료자는 되도록 구현하지 않는 것이 좋다. CLR의 가비지 컬렉터가 객체가 소멸되는 시점을 판단해서 종료자를 호출해준다. 가비지 컬렉터가 우리보다 훨씬 똑똑하게 객체의 소멸을 처리할 수 있다. 종료자를 명시적으로 구현하면 가비지 컬렉터는 클래스의 족보를 타고 올라가서 객체로부터 상속받은 Finalize()메소드를 호출한다. 이렇게 되면 성능 저하를 초래할 확률이 높아진다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Cat { public string Name; public string Color; public Cat() { Name = \u0026#34;\u0026#34;; Color = \u0026#34;\u0026#34;; } public Cat(string _Name, string _Color) { Name = _Name; Color = _Color; } ~Cat() { Console.WriteLine(\u0026#34;{0}, 잘가\u0026#34;, Name); } public void Meow() { Console.WriteLine(\u0026#34;{0} : 야옹\u0026#34;, Name); } } 정적 필드와 메소드 정적(static) 필드, 메소드란? 필드나 메소드가 인스턴스가 아닌, 클래스 자체에 소속되도록 하는 것이다. 프로그램 전체에 걸쳐 하나밖에 존재하지 않는다. 인스턴스를 생성하지 않아도 호출이 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class MyClass { public static int StaticVal; public int Val; public static void StaticFunc() { //... } public void Func() { //... } } class MainApp { static void Main(string[] args) { // 인스턴스 없이 접근 가능한 static 필드와 메소드 MyClass.StaticVal = 1; MyClass.StaticFunc(); // 인스턴스에 소속되는 필드와 메소드 MyClass mine = new MyClass(); mine.Val = 1; mine.Func(); } } 객체 복사하기 : 얕은 복사와 깊은 복사 얕은 복사(Shallow Copy) 클래스는 태생이 참조 형식이기 때문에 다음 코드와 같은 경우, 두 객체 모두 하나의 힙에 있는 데이터를 가리키게 되는 문제가 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyClass { public int Val; } class MainApp { static void Main(string[] args) { MyClass a = new MyClass(); a.Val = 1; MyClass copyA = a; copyA.Val = 2; Console.WriteLine(a.Val); // 2 } } 깊은 복사(Deep copy) 우리가 직접 깊은 복사를 수행하는 코드를 만들어서, 다른 힙에 저장되도록 할 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MyClass { public int Val; public MyClass DeepCopy() { MyClass newCopy = new MyClass(); newCopy.Val = Val; return newCopy; } } class MainApp { static void Main(string[] args) { MyClass a = new MyClass(); a.Val = 1; MyClass copyA = a.DeepCopy(); copyA.Val = 2; Console.WriteLine(a.Val); // 1 } } this 키워드 this 키워드\n객체 내부에서 자기 자신의 필드나 메소드에 접근할 때 사용한다. this() 생성자\n자기 자신의 생성자를 가리킨다. 생성자에서만 사용될 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MyClass { private int a, b, c; public MyClass() { this.a = 0; } public MyClass(int b) : this() { this.b = b; } public MyClass(int b, int c) : this(b) { this.c = c; } } 접근 한정자로 공개 수준 결정하기 C#에서 제공하는 접근 한정자 6가지 접근 한정자 설명 public 클래스 내부/외부 모든 곳에서 접근할 수 있다. protected 클래스의 외부에서는 접근할 수 없지만, 파생 클래스에서는 접근이 가능하다. private 클래스의 내부에서만 접근할 수 있다. 파생 클래스에서도 접근이 불가능하다. internal 같은 어셈블리에 있는 코드에서만 public으로 접근할 수 있다. 다른 어셈블리에 있는 코드에서는 private과 같은 수준의 접근성을 가진다. protected internal 같은 어셈블리에 있는 코드에서만 protected으로 접근할 수 있다. 다른 어셈블리에 있는 코드에서는 private과 같은 수준의 접근성을 가진다. private internal 같은 어셈블리에 있는 클래스에서 생속받은 클래스 내부에서만 접근이 가능하다. 클래스의 멤버의 접근 한정자는 디폴트로 private이다. 상속으로 코드 재활용하기 객체를 생성할 때 기반 클래스의 생성자 → 파생 클래스의 생성자 객체가 소멸될 때 파생 클래스의 소멸자 → 기반 클래스의 소멸자 매개변수를 가지는 기반 클래스의 생성자를 호출하는 방법? base 키워드를 사용한다. 이것은 기반 클래스를 가리킨다. base 키워드로 기반 클래스의 필드나 메서드에 접근할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class BaseClass { public int BaseVal; public BaseClass(int BaseVal) { this.BaseVal = BaseVal; } public void BaseMethod() { //... } } class DerivedClass : BaseClass { public int DerivedVal; // base()를 통해 기반 클래스의 생성자 호출가능. public DerivedClass(int BaseVal, int DerivedVal) : base(BaseVal) { this.DerivedVal = DerivedVal; } public void DerivedMethod() { // base 키워드를 통해 기반 클래스의 필드나 메서드에 접근 가능. int val = base.BaseVal; base.BaseMethod(); } } 상속이 불가능하도록 만드려면? sealed 키워드를 사용한다. 1 2 3 4 5 6 7 8 9 sealed class BaseClass { //... } class DerivedClass : BaseClass // 컴파일 에러! { //... } 기반 클래스와 파생 클래스 사이의 형식 변환, 그리고 is와 as C#에서 형식 변환을 위한 연산자: is, as (Dog)같이 형식을 변환하는 것 보다는 as Dog과 같이 사용하는 것을 권장한다. as는 참조 형식에 대해서만 사용이 가능하므로, 값 형식의 객체는 기존의 형식 변환 연산자를 사용해야 한다. 연산자 설명 is 객체가 해당 형식으로 변환 가능한지 검사해서 그 결과를 bool값으로 반환한다. as 객체를 해당 형식으로 변환한다. 만약 실패하면 null을 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Animal { } class Dog : Animal { public void Bark() { } } class Cat : Animal { public void Meow() { } } class MainApp { static void Main(string[] args) { Animal ani = new Dog(); if (ani is Dog) { Dog dog = (Dog) ani; dog.Bark(); } Cat cat = ani as Cat; if (cat != null) { cat.Meow(); } } } 오버라이딩과 다형성 다형성(Polymorphism) 객체가 여러 형태를 가질 수 있음을 의미한다. 오버라이딩(Overriding) 다형성을 실현하는 방법이다. 기반 클래스의 메소드를 파생 클래스에서 재정의하는 것을 말한다. 기반 클래스의 메소드가 virtual 키워드로 한정되어 있어야 한다. 그리고 파생 클래스의 메소드에서 override 키워드로 한정하여 컴파일러에게 재정의하고 있음을 알린다. private으로 선언한 메소드는 오버라이딩 할 수 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Animal { public virtual void MakeSound() { Console.WriteLine(\u0026#34;Animal\u0026#34;); } } class Dog : Animal { public override void MakeSound() { Console.WriteLine(\u0026#34;Bark\u0026#34;); } } class Cat : Animal { public override void MakeSound() { Console.WriteLine(\u0026#34;Meow\u0026#34;); } } class MainApp { static void Main(string[] args) { Animal ani = new Dog(); ani.MakeSound(); // Bark ani = new Cat(); ani.MakeSound(); // Meow } } 메소드 숨기기 메소드 숨기기(Method Hiding) CLR에게 기반 클래스에서 구현된 버전의 메소드를 감추고, 파생 클래스에서 구현된 버전만 보여주는 것이다. 파생 클래스의 메소드에 new 키워드를 사용한다. 오버라이딩과 다른 점이라면, 아래 코드처럼 메소드를 단순히 숨기기만 한다는 점이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Animal { public virtual void MakeSound() { Console.WriteLine(\u0026#34;Animal\u0026#34;); } } class Dog : Animal { public new void MakeSound() { Console.WriteLine(\u0026#34;Bark\u0026#34;); } } class MainApp { static void Main(string[] args) { Animal ani = new Dog(); ani.MakeSound(); // Animal } } 오버라이딩 봉인하기 메소드를 오버라이딩되지 않도록 봉인하기 sealed 키워드를 사용한다. 기반 클래스에서 virtual로 선언된 메서드를 상속하는 파생 클래스의 메서드만 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Animal { public virtual void MakeSound() { Console.WriteLine(\u0026#34;Animal\u0026#34;); } } class Dog : Animal { public sealed override void MakeSound() // sealed { Console.WriteLine(\u0026#34;Bark\u0026#34;); } } class Bulldog : Dog { public override void MakeSound() // 컴파일 에러! { } } 읽기 전용 필드 읽기 전용 필드 readonly 키워드를 사용한다. 생성자 안에서 한 번 값을 지정하면, 그 후로는 값을 변경할 수 없다. 클래스나 구조체의 멤버로만 존재할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MyClass { private readonly int val; public MyClass() { val = 1; // 생성자에서는 readonly 초기화 가능 } public void MyMethod() { val = 1; // 컴파일 에러! } } 중첩 클래스 중첩 클래스(Nested Class) 클래스 안에 선언되어 있는 클래스이다. 자신이 소속되어 있는 클래스의 멤버에 자유롭게 접근할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 class OuterClass { private int val; class NestedClass { public void DoSomething() { OuterClass outer = new OuterClass(); outer.val = 1; // private이라도 접근이 가능하다. } } } 분할 클래스 분할 클래스(Partial Class) 클래스의 구현이 길어질 경우 여러 파일에 나눠서 구현할 수 있게 한다. partial 키워드를 사용한다. 1 2 3 4 5 6 7 8 9 10 11 partial class MyClass { public void Method1() {} public void Method2() {} } partial class MyClass { public void Method3() {} public void Method4() {} } 확장 메소드 확장 메소드(Extension Method) 기반 클래스의 기능을 확장한다. 이것은 기반 클래스를 물려받아서 파생 클래스를 만든 뒤 필드나 메소드를 추가하는 상속과는 다른 것이다. 확장 메소드를 사용하면, string 클래스에 문자열을 뒤집는 기능을 넣을 수도 있고, int형식에 제곱 연산 기능을 넣을 수도 있다. 선언 방법 선언하는 클래스와 메소드는 static한정자로 수식해야 한다. 확장 메소드의 첫번째 매개변수는 반드시 this 키워드와 함께 확장하고자 하는 클래스(형식)의 인스턴스여야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static class IntegerExtension { public static int Power(this int myInt, int exponent) { int result = myInt; for (int i = 1; i \u0026lt; exponent; i++) result = result * myInt; return result; } } class MainApp { static void Main(string[] args) { int pow = 2.Power(4); int a = 2; pow = a.Power(4); } } 구조체 클래스와 구조체의 차이점 특징 클래스 구조체 형식 참조 형식 값 형식 복사 얕은 복사 깊은 복사 인스턴스 생성 new연산자와 생성자 필요 선언만으로 생성 생성자 제한 없음 매개변수 없는 생성자는 선언 불가능 모든 필드를 초기화하지 않는 생성자는 선언 불가능 상속 가능 불가능 변경불가능 선언 불가능 가능(readonly) 읽기 전용 메소드 불가능 가능(readonly) 변경불가능(Immutable) 구조체 readonly 키워드를 사용한다. 해당 구조체의 모든 필드가 readonly로 선언되도록 강제한다. 1 2 3 4 5 6 7 8 9 10 readonly struct ImmutableStruct { public readonly int ImmutableField; // (O) public int MutableField; // 컴파일 에러! public ImmutableStruct(int val) { ImmutableField = val; // 생성자에서만 초기화 가능 } } 읽기 전용 메소드 readonly 키워드를 사용한다. 해당 메소드가 객체의 상태를 바꿀 수 없게 한다. 구조체에서만 가능하다. 1 2 3 4 5 6 7 8 9 struct MyStruct { public int Value; public readonly void TryToChange() // readonly 메소드는 객체의 상태를 바꿀 수 없다 { Value = 1; // 컴파일 에러! } } 튜플 튜플(Tuple) 여러 필드를 담을 수 있는 구조체이다. 구조체이므로 값 형식이다. 명명되지 않은 튜플(Unnamed Tuple) 필드의 이름을 지정하지 않은 튜플 명명된 튜플(Named Tuple) 필드의 이름을 지정한 튜플 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 컴파일러가 튜플의 모양을 보고 직접 형식을 결정하도록 var를 이용해서 선언한다. // 명명되지 않은 튜플 var unnamedTuple = (\u0026#34;박찬호\u0026#34;, 13); Console.WriteLine($\u0026#34;{unnamedTuple.Item1}, {unnamedTuple.Item2}\u0026#34;); // 명명된 튜플 var namedTuple = (Name: \u0026#34;박찬호\u0026#34;, Age: 13); Console.WriteLine($\u0026#34;{namedTuple.Name}, {namedTuple.Age}\u0026#34;); // 튜플 분해하기 var (name, age) = namedTuple; Console.WriteLine($\u0026#34;{name}, {age}\u0026#34;); // 튜플 분해 시 특정 필드 무시하기 var (n, _) = namedTuple; Console.WriteLine($\u0026#34;{n}\u0026#34;); // 튜플 생성과 분해를 한 번에 하기 -\u0026gt; 여러 변수를 단번에 초기화 var (color, value) = (\u0026#34;White\u0026#34;, 33); Console.WriteLine($\u0026#34;{color}, {value}\u0026#34;); 튜플의 분해 튜플은 분해자(Deconstructor)를 구현하고 있기 때문에 분해가 가능하다. 분해한 결과를 switch문이나 switch식의 분기 조건에 활용할 수도 있다. 이것을 위치 패턴 매칭(Positional Pattern Matching)이라고 한다. 1 2 3 4 5 6 7 8 9 10 var alice = (Job: \u0026#34;학생\u0026#34;, Age: 30); var discountRate = alice switch { (\u0026#34;학생\u0026#34;, int n) when n \u0026lt; 18 =\u0026gt; 0.2, (\u0026#34;학생\u0026#34;, _) =\u0026gt; 0.1, (\u0026#34;일반\u0026#34;, int n) when n \u0026lt; 18 =\u0026gt; 0.1, (\u0026#34;일반\u0026#34;, _) =\u0026gt; 0.05, _ =\u0026gt; 0 }; ","date":"2022-05-07T09:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-07/","title":"[This is C#] Chapter 7. 클래스"},{"content":" 메소드 메소드(Method) C와 C++에서의 함수(Function)나 파스칼에서의 프로시저(Procedure)와 같은 것이다. 매개변수(Parameter) 메소드가 호출자에게서 전달받은 값을 받는 변수. 인수(Argument) 호출자가 매개변수에 넘기는 값. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Cal { public static int Plus(int a, int b) // a, b는 매개변수 { return a + b; } } class MainApp { static void Main(string[] args) { Cal.Plus(4, 5); // 4, 5는 인수 } } 참조에 의한 전달 ref 키워드를 메소드의 매개변수 앞에 사용한다. 그리고 호출할 때 ref 키워드를 인수 앞에 사용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MainApp { static void Swap(ref int a, ref int b) { int temp = a; a = b; b = temp; } static void Main(string[] args) { int x = 1, y = 2; Swap(ref x, ref y); Console.WriteLine(\u0026#34;{0}, {1}\u0026#34;, x, y); // 2, 1 } } 참조 반환값 ref 키워드를 메소드의 반환값 앞에 사용한다. 그리고 return문이 반환하는 변수 앞에도 사용한다. 참조로 반환되는 결과를 담는 지역 변수를 참조 지역 변수(Ref local)라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Product { private int price = 100; public ref int GetPrice() { return ref price; } public void PrintPrice() { Console.WriteLine(price); } } class MainApp { static void Main(string[] args) { Product product = new Product(); // 참조 지역 변수 pref ref int pref = ref product.GetPrice(); pref = 200; product.PrintPrice(); // 200 } } 출력 전용 매개변수 두 개 이상의 결과를 요구하는 메소드는 어떻게 만들까? ref보다 좀 더 안전한 out을 사용한다. 출력 전용 매개변수는 out 키워드를 사용한다. 해당 매개변수에 결과를 저장하지 않으면 컴파일러가 에러 메시지를 출력한다. out으로 전달된 값을 사용할 수 없다. 해당 매개변수로 전달할 변수들을 미리 선언할 필요는 없다. (아래 코드의 c, d의 경우) 1 2 3 4 5 6 7 8 9 10 11 12 13 static void Divide(int a, int b, out int quotient, out int remainder) { quotient = a / b; remainder = a % b; } static void Main(string[] args) { int a = 20, b = 3; Divide(a, b, out int c, out int d); Console.WriteLine(\u0026#34;{0}, {1}\u0026#34;, c, d); // 6, 2 } 메소드 오버로딩 메소드 오버로딩(Overloading)\n하나의 메소드 이름으로 여러 개를 구현한 것이다. 방법\n메소드의 이름을 같게 한다. 메소드의 파라미터를 다르게 한다. 가변 개수의 인수 개수가 유연하게 변할 수 있는 인수이다. params 키워드와 배열을 이용해서 선언한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static int Sum(params int[] args) { int sum = 0; for (int i = 0; i \u0026lt; args.Length; i++) sum += args[i]; return sum; } static void Main(string[] args) { int sum = Sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Console.WriteLine(sum); // 55 } 명명된 인수 메소드를 호출할 때 인수의 이름에 근거해서 데이터를 할당할 수 있는 기능이다. 인수가 너무 많아서 어느 매개변수에 어느 인수를 할당하고 있는지 분간이 어려운 경우에 도움이 될 수 있겠다. 1 2 3 4 5 6 7 8 9 static void PrintProfile(string name, string phone) { Console.WriteLine($\u0026#34;{name}, {phone}\u0026#34;); } static void Main(string[] args) { PrintProfile(name: \u0026#34;박찬호\u0026#34;, phone: \u0026#34;000-0000-0000\u0026#34;); // 박찬호, 000-0000-0000 } 선택적 인수 매개변수에 기본값을 줄 수 있다. 그리고 기본값을 가진 매개변수는 메소드를 호출할 때 인수를 생략할 수 있다. 주의할 점은, 이러한 선택적 인수는 항상 필수 인수 뒤에 와야 한다는 것이다. 1 2 3 4 5 6 7 8 9 static void PrintProfile(string name, string phone = \u0026#34;\u0026#34;) { Console.WriteLine($\u0026#34;{name}, {phone}\u0026#34;); } static void Main(string[] args) { PrintProfile(name: \u0026#34;박찬호\u0026#34;); // 박찬호, } 로컬 함수 로컬 함수는 메소드 안에서 선언되고, 선언된 메소드 안에서만 사용되는 특별한 함수이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class SomeClass { public void SomeMethod() { int count = 0; SomeLocalFunction(1, 2); void SomeLocalFunction(int a, int b) { //... count++; // 지역 변수를 사용할 수 있다. } } } ","date":"2022-05-06T13:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-06/","title":"[This is C#] Chapter 6. 메소드로 코드 간추리기"},{"content":" 분기문 C#이 제공하는 분기문 if문 switch문 switch 문 C# 7.0부터는 switch문에 데이터 형식을 조건으로 사용할 수 있게 되었다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 object obj = null; string s = Console.ReadLine(); if (int.TryParse(s, out int out_i)) obj = out_i; else if (float.TryParse(s, out float out_f)) obj = out_f; else obj = s; switch (obj) { case int i: Console.WriteLine(\u0026#34;int 형식\u0026#34;); break; case float f: Console.WriteLine(\u0026#34;float 형식\u0026#34;); break; default: Console.WriteLine(\u0026#34;모르는 형식\u0026#34;); break; } when절을 이용하여 추가적은 조건 검사를 수행할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 switch (obj) { case int i: Console.WriteLine(\u0026#34;int 형식\u0026#34;); break; case float f when f \u0026gt;= 0: Console.WriteLine(\u0026#34;양의 float 형식\u0026#34;); break; case float f: Console.WriteLine(\u0026#34;음의 float 형식\u0026#34;); break; default: Console.WriteLine(\u0026#34;모르는 형식\u0026#34;); break; } switch 식 switch문을 switch식으로 바꾸는 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int score = 99; int result = (int)(Math.Truncate(score/10.0) * 10); // 1의 자리를 버린다. string grade = \u0026#34;\u0026#34;; switch (result) { case 90: grade = \u0026#34;A\u0026#34;; break; case 80: grade = \u0026#34;B\u0026#34;; break; case 70: grade = \u0026#34;C\u0026#34;; break; default: grade = \u0026#34;F\u0026#34;; break; } 1 2 3 4 5 6 7 8 9 10 int score = 99; int result = (int)(Math.Truncate(score/10.0) * 10); string grade = result switch { 90 =\u0026gt; \u0026#34;A\u0026#34;, 80 =\u0026gt; \u0026#34;B\u0026#34;, 70 =\u0026gt; \u0026#34;C\u0026#34;, _ =\u0026gt; \u0026#34;F\u0026#34; }; switch식에 when절 활용해보기 1 2 3 4 5 6 7 8 9 10 11 12 bool repeated = true; int score = 99; int result = (int)(Math.Truncate(score/10.0) * 10); string grade = result switch { 90 when repeated == true =\u0026gt; \u0026#34;A+\u0026#34;, 90 =\u0026gt; \u0026#34;A\u0026#34;, 80 =\u0026gt; \u0026#34;B\u0026#34;, 70 =\u0026gt; \u0026#34;C\u0026#34;, _ =\u0026gt; \u0026#34;F\u0026#34; }; 반복문 C#이 제공하는 반복문 while문 do while문 for문 foreach문 foreach 배열이나 컬렉션을 순회하면서 각 데이터 요소에 차례대로 접근하도록 해준다. 그리고, 끝에 도달하면 자동으로 반복이 종료된다. 1 2 3 4 int[] arr = new int[]{0, 1, 2, 3, 4}; foreach (int a in arr) Console.WriteLine(a); 점프문 C#이 제공하는 점프문 break continue goto return throw goto goto 레이블;을 통해서 해당 레이블(Label)로 건너뛸 수 있다. 중첩된 반복문을 단번에 뚫고 나올 수 있다는 장점이 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 string input = Console.ReadLine(); int input_number = Convert.ToInt32(input); int exit_number = 0; for (int i = 0; i \u0026lt; 100; i++) { for (int j = 0; j \u0026lt; 200; j++) { for (int k = 0; k \u0026lt; 300; k++) { if (exit_number++ == input_number) goto EXIT_FOR; Console.WriteLine(exit_number); } } } EXIT_FOR: Console.WriteLine(\u0026#34;Exited for\u0026#34;); ","date":"2022-05-06T12:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-05/","title":"[This is C#] Chapter 5. 코드의 흐름 제어하기"},{"content":" null 조건부 연산자 해당 객체가 null이면 null을 반환하고, null이 아니면 .뒤에 지정된 멤버를 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 class Foo { public int member; } Foo foo = null; int? bar; bar = foo?.member; // foo가 null이므로 null을 반환한다. foo = new Foo(); bar = foo?.member; // foo가 null이 아니므로 member를 반환한다. null 병합 연산자 왼쪽 피연산자가 null이면 오른쪽 피연산자를 반환하고, null이 아니면 왼쪽 피연산자를 그대로 반환한다. 1 2 3 4 5 int? a = null; int result = a ?? 0; // a가 null이므로 0을 반환한다. a = 1; result = a ?? 0; // a가 null이 아니므로 1을 반환한다. 연산자 우선순위 우선순위 종류 연산자 1 증가/감소 연산자, null 조건부 연산자 a++, a--, ?., ?[] 2 증가/감소 연산자 ++a, --a 3 산술 연산자 *, /, % 4 산술 연산자 +, - 5 시프트 연산자 \u0026lt;\u0026lt;, \u0026gt;\u0026gt; 6 관계 연산자 \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=, is, as 7 관계 연산자 ==, != 8 비트 논리 연산자 \u0026amp; 9 비트 논리 연산자 ^ 10 비트 논리 연산자 ` 11 논리 연산자 \u0026amp;\u0026amp; 12 논리 연산자 ` 13 null 병합 연산자 ?? 14 조건 연산자 ?: 15 할당 연산자 =, *=, /=, %=, +=, \u0026lt;\u0026lt;=, \u0026gt;\u0026gt;=, \u0026amp;=, ^=, ` ","date":"2022-05-06T11:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-04/","title":"[This is C#] Chapter 4. 데이터를 가공하는 연산자"},{"content":" 데이터의 종류 C#에서 데이터는 이렇게 나뉠 수도 있고 기본 데이터 형식(Primitive Type) 복합 데이터 형식(Complex Data Type) 이렇게 나뉠 수도 있다. 값 형식(Value Type) 참조 형식(Reference Type) 즉, 기본 데이터 형식이면서 값 형식일 수도 있고, 참조 형식일 수도 있는 것이다. 이 장에서는 기본 데이터 형식 데이터만 살펴 본다. 값 형식과 참조 형식 값 형식\n스택에 저장된다. 중괄호를 만나면 메모리에서 제거된다. 참조 형식\n힙에 데이터가 저장되고, 스택에 그 주소가 저장된다. 더이상 참조되지 않으면 가비지 컬렉터가 메모리를 수거해 간다. 기본 데이터 형식 기본 데이터 형식은 모두 15가지가 있는데 크게 다음과 같이 나뉜다. 숫자 형식 - 값 형식 논리 형식 - 값 형식 문자열 형식 - 참조 형식 object 형식 - 참조 형식 숫자 형식 (1) 정수 계열 데이터 형식 크기(byte) 값의 범위 sbyte 1 -128 ~ 127 byte 1 0 ~ 255 short 2 -32,768 ~ 32,767 ushort 2 0 ~ 65,535 int 4 -2,147,483,648 ~ 2,147,483,647 uint 4 0 ~ 4,294,967,295 long 8 -922,377,203,685,477,508 ~ 922,377,203,685,477,507 ulong 8 0 ~ 18,446,744,073,709,551,615 char 2 자릿수 구분자(_)를 사용하면 타이핑할 때 편리하다.\nint val = -1000_0000; 2진수, 10진수, 16진수 리터럴\n리터럴(Literal)이란 문자 그대로의 고정값을 나타낸다. 2진수: 0b를 앞에 붙인다. 10진수: 아무것도 붙이지 않는다. 16진수: 0X 또는 0x를 앞에 붙인다. 음수를 표현하는 방식\n부호와 절대값(Sign-and-magnitude) 단순히 맨 왼쪽 비트를 부호를 나타내는 데 사용한다. $+0$과 $-0$이 두 가지로 존재하는 문제가 있다. 그래서 2의 보수법을 사용한다. 2의 보수법(2\u0026rsquo;s Complement) 수 부분 비트를 채운다. 전체 비트를 반전시킨다. 반전된 비트에 $1$을 더한다. 따라서 sbyte의 11111111의 값은 $-1$이 된다. 오버플로우(Overflow)\n최대값보다 큰 데이터를 저장할 때 발생한다. 예를 들면, byte 형식 변수에 $256$을 담으면, $0$이 담기게 된다. 언더플로우(Underflow)\n최저값보다 작은 데이터를 저장할 때 발생한다. 예를 들면, byte 형식 변수에 $-1$을 담으면, $255$가 담기게 된다. (2) 부동 소수 및 소수 계열 부동 소수점 형식(Floating Point Type) 소수점이 움직이면서 수를 표현한다는 뜻이다. decimal은 부동 소수점과는 다른 방식으로 소수를 다루며, 정밀도가 훨씬 높다. | 데이터 형식 | 설명 | 크기(byte) | 접미사 | 값의 범위 | |\u0026mdash;|\u0026mdash;|\u0026mdash;|\u0026mdash;| | float | 7개의 자릿수(단일 정밀도) | 4 | f | -3.402823e38 ~ -3.402823e38 | | double | 15~16개의 자릿수(복수 정밀도) | 8 | 없음 | -1.79769313486232e308 ~ -1.79769313486232e308 | | decimal | 29개의 자릿수 | 16 | m | |\n정밀도(Precision) 정보 손실 없이 나타낼 수 있는 유의한 자릿수. C#의 float과 double은 IEEE754라는 표준 알고리즘에 기반한다. 이에 따르면 float형식은 다음과 같이 구성된다. 1비트: 부호(Sign) 비트 8비트: 지수부(Exponent) 23비트: 가수부(Mantissa) 가수부가 23비트이기 때문에 이것으로는 총 7자리의 수를 만들 수 있으며, 즉 유효숫자가 7자리인 셈이다. 따라서 한정된 정밀도를 가진다. 문자 형식과 문자열 형식 char 형식 문자를 다루며 따옴표로 문자를 감싸줘야 한다. string 형식 문자열을 다루며 큰 따옴표로 문자열을 감싸줘야 한다. 논리 형식 bool은 True혹은 False값을 가지며 크기는 $1$바이트이다. object 형식 모든 데이터 형식의 조상이다.\n박싱(Boxing)\n값 형식의 데이터를 참조 형식 데이터로 변경할 때. 언박싱(Unboxing)\n참조 형식의 데이터를 값 형식 데이터로 변경할 때. 1 2 object obj = 20; // 박싱 int val = (int)obj; // 언박싱 상수와 열거 형식 상수(Constants)와 열거 형식(Enumerator)은 변수와 다르게, 안에 담긴 데이터를 절대 바꿀 수 없는 메모리 공간이다. const int a = 3; `enum Result { YES = 10, NO, CANCEL, CONFIRM, OK } Nullable 형식 어떠한 값도 가지지 않는 null이 될 수 있는 변수이다. 데이터 형식 뒤에 ?를 붙여서 선언하면 된다. int? a = null; var var로 변수를 선언하면 컴파일러가 자동으로 해당 변수의 형식을 지정해준다. 반드시 선언과 동시에 초기화를 해야한다. 지역 변수로만 사용할 수 있다. 클래스의 필드를 선언할 때는 사용할 수 없다. var a = 3; // int형식 공용 형식 시스템 공용 형식 시스템(Common Type System) .NET의 형식 체계 표준이다. C#의 데이터 형식 체계는 모두 공용 형식 시스템을 따른다. 따라서 .NET 언어들끼리 호환성을 갖는다. CTS 클래스 이름 C# 형식 C++ 형식 System.Byte byte unsigned char System.SByte sbyte char System.Int16 short short System.Int32 int int 또는 long System.Int64 long __int64 System.UInt16 ushort unsigned short System.UInt32 uint unsigned int 또는 unsigned long System.UInt64 ulong unsigned__int64 System.Single float float System.Double double double System.Boolean bool bool System.Char char wchar_t System.Decimal decimal Decimal System.IntPtr 없음 없음 System.UIntPtr 없음 없음 System.Object object Object* System.String string String* ","date":"2022-05-06T10:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-03/","title":"[This is C#] Chapter 3. 데이터 보관하기"},{"content":" CLR에 대하여 CLR(Common Language Runtime, 공통 언어 런타임) .NET Framework의 VM(Virtual Machine, 가상머신)의 하나의 요소이다. 우리가 작성한 소스코드(C#, C++ 등)를 OS 위에 있는 .NET Framework에서 작동하게 해준다. 개발자는 C#, VB.NET 등 다른 .NET 언어들을 통해서 프로그램을 개발한다. 이러한 소스코드를 컴파일러가 컴파일하면 IL(Intermediate Language) 이라는 중간 언어로 작성된 실행 파일이 만들어진다. 사용자가 이 파일을 실행시키면, CLR이 IL 소스코드를 읽어 들여서 OS가 이해할 수 있는 네이티브 코드로 컴파일한 후 실행한다. 이것을 JIT 컴파일(Just In Time Compile, 적시 컴파일) 이라고 한다. 매번 실행될 때마다 실시간으로 컴파일을 해서 실행한다는 의미이다. 장점 따라서 CLR이 있기 때문에 윈도우든, 리눅스든, 어떠한 실행환경이든 간에 .Net Framework가 설치된 어떤 환경에서도 실행이 가능해진다. 즉, 플랫폼에 최적화된 코드를 만들어낸다는 장점이 있다. 단점 반면, 컴파일에 대한 시간적 비용이 많이 든다는 단점이 따른다. 이 외에도 CLR은\u0026hellip; 프로그램의 예외가 발생했을 때 이것을 처리하도록 도와준다. 언어 간의 상속을 지원한다. COM과의 상호 운영성을 지원한다. 자동 메모리 관리 기능인 가비지 컬렉션(Garbage Collection)을 제공한다. ","date":"2022-05-06T09:00:00+09:00","permalink":"https://sopod.github.io/p/this-is-c-sharp-02/","title":"[This is C#] Chapter 1, 2. 시작하기"},{"content":" 복소수 체의 구조를 가지는 수 집합은 실수 외에도 복소수(Complex number) 가 있다. 복소수는 다음과 같이 실수(Real number) 와 허수(Imaginary number) 의 독립된 2개 요소로 구성된 수 집합이다. 허수 허수 단위(Imaginary unit) $i$라는 기호를 사용한다. 제곱했을 때 $-1$이 되는 수를 말한다. $$ i^2 = -1 $$ 복소수는 실수부(Real part)와 허수부(Imaginary part)로 분리되어 있으며 허수부는 항상 $i$를 사용해서 표기한다. 그래서 실수부가 $a$, 허수부가 $b$인 복소수는 다음과 같이 표기한다. $$ a + bi $$ $$ (a, b) $$ 복소수의 구조 복소수의 덧셈 결합법칙 $(a, b) + ((c, d) + (e, f)) = ((a, b) + (c, d)) + (e, f)$ 교환법칙 $(a, b) + (c, d) = (c, d) + (a, b)$ 항등원 $(a, b) + (0, 0) = (a, b)$ 역원 $(a, b) + (-a, -b) = (0, 0)$ 복소수 덧셈 연산의 성질 연산의 성질 만족 여부 덧셈에 대해 닫혀 있음 O 덧셈에 대한 결합법칙이 성립함 O 덧셈에 대한 교환법칙이 성립함 O 덧셈에 대한 항등원의 존재함 O 덧셈에 대한 역원이 존재함 O 복소수의 곱셈 결합법칙 $(a, b) \\cdot ((c, d) \\cdot (e, f)) = ((a, b) \\cdot (c, d)) \\cdot (e, f)$ 교환법칙 $(a, b) \\cdot (c, d) = (c, d) \\cdot (a, b)$ 분배법칙 $(a, b) \\cdot ((c, d) + (e, f)) = (a, b) \\cdot (c, d) + (a, b) \\cdot (e, f)$ 항등원 $(a, b) \\cdot (1, 0) = (a, b)$ 복소수 곱셈 연산의 성질 연산의 성질 만족 여부 곱셈에 대해 닫혀 있음 O 곱셈에 대한 결합법칙이 성립함 O 곱셈에 대한 교환법칙이 성립함 O 덧셈과 곱셈에 대한 분배법칙이 성립함 O 곱셈에 대한 항등원의 존재함 O 곱셈에 대한 역원이 존재함 O (알아보자.) 복소수의 크기\n2차원 벡터와 동일하게 실수부와 허수부를 제곱해 더한 다음 제곱근을 취한다. 절댓값 기호를 써서 나타내며 복소수의 노름(Norm) 이라고도 부른다. $$ |(a, b)| = |(a, -b)| = \\sqrt{a^2 + b^2} $$ 단위 복소수(Unit complex number)\n크기가 1인 복소수이다. 켤레(Conjugate) 복소수 임의의 복소수를 $c$라고 하면 켤레 복소수는 $c^*$나 $\\bar{c}$로 표시한다. $$ c = a + bi = (a, b) $$ $$ c^* = a - bi = (a, -b) $$ 켤레 복소수는 다음곽 같은 성질이 있다. $$ (c^*)^* = c $$ $$ c^*c = c^* $$ $$ (c_1c_2)^* = c_2^*c_1^* $$ 어떤 복소수에 그 켤레 복소수를 곱하면 해당 복소수의 크기를 제곱한 값을 얻을 수 있다. $$ cc^* = (a + bi) \\cdot (a - bi) = a^2 + b^2 = |c|^2 $$ 그러면 켤레 복소수를 이용해서 복소수의 역원을 구해보자. $c$의 역원인 $c^{-1}$에 켤레 복소수를 곱해보자. $$ c^{-1} = \\frac{1}{c} = \\frac{c^*}{cc^*} $$ $$ (a + bi)^{-1} = \\frac{1}{(a + bi)} = \\frac{(a - bi)}{(a + bi)(a - bi)} = \\frac{(a - bi)}{(a^2 + b^2)} $$ 즉, $c$의 역원인 $c^{-1}$은 켤레 복소수에 복소수 크기에 관한 식으로 나타낼 수 있다. $$ c^{-1} = \\frac{c^*}{|c|^2} $$ 만약 단위 복소수라면? 단위 복소수는 크기가 $1$이므로, 곱셈역원은 바로 켤레 복소수가 된다. 복소평면 복소평면(Complex plane) 아래 그림 (a)와 같이 2차원 실벡터 공간 $\\mathbb{R}^2$의 벡터 $(a, b)$를 표현하기 위해서 서로 직교하는 $x$, $y$축을 사용한 것처럼, 복소수 역시 (b)와 같이 실수축과 허수축을 직각으로 교차시키는 방식으로 표현할 수 있다. 이것을 복소평면이라고 한다. 여기에 복소수 $(a, b)$를 평면 상에 다음과 같이 표현할 수 있겠다. 크기가 $1$인 단위 복소수를 모아 복소평면에서 표현하면 단위원이 만들어진다. 단위 복소수와의 곱 허수부가 $0$인 임의의 복소수 $(a, 0)$에 $i$라는 단위 복소수를 곱해보자. $$ (a + 0i) \\cdot (0 + i) = (0 + ai) = (0, a) $$ 이것을 평면 상에 나타내보면, $(0, a)$는 복소수 $(a, 0)$를 $90^{\\circ}$ 회전시킨 결과다. 이 결과에 또 다시 단위 복소수 $(0, i)$를 곱하면 계속 $90^{\\circ}$씩 회전한다. 따라서 임의의 복소수 $(a, b)$에 단위 복소수 $i$를 곱한 결과는 해당 복소수를 $90^{\\circ}$ 회전시킨 결과와 같다. $$ (a, b) \\cdot (0, 1) = (-b, a) $$ 이것은 Chapter 5에서 보았던 좌표 평면에서의 $90^{\\circ}$ 회전과 동일하다. 삼각함수 공식 $\\cos^2\\theta + \\sin^2\\theta = 1$를 이용해서 단위 복소수를 다음과 같이 표현할 수 있겠다. (참고로, 삼각함수를 사용하는 경우에는 허수의 $i$가 앞에 오는게 일반적이다.) $$ \\cos\\theta + i\\sin\\theta = (\\cos\\theta, \\sin\\theta) $$ 이렇게 삼각함수로 나타낸 단위 복소수에다가 임의의 복소수 $(x, y)$를 곱하면? $$ (\\cos\\theta, \\sin\\theta) \\cdot (x, y) = (x\\cos\\theta - y\\sin\\theta, y\\cos\\theta + x\\sin\\theta) $$ 이것은 Chapter 5에서 다룬 2차원 공간의 회전행렬 R에 2차원 벡터 $(x, y)$를 곱한 결과와 같다. $$ R = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix} $$ $$ \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} x\\cos\\theta - y\\sin\\theta \\\\ y\\cos\\theta + x\\sin\\theta \\end{bmatrix} $$ 따라서, 임의의 복소수에 단위 복소수를 곱하는 것은 복소평면에서의 회전변환을 의미한다. 이번에는 서로 다른 각을 갖는 2개의 복소수를 곱한 결과를 보자. $$ (\\cos\\alpha, \\sin\\alpha) \\cdot (\\cos\\beta, \\sin\\beta) = (\\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta, \\sin\\alpha\\cos\\beta + \\sin\\beta\\cos\\alpha) $$ Chapter 5에서 살펴본 삼각함수의 덧셈 정리를 사용하면 다음과 같이 정리할 수 있다. $$ (\\cos(\\alpha + \\beta), sin(\\alpha + \\beta)) $$ 따라서, 서로 다른 두 각을 회전 변환한 후 곱셈 연산을 하는 것은 두 각의 합을 회전 변환하는 것과 동일하다는 것을 알 수 있다. 이번에는 복소수 곱셈의 항등원인 $(1, 0)$의 의미를 생각해보자. 이것은 실수에서 곱셈의 항등원인 $1$과 동일하다. 복소수 $1$은 단위 복소수이다. 삼각함수로 표현하면 다음과 같이 각 $0^{\\circ}$에 대응하는 수다. $$ (1, 0) = (\\cos0^{\\circ}, \\sin0^{\\circ}) $$ 따라서, 곱셈의 항등원을 곱한다는 것은 아무런 변환가 일어나지 않는 $0^{\\circ}$의 회전 변환이라고 해석할 수 있다. 켤레 복소수의 회전 변환 복소평면에서 켤레 복소수를 시각화해보자. 임의의 복소수 $(a, b)$의 켤레 복소수 $(a, -b)$는 다음과 같다. 이것은 실수부 축($Re$)을 중심으로 서로 대칭된 형태이다. 이번에는 단위 복소수의 켤레 복소수를 생각해보자. 단위 복소수 $(\\cos\\theta, \\sin\\theta)$의 켤레 복소수는 $(\\cos\\theta, -\\sin\\theta)$이다. 여기에 삼각함수의 성질을 활용하면 켤레 복소수를 다음과 같이 나타낼 수 있다. $$ (\\cos\\theta, -\\sin\\theta) = (\\cos(-\\theta), \\sin(-\\theta)) $$ 즉, 단위 복소수가 실수 축에 위치한 $(1, 0)$을 각 $\\theta$만큼 회전한 수를 의미한다면, 켤레 복소수는 반대 방향인 $-\\theta$만큼 회전한 수를 의미한다. 따라서, 임의의 복소수 $(a, b)$에 단위 복소수를 곱하면 반시게 방향으로 회전이 발생하는데, 단위 복소수의 켤레 복소수를 곱하면 시계 방향의 회전이 발생한다. 단위 복소수와 켤레 복소수를 곱한 값은 복소수 크기의 제곱이므로 $1$이 된다. $$ c \\dot c^* = a^2 + b^2 = \\sin^2\\theta + \\cos^2\\theta = 1 $$ 이 식을 변환의 관점에서 보면 각 $\\theta$만큼 회전한 후 바로 $-\\theta$만큼 거꾸로 회전하는 변환을 의미한다. 이 결과는 아무런 변화 없는 $0^{\\circ}$ 회전 변환을 의미하므로 복소수 곱셈의 항등원 $(1, 0)$이 됨을 다시 한 번 확인할 수 있다. 복소수와 행렬의 관계 복소수를 수의 관점이 아닌 변환에 관점에서 보자. 2차원 복소펼면 상의 복소수를 2차원 행렬에 대응할 수 있다. 단위 복소수가 2차원의 회전 변환행렬과 같다고 해보자. $$ \\cos\\theta + i\\sin\\theta = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix} $$ 회전 변환행렬을 분리해 정리하면 다음과 같다. $$ \\cos\\theta + i\\sin\\theta = \\cos\\theta \\cdot \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix} + \\sin\\theta \\cdot \\begin{bmatrix} 0 \u0026amp; -1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}$$ 실수부에 대응하는 행렬을 $I$로 하고, 허수에 대응하는 행렬을 $J$라고 하자. $$ I = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix} $$ $$ J = \\begin{bmatrix} 0 \u0026amp; -1 \\\\ 1 \u0026amp; 0 \\end{bmatrix} $$ 실수부 행렬 $I$는 항등행렬이지만, 허수부 행렬 $J$는 $90^{\\circ}$ 회전 변환행렬이다. $J$를 두 번 곱하면 $-I$가 나오며 이것은 $-1$에 대응한다. $$ J \\cdot J = \\begin{bmatrix} -1 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \\end{bmatrix} = -I $$ 이는 두 번 곱하면 $-1$이 나오는 허수 단위의 성질과도 일치한다. $$ i \\cdot i = -1 $$ ","date":"2022-04-22T13:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-14/","title":"[Game Math] Chapter 14. 복소수: 2차원 평면의 수"},{"content":" 바운딩 볼륨 절두체 컬링에서 게임 오브젝트가 절두체 영역에 걸쳐 있다면 그려줘야한다. 따라서 이 문제를 해결하기 위해서 게임 오브젝트의 위치를 대상으로 하지 않고, 메시가 차지하는 영역을 감안해 절두체 컬링을 해야한다. 바운딩 볼륨(Bounding volume)\n메시가 차지하는 영역을 효과적으로 관리하기 위해 구(Sphere)나 박스(Box)같은 원시 도형(Primitive shape)을 사용한다. 이렇게 원시 도형으로 설정한 공간 데이터를 바운딩 볼륨이라고 한다. 구 바운딩 볼륨의 판정 바운딩 볼륨에서 가장 손쉽게 사용되는 것은 구(Sphere) 다. 어떤 점이 구의 외부에 있는지(a)와 두 구의 영역이 서로 떨어져 있는지(b)의 여부는 반지름을 이용해서 쉽게 알 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Sphere { public: FORCEINLINE constexpr Sphere() = default; FORCEINLINE constexpr Sphere(const Circle\u0026amp; InCircle) : Center(InCircle.Center), Radius(InCircle.Radius) {}; Sphere(const std::vector\u0026lt;Vector3\u0026gt;\u0026amp; InVertices); FORCEINLINE constexpr bool IsInside(const Vector3\u0026amp; InVector) const; FORCEINLINE constexpr bool Intersect(const Sphere\u0026amp; InCircle) const; public: Vector3 Center = Vector3::Zero; float Radius = 0.f; }; // (a) FORCEINLINE constexpr bool Sphere::IsInside(const Vector3\u0026amp; InVector) const { return ((Center - InVector).SizeSquared() \u0026lt;= (Radius * Radius)); } // (b) FORCEINLINE constexpr bool Sphere::Intersect(const Sphere\u0026amp; InCircle) const { float radiusSum = Radius + InCircle.Radius; return (Center - InCircle.Center).SizeSquared() \u0026lt;= (radiusSum * radiusSum); } 다음은 메시의 모든 영역을 감쌀 수 있는 구 영역을 생성하는 로직이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Sphere::Sphere(const std::vector\u0026lt;Vector3\u0026gt;\u0026amp; InVertices) { size_t cnt = InVertices.size(); if (cnt == 0) { return; } Vector3 sum; for (const auto\u0026amp; v : InVertices) { sum += v; } // 모든 점의 좌표를 더한 값을 수로 나눠서, 중점을 계산한다. Center = sum / (float)cnt; // 중점으로부터 모든 점의 거리를 구하고, 이 중에서 가장 큰 값을 반지름으로 한다. Radius = (*std::max_element(InVertices.begin(), InVertices.end(), [\u0026amp;](Vector3 const\u0026amp; lhs, Vector3 const\u0026amp; rhs) { return (Center - lhs).SizeSquared() \u0026lt; (Center - rhs).SizeSquared(); })).Size(); } 그렇다면 구를 이용해서 어떻게 절두체 컬링을 할 수 있을까? 앞서 보았던 평면의 방정식의 법선 벡터 $(a, b, c)$와 구의 중점 좌표의 내적값에 $d$값을 더한 값인 $p + d$가 양수이면 구는 평면의 바깥쪽에 위치한다. 거리에 해당하는 $|p + d|$가 반지름 $r$보다 작거나 같다면 구는 절두체 평면과 겹쳐져 있다. 나머지 경우라면 구는 절두체 안에 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 FORCEINLINE constexpr BoundCheckResult Frustum::CheckBound(const Sphere\u0026amp; InSphere) const { for (const auto\u0026amp; p : Planes) { // 양수이고, 반지름보다 크면 -\u0026gt; 절두체 밖에 있다. if (p.Distance(InSphere.Center) \u0026gt; InSphere.Radius) { return BoundCheckResult::Outside; } // 반지름보다 작거나 같으면 -\u0026gt; 절두체 평면에 걸쳐있다. else if (Math::Abs(p.Distance(InSphere.Center)) \u0026lt;= InSphere.Radius) { return BoundCheckResult::Intersect; } } // 나머지 -\u0026gt; 절두체 안에 있다. return BoundCheckResult::Inside; } 절두체 컬링에 사용하는 구 바운딩 볼륨은 로컬 좌표를 기준으로 생성된 데이터다. 하지만 우리는 절두체 컬링을 뷰 공간에서 진행하기 때문에 변환이 필요하겠다. 로컬 공간의 바운딩 볼륨 정보로 바로 절두체 컬링을 진행할 순 없을까? 클립 좌표는 다음과 같이 만들어진다. $\\vec{v_{clip}} = (P) \\cdot \\vec{v_{view}}$ 만약 $\\vec{v_{view}}$대신 $\\vec{v_{local}}$을 사용한다면? 다음과 같이 모델링 행렬과 뷰 행렬을 사용할 수 있다. $\\vec{v_{clip}} = (PVM) \\cdot \\vec{v_{local}}$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render3D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 const GameEngine\u0026amp; g = Get3DGameEngine(); auto\u0026amp; r = GetRenderer(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 배경에 기즈모 그리기 DrawGizmo3D(); // 렌더링 로직의 로컬 변수 const Matrix4x4 pvMatrix = mainCamera.GetPerspectiveViewMatrix(); // 절두체 컬링 테스트를 위한 통계 변수 size_t totalObjects = g.GetScene().size(); size_t culledObjects = 0; size_t intersectedObjects = 0; size_t renderedObjects = 0; for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); // 최종 행렬 계산 PVM Matrix4x4 finalMatrix = pvMatrix * transform.GetModelingMatrix(); LinearColor finalColor = gameObject.GetColor(); // 최종 변환 행렬로부터 평면의 방정식과 절두체 생성 Matrix4x4 finalTransposedMatrix = finalMatrix.Transpose(); std::array\u0026lt;Plane, 6\u0026gt; frustumPlanesFromMatrix = { Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[1])), // up Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[1])), // bottom Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[0])), // right Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[0])), // left Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[2])), // far Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[2])), // near }; Frustum frustumFromMatrix(frustumPlanesFromMatrix); // 바운딩 영역을 사용해 절두체 컬링을 구현 Sphere sphereBound = mesh.GetSphereBound(); auto checkResult = frustumFromMatrix.CheckBound(sphereBound); if (checkResult == BoundCheckResult::Outside) { culledObjects++; continue; } else if (checkResult == BoundCheckResult::Intersect) { // 겹친 게임 오브젝트를 통계에 포함 intersectedObjects++; finalColor = LinearColor::Red; } // 메시 그리기 DrawMesh3D(mesh, finalMatrix, finalColor); // 그린 물체를 통계에 포함 renderedObjects++; } r.PushStatisticText(\u0026#34;Total GameObjects : \u0026#34; + std::to_string(totalObjects)); r.PushStatisticText(\u0026#34;Culled GameObjects : \u0026#34; + std::to_string(culledObjects)); r.PushStatisticText(\u0026#34;Intersected GameObjects : \u0026#34; + std::to_string(intersectedObjects)); r.PushStatisticText(\u0026#34;Rendered GameObjects : \u0026#34; + std::to_string(renderedObjects)); } AABB와의 판정 구 영역 대신 박스(Box) 영역을 사용해서 좀 더 정교한 절두체 컬링 작업을 수행해보자.\n구 바운딩 볼륨에 비해 계산량은 많지만, 좀 더 정교하게 절두체 컬링을 할 수 있어서 보편적으로 게임 엔진에서 활용된다. AABB(Axis aligned bounding box)\n박스 영역을 생성할 때, 기저 축에 평행한 박스 영역이 형성되는데 이것을 AABB라고 한다. 다음은 로컬 공간에서 AABB 영역을 생성하는 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct Box { public: // ... FORCEINLINE constexpr Box operator+=(const Vector3\u0026amp; InVector); public: Vector3 Min; Vector3 Max; }; // 박스 영역의 최솟값과 최댓값을 저장한다. FORCEINLINE constexpr Box Box::operator+=(const Vector3\u0026amp; InVector) { Min.X = Math::Min(Min.X, InVector.X); Min.Y = Math::Min(Min.Y, InVector.Y); Min.Z = Math::Min(Min.Z, InVector.Z); Max.X = Math::Max(Max.X, InVector.X); Max.Y = Math::Max(Max.Y, InVector.Y); Max.Z = Math::Max(Max.Z, InVector.Z); return *this; } 1 2 3 4 5 6 7 Box::Box(const std::vector\u0026lt;Vector3\u0026gt; InVertices) { for (const auto\u0026amp; v : InVertices) { *this += v; } } 그렇다면 로컬 공간에서 생성한 AABB 영역과 평면과의 판정은 어떻게 할까? (a) 평면의 법선 벡터의 모든 요소가 양수인 상황, AABB 영역이 평면의 바깥에 위치해 있다. AABB영역의 최솟값이 평면과 가장 가깝다. (b) 평면의 법선 벡터의 모든 요소가 음수인 상황, AABB 영역이 평면의 안쪽에 위치해 있다. AABB영역의 최댓값이 평면과 가장 까깝다. AABB 영역과 법선 벡터의 $x$, $y$, $z$축은 서로 직교하고 있으므로 각 축의 데이터는. 독립적으로 동작한다. 따라서, 각 법선 벡터의 요소가 양수인 경우에는 최솟값을, 음수인 경우에는 최댓값을 사용하는. 것으로 평면에서 가장 가까운 AABB의 점을 구할 수 있다. 이 가장 가까운 점과 평면과의 $p + d$가 양수라면 바깥에 있는 것이겠다. 그렇다면 겹치는 경우에는? 위 그림과 같이 가장 가까운 점과 평면과의 $p + d$가 음수라면, 정반대의 점으로 다시 테스트를 진행해서, 양수라면 교차하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 FORCEINLINE constexpr BoundCheckResult Frustum::CheckBound(const Box\u0026amp; InBox) const { for (const auto\u0026amp; p : Planes) { Vector3 pPoint = InBox.Min, nPoint = InBox.Max; if (p.Normal.X \u0026gt;= 0.f) { pPoint.X = InBox.Max.X; nPoint.X = InBox.Min.X; } if (p.Normal.Y \u0026gt;= 0.f) { pPoint.Y = InBox.Max.Y; nPoint.Y = InBox.Min.Y; } if (p.Normal.Z \u0026gt;= 0.f) { pPoint.Z = InBox.Max.Z; nPoint.Z = InBox.Min.Z; } // 가장 가까운 점과의 결과가 양수이면 -\u0026gt; 바깥쪽에 있다. if (p.Distance(nPoint) \u0026gt; 0.f) { return BoundCheckResult::Outside; } // 음수인데, 정반대의 점과의 결과가 양수이면 -\u0026gt; 겹쳐있다. if (p.Distance(nPoint) \u0026lt;= 0.f \u0026amp;\u0026amp; p.Distance(pPoint) \u0026gt;= 0.f) { return BoundCheckResult::Intersect; } } // 나머지 -\u0026gt; 안쪽에 있다. return BoundCheckResult::Inside; } 다음은 AABB영역을 사용해서 절두체 컬링을 하는 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render3D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 const GameEngine\u0026amp; g = Get3DGameEngine(); auto\u0026amp; r = GetRenderer(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 배경에 기즈모 그리기 DrawGizmo3D(); // 렌더링 로직의 로컬 변수 const Matrix4x4 pvMatrix = mainCamera.GetPerspectiveViewMatrix(); // 절두체 컬링 테스트를 위한 통계 변수 size_t totalObjects = g.GetScene().size(); size_t culledObjects = 0; size_t intersectedObjects = 0; size_t renderedObjects = 0; for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); // 최종 행렬 계산 Matrix4x4 finalMatrix = pvMatrix * transform.GetModelingMatrix(); LinearColor finalColor = gameObject.GetColor(); // 최종 변환 행렬로부터 평면의 방정식과 절두체 생성 Matrix4x4 finalTransposedMatrix = finalMatrix.Transpose(); std::array\u0026lt;Plane, 6\u0026gt; frustumPlanesFromMatrix = { Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[1])), // up Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[1])), // bottom Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[0])), // right Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[0])), // left Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[2])), // far Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[2])), // near }; Frustum frustumFromMatrix(frustumPlanesFromMatrix); // 바운딩 영역을 사용해 절두체 컬링을 구현 Box boxBound = mesh.GetBoxBound(); auto checkResult = frustumFromMatrix.CheckBound(boxBound); if (checkResult == BoundCheckResult::Outside) { culledObjects++; continue; } else if (checkResult == BoundCheckResult::Intersect) { // 겹친 게임 오브젝트를 통계에 포함 intersectedObjects++; finalColor = LinearColor::Red; } // 메시 그리기 DrawMesh3D(mesh, finalMatrix, finalColor); // 그린 물체를 통계에 포함 renderedObjects++; } r.PushStatisticText(\u0026#34;Total GameObjects : \u0026#34; + std::to_string(totalObjects)); r.PushStatisticText(\u0026#34;Culled GameObjects : \u0026#34; + std::to_string(culledObjects)); r.PushStatisticText(\u0026#34;Intersected GameObjects : \u0026#34; + std::to_string(intersectedObjects)); r.PushStatisticText(\u0026#34;Rendered GameObjects : \u0026#34; + std::to_string(renderedObjects)); } 삼각형 클리핑 지금까지 구현한 것에 문제가 있다. 카메라를 좌우로 움직이면 깨짐 현상이 일어난다. 이 문제의 발생 원인은? 거대한 삼각형이 카메라 앞뒤에 있다고 한다면, 카메라 뒤에 있는 점은 무한 원점을 중심으로 뒤집혀서 투영되기 때문이다. 삼각형 클리핑(Triangle clipping) 원근 투영 행렬을 곱해 생성된 클립 좌표계의 $w$값은 뷰 공간에서의 깊이 값을 의미한다. 따라서 카메라 정면의 위치한 점은 $w$값이 $0$보다 크고, 카메라 뒤에 있는 점의 $w$값은 $0$보다 작으며, 카메라 초점에 위치한 점의 $w$값은 $0$이 된다. 올바르게 보이려면 카메라 뒤쪽에 있는, 음의 $w$ 영역에 걸쳐 있는 삼각형을 파악하고 잘라내야 한다. 이것을 삼각형 클리핑이라고 한다. 이 상황을 위에서 내려다 보자. 점 하나가 카메라 뒤에 있는 경우이다. Chapter 6에서 보았던 것을 사용해서 점 $P_{c1}$의 좌표는 다음과 같이 구할 수 있겠다. $$ P_{c1} = P_1 \\cdot (1- t_1) + P_2 \\cdot t_1 $$ 점 $P_{c1}$은 $w = 0$인 직선에 위치하므로 점 $P_1$, $P_2$의 $w$값을 각각 $w_1$, $w_2$라고 표기하면 다음의 수식이 성립한다. $$ w_1 (1 - t_1) + w_2t_1 = 0 $$ $$ t_1 = \\frac{w_1}{w_1 - w_2} $$ 이 영역은 사각형이므로 두 개의 삼각형으로 분할해야 한다. 방향이 동일하도록 정점의 순서도 자르기 전의 삼각형의 순서와 동일해야 한다. 이번에는 두 점이 카메라 뒤에 있는 경우이다. 이 경우에는 결과가 언제나 삼각형이므로, 두 점의 위치 값만 갱신하면 되겠다. 세 점이 뒤에 있다면 안 그리면 된다. 이러한 클리핑 규칙은 절두체를 구성하는 모든 평면에 적용할 수 있다. 한 점이 카메라 뒤에 있는 경우, 그 다음 상황을 생각해보자. 오른쪽 절두체 영역을 잘라내면 다음과 같을 것이다. 절두체의 오른쪽 평면은 NDC좌표의 x값이 언제나 $1$인 평면이다. 따라서 이것을 클립 좌표계로 표현하면 $\\frac{x}{w} = 1$이며, 이는 $w = x$를 의미한다. 따라서 다음과 같은 식을 사용해서 잘라내는 영역을 파악할 수 있겠다. $$ \\frac{x}{w} \u0026gt; 1 $$ $$ \\therefore x \u0026gt; w $$ 잘라낼 평면 상에 위치한 점의 좌표를 계산하는 방법도 변경된다. 점 $P_1$, $P_2$의 $x$값을 각각 $x_1$, $x_2$로 지정하고, 잘라내는 점의 $x$값을 $x_{c1}$이라고 할 때 $x_{c1}$을 구하는 수식은 다음과 같다. $$ x_{c1} = x_1(1 - t_1) + x_2 t_1 $$ 이것은 $w$값에 대해서도 동일하게 성립된다. $$ w_{c1} = w_1(1- t_1) + w_2t_1 $$ 오른쪽 절두체 평면에서는 $x$, $w$값이 동일하므로 다음과 같이 구할 수 있다. $$ x_1(1 - t_1) + x_2 t_1 = w_1(1- t_1) + w_2t_1 $$ $$ t_1 = \\frac{(w_1 - x_1)}{(w_1 - x_1) - (w_2 - x_2)} $$ 따라서 다음과 같이 각 평면에 대한 방정식을 정리할 수 있겠다. 각 평면의 방정식과 외부 영역에 대한 판별식, 그리고 아핀 결합의 계수를 구하는 수식은 다음과 같다.\n순서 평면 외부 판별식 아핀 결합의 계수 1 $w = 0$ $w\u0026lt;0$ $$\\frac{w_1}{w_1 - w_2}$$ 2 $w = y$ $y\u0026gt;w$ $$\\frac{(w_1 - y_1)}{(w_1 - y_1) - (w_2 - y_2)} $$ 3 $w = -y$ $y\u0026lt;-w$ $$\\frac{(w_1 + y_1)}{(w_1 + y_1) - (w_2 + y_2)} $$ 4 $w = x$ $x\u0026gt;w$ $$\\frac{(w_1 - x_1)}{(w_1 - x_1) - (w_2 - x_2)} $$ 5 $w = -x$ $x\u0026lt;-w$ $$\\frac{(w_1 + x_1)}{(w_1 + x_1) - (w_2 + x_2)} $$ 6 $w = z$ $z\u0026gt;w$ $$\\frac{(w_1 - z_1)}{(w_1 - z_1) - (w_2 - z_2)} $$ 7 $w = -z$ $z\u0026lt;-w$ $$\\frac{(w_1 + z_1)}{(w_1 + z_1) - (w_2 + z_2)} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // w = 0 static auto TestFuncW0 = [](const Vertex3D\u0026amp; InVertex) { return InVertex.Position.W \u0026lt; 0.f; }; static auto EdgeFuncW0 = [](const Vertex3D\u0026amp; InStartVertex, const Vertex3D\u0026amp; InEndVertex) { float p1 = InStartVertex.Position.W; float p2 = InEndVertex.Position.W; float t = p1 / (p1 - p2); return InStartVertex * (1.f - t) + InEndVertex * t; }; // w = -y static auto TestFuncNY = [](const Vertex3D\u0026amp; InVertex) { return InVertex.Position.Y \u0026lt; -InVertex.Position.W; }; static auto EdgeFuncNY = [](const Vertex3D\u0026amp; InStartVertex, const Vertex3D\u0026amp; InEndVertex) { float p1 = InStartVertex.Position.W + InStartVertex.Position.Y; float p2 = InEndVertex.Position.W + InEndVertex.Position.Y; float t = p1 / (p1 - p2); return InStartVertex * (1.f - t) + InEndVertex * t; }; // w = -z static auto TestFuncNear = [](const Vertex3D\u0026amp; InVertex) { return InVertex.Position.Z \u0026lt; -InVertex.Position.W; }; static auto EdgeFuncNear = [](const Vertex3D\u0026amp; InStartVertex, const Vertex3D\u0026amp; InEndVertex) { float p1 = InStartVertex.Position.W + InStartVertex.Position.Z; float p2 = InEndVertex.Position.W + InEndVertex.Position.Z; float t = p1 / (p1 - p2); return InStartVertex * (1.f - t) + InEndVertex * t; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 struct PerspectiveTest { std::function\u0026lt;bool(const Vertex3D\u0026amp; InVertex)\u0026gt; ClippingTestFunc; std::function\u0026lt;Vertex3D(const Vertex3D\u0026amp; InStartVertex, const Vertex3D\u0026amp; InEndVertex)\u0026gt; GetEdgeVertexFunc; std::array\u0026lt;bool, 3\u0026gt; TestResult; void ClipTriangles(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InTriangleVertices) { size_t nTriangles = InTriangleVertices.size() / 3; for (size_t ti = 0; ti \u0026lt; nTriangles; ++ti) { size_t si = ti * 3; size_t testNotPassedCount = 0; std::vector\u0026lt;Vertex3D\u0026gt; sub(InTriangleVertices.begin() + si, InTriangleVertices.begin() + si + 3); // 테스트에 실패한 점 정보 얻기 for (size_t ix = 0; ix \u0026lt; 3; ++ix) { bool testResult = ClippingTestFunc(sub[ix]); TestResult[ix] = testResult; if (testResult) testNotPassedCount++; } GetNewVertices(sub, testNotPassedCount); // 카메라 뒤에 아무 점도 없다. -\u0026gt; 그린다. if (testNotPassedCount == 0) { continue; } // 한 개의 점이 카메라 뒤에 있다. else if (testNotPassedCount == 1) // 삼각형 추가 { DivideIntoTwoTriangles(InOutVertices, startIndex, nonPassCount); } // 두 개의 점이 카메라 뒤에 있다. else if (testNotPassedCount == 2) // 삼각형 정보 변경 { ClipTriangle(InOutVertices, startIndex, nonPassCount); } // 세 개의 점이 카메라 뒤에 있다. -\u0026gt; 안 그린다. else { InTriangleVertices.erase(InTriangleVertices.begin() + si, InTriangleVertices.begin() + si + 3); nTriangles--; ti--; } } } private: // 점 하나가 평면의 바깥에 있어 삼각형이 2개로 쪼개지는 경우 void DivideIntoTwoTriangles(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InOutVertices, size_t StartIndex, size_t NonPassCount) { // 평면의 바깥에 위치한 점 찾기 BYTE index = 0; if (!TestResult[0]) { index = TestResult[1] ? 1 : 2; } size_t v1Index = StartIndex + (index + 1) % 3; size_t v2Index = StartIndex + (index + 2) % 3; // 안 쪽의 점 두 개 Vertex3D v1 = InOutVertices[v1Index]; Vertex3D v2 = InOutVertices[v2Index]; // 교차 지점 Vertex3D clipped1 = GetEdgeVertexFunc(InOutVertices[StartIndex + index], v1); Vertex3D clipped2 = GetEdgeVertexFunc(InOutVertices[StartIndex + index], v2); InOutVertices[StartIndex] = clipped1; InOutVertices[StartIndex + 1] = v1; InOutVertices[StartIndex + 2] = v2; InOutVertices.push_back(clipped1); InOutVertices.push_back(v2); InOutVertices.push_back(clipped2); } // 점 두 개가 평면의 바깥에 있어 삼각형의 두 점이 변하는 경우 void ClipTriangle(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InOutVertices, size_t StartIndex, size_t NonPassCount) { // 평면의 안쪽에 위치한 점 찾기 BYTE index = 0; if (TestResult[0]) { index = !TestResult[1] ? 1 : 2; } size_t v1Index = StartIndex + (index + 1) % 3; size_t v2Index = StartIndex + (index + 2) % 3; // 바깥쪽 점 두 개 Vertex3D v1 = InOutVertices[v1Index]; Vertex3D v2 = InOutVertices[v2Index]; // 교차 지점 Vertex3D clipped1 = GetEdgeVertexFunc(InOutVertices[StartIndex + index], v1); Vertex3D clipped2 = GetEdgeVertexFunc(InOutVertices[StartIndex + index], v2); InOutVertices[v1Index] = clipped1; InOutVertices[v2Index] = clipped2; } }; 다음은 대형 평면 메시를 배치해서 원근 투영 문제를 발생시키고, 삼각형 클래핑을 통해 해결하는 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // 메시를 그리는 함수 void SoftRenderer::DrawMesh3D(const Mesh\u0026amp; InMesh, const Matrix4x4\u0026amp; InMatrix, const LinearColor\u0026amp; InColor) { size_t vertexCount = InMesh.GetVertices().size(); size_t indexCount = InMesh.GetIndices().size(); size_t triangleCount = indexCount / 3; // 렌더러가 사용할 정점 버퍼와 인덱스 버퍼로 변환 std::vector\u0026lt;Vertex3D\u0026gt; vertices(vertexCount); std::vector\u0026lt;size_t\u0026gt; indice(InMesh.GetIndices()); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = Vector4(InMesh.GetVertices()[vi]); if (InMesh.HasColor()) { vertices[vi].Color = InMesh.GetColors()[vi]; } if (InMesh.HasUV()) { vertices[vi].UV = InMesh.GetUVs()[vi]; } } // 정점 변환 진행 VertexShader3D(vertices, InMatrix); // 삼각형 별로 그리기 for (int ti = 0; ti \u0026lt; triangleCount; ++ti) { int bi0 = ti * 3, bi1 = ti * 3 + 1, bi2 = ti * 3 + 2; std::vector\u0026lt;Vertex3D\u0026gt; tvs = { vertices[indice[bi0]] , vertices[indice[bi1]] , vertices[indice[bi2]] }; if (useHomogeneousClipping) { // 동차좌표계에서 클리핑을 위한 설정 std::vector\u0026lt;PerspectiveTest\u0026gt; testPlanes = { { TestFuncW0, EdgeFuncW0 }, { TestFuncNY, EdgeFuncNY }, { TestFuncPY, EdgeFuncPY }, { TestFuncNX, EdgeFuncNX }, { TestFuncPX, EdgeFuncPX }, { TestFuncFar, EdgeFuncFar }, { TestFuncNear, EdgeFuncNear } }; // 동차좌표계에서 클리핑 진행 for (auto\u0026amp; p : testPlanes) { p.ClipTriangles(tvs); } } size_t triangles = tvs.size() / 3; for (size_t ti = 0; ti \u0026lt; triangles; ++ti) { size_t si = ti * 3; std::vector\u0026lt;Vertex3D\u0026gt; sub(tvs.begin() + si, tvs.begin() + si + 3); DrawTriangle3D(sub, InColor, FillMode::Color); } } } ","date":"2022-04-21T17:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-13-2/","title":"[Game Math] Chapter 13. 절두체: 최적화된 3차원 공간 (2) "},{"content":" 절두체 컬링 절두체 컬링(Frustum culling) 절두체를 구성하는 6개의 평면에 대해 각각 평면의 방정식을 세우고, 그것을 활용해서 게임 오브젝트가 평면의 바깥에 있는지 확인한다. 바깥에 있다면, 그리지 않는다. 평면의 방정식 절두체를 구성하는 평면의 방정식\nChapter 8에서 살펴본 것처럼, 주어진 세 점으로 두 벡터를 생성해서 평면 상의 모든 점을 생성할 수 있다. 하지만 3차원 공간의 평면은 앞면과 뒷면이 존재하기 때문에 이를 구분할 수 있어야 하겠다. 따라서 평면이 바라보는 방향을 알려주는 법선 벡터와 평면 상에 위치한 한 점을 제공하는 방법을 사용한다. 이 때 법선 벡터는 크기를 1로 정규화한다. 법선벡터와 평면 위의 두 점을 지나는 벡터는 서로 직교하기 때문에 두 벡터의 내적은 $0$이 된다.\n따라서 법선벡터 $\\hat{n} = (a, b, c)$와 점 $P_0 = (x_0, y_0, z_0)$에서 $P = (x, y, z)$로 향하는 벡터를 내적하면 다음과 같다. $$ \\hat{n} \\cdot (P - P_0) = (a, b, c) \\cdot (x - x_0, y - y_0, z - z_0) = 0 $$ $$ = ax + by + cz - (ax_0 + by_0 + cz_0) = 0 $$ 여기서 법선벡터 $\\hat{n} = (a, b, c)$와 점 $P_0 = (x_0, y_0, z_0)$은 사전에 주어진 값이므로 $- (ax_0 + by_0 + cz_0)$는 미리 계산할 수 있는 상수 값이다. 이것을 간단히 $d$로 치환하면 다음과 같다. 평면의 방정식(The equation of plane) $$ ax + by + cz + d = 0 $$ 여기서 $d$의 의미를 찾아보자. $$d = -(ax_0 + by_0 + cz_0)$$ $$ d = -\\hat{n} \\cdot (x_0, y_0, z_0)$$ $$ d = -\\hat{n} \\cdot \\vec{OP_0} = -\\hat{n} \\cdot \\vec{p}$$ 그렇다면 $\\hat{n} \\cdot \\vec{p}$는 무엇을 의미할까? Chapter 7에서 배운 벡터 내적의 $\\cos$공식을 떠올려보자. $\\hat{n} \\cdot \\vec{p} = | \\hat{n} | | \\vec{p} | \\cos\\theta$ 법선 벡터의 크기는 $1$이므로 다음과 같이 정리된다. $\\hat{n} \\cdot \\vec{p} = | \\vec{p} | \\cos\\theta$ 따라서 $\\hat{n} \\cdot \\vec{p}$이란 $\\vec{p}$벡터를 법선 벡터 $\\hat{n}$에 투영한 벡터의 크기를 의미한다. 즉, 원점에서 평면까지의 최단 거리인 것이다. $d$의 값은 마이너스를 붙인 $-\\hat{n} \\cdot \\vec{p}$이므로 원점으로부터 평면의 최단 거리에 음의 부호를 설정한다. 그래서 $d$는 최단 거리와 방향이라는 두 가지 정보를 담고 있다. $d$의 부호 $d$의 값이 양수이다. 평면이 바라보는 방향은 원점을 향한다. 즉, 원점은 평면의 바깥에 있다. $d$의 값이 음수이다. 평면이 바라보는 방향은 원점에서 멀어지는 방향을 가진다. 즉, 원점은 평면의 안쪽에 있다. $d$의 절댓값 평면에서 원점까지의 최단 거리. $d$의 값이 $0$ 이다. 평면이 원점을 품었다. 주어진 점이 평면의 안쪽에 있는지 바깥쪽에 있는지 판별하기. $d$값의 성질을 응용해보자. 위 그림과 같이 벡터 $\\vec{p}$를 법선 벡터에 내적한 값을 $p$라고 하자. $p$가 양수면? 벡터 $\\vec{p}$는 법선 벡터와 같은 방향을 향한다. $p$가 음수면? 벡터 $\\vec{p}$는 법선 벡터와 반대 방향을 향한다. 위 그림에서는 $p$가 양수이겠다. 그렇다면 $p$와 $d$를 더한 값은 어떨까? $p + d$가 음수면? 점 $P$는 평면의 안쪽에 있다. $p + d$가 양수면? 점 $P$는 평면의 바깥쪽에 있다. 따라서 법선 벡터 $(a, b, c)$와 $d$를 사용해 주어진 점 $P = (x_1, y_1, z_1)$이 평면의 바깥쪽에 있는지 판단하는 수식은 다음과 같다. $$(a, b, c) \\cdot (x_1, y_1, z_1) + d \u0026gt; 0 $$ 그리고 평면에서 해당 점까지의 최단 거리는 다음과 같다. $$distance = |(a, b, c) \\cdot (x_1, y_1, z_1) + d | $$ 평면의 방정식의 정규화 크기가 $1$이 아닌 주어진 법선 벡터를 구성하는 세 계수 $(a, b, c)$를 정규화해서 $(a\u0026rsquo;, b\u0026rsquo;, c\u0026rsquo;)$를 만들어 보자. 이것은 법선 벡터의 크기로 나누면 구할 수 있다. $$ (a\u0026rsquo;, b\u0026rsquo;, c\u0026rsquo;) = \\frac{(a, b, c)}{\\sqrt{a^2 + b^2 + c^2}} $$ $d$를 정규화한 $d\u0026rsquo;$를 만들어 보자. $$ d = -\\hat{n} \\cdot \\vec{p} = - |\\hat{n}||\\vec{p}|\\cos\\theta $$ $$ d\u0026rsquo; = -|\\vec{p}|\\cos\\theta $$ 따라서 다음과 같은 관계가 나온다. $$ d\u0026rsquo; = \\frac{d}{|\\vec{n}|} $$ 즉, $d$의 경우에도 동일하게 법선 벡터의 크기로 나누면 되는 것이다. $$ \\frac{ax + by + cz + d}{\\sqrt{a^2 + b^2 + c^2}} = 0 $$ 2차원 직선의 방정식에서의 최단 거리 임의의 한 점 $(x_1, y_1)$에서 임의의 직선 $ax + by + c = 0$ 까지의 최단 거리는 어떻게 구할 수 있을까? 평면의 방정식을 정규화한 값과 내적을 활용해 구할 수 있겠다. $$ \\frac{ | ax_1 + by_1 + c | }{ \\sqrt{a^2 + b^2 } } $$ 평면의 방정식을 활용한 절두체 표현 절두체 상단 평면을 무한하게 확장하면, 그 평면은 원점을 품게 된다. 이것은 근평면, 원평면을 제외한 나머지 평면에 대해서도 동일하다. 따라서 근평면, 원평면을 제외한 나머지 평면을 구성하는 평면의 방정식 $d$값은 $0$이겠다. 상단 평면의 경우 아래 그림과 같이 구할 수 있으므로, 같은 방식으로 네 평면의 방정식을 구할 수 있다. 절두체 상단 평면의 방정식 $$ \\cos\\frac{\\theta}{2}y + \\sin\\theta\\frac{\\theta}{2}z = 0 $$ 절두체 하단 평면의 방정식 $$ -\\cos\\frac{\\theta}{2}y + \\sin\\theta\\frac{\\theta}{2}z = 0 $$ 절두체 좌측 평면의 방정식 $$ \\cos\\frac{\\theta}{2}x + \\sin\\theta\\frac{\\theta}{2}z = 0 $$ 절두체 우측 평면의 방정식 $$ -\\cos\\frac{\\theta}{2}x + \\sin\\theta\\frac{\\theta}{2}z = 0 $$ 근평면의 경우, 원점으로부터의 거리는 $n$이므로, 평면의 방정식의 $d$의 값은 $n$이 된다. 그리고 법선 벡터의 값은 $(0, 0, 1)$이 된다. $$(0, 0, 1) \\cdot (x, y, z) - (0, 0, 1) \\cdot (0, 0, -n) = 0 $$ $$ \\therefore z + n = 0 $$ 원평면의 경우에는 거리가 $f$가 되며, 법선 벡터의 값은 $(0, 0, -1)$이 된다. $$(0, 0, -1) \\cdot (x, y, z) - (0, 0, 1) \\cdot (0, 0, f) = 0 $$ $$ \\therefore -z -f = 0 $$ 이 때, 함부로 수식을 옮기면 안 된다. 만약 $0 = z + f$와 같이 옮긴다면, 평면의 방향은 원평면의 반대 방향인 원점을 향한다. 따라서 $-z -f = 0 $와 $0 = z + f$는 서로 다른 평면이다. 원근 투영 행렬로부터 평면의 방정식 만들기 원근 투영 행렬을 사용해서 절두체 컬링을 좀 더 간편하게 구현할 수 있다. 뷰 공간의 점이 NDC좌표까지 변환됐을 때, NDC좌표를 구성하는 $x$, $y$, $z$ 세 축의 값이 $[-1, 1]$ 범위에 있다면 해당 점은 절두체 영역 안 쪽에 있다는 것을 의미한다. $$ -1 \\leq n_x \\leq 1 $$ $$ -1 \\leq n_y \\leq 1 $$ $$ -1 \\leq n_z \\leq 1 $$ 이 때 NDC좌표는 클립 좌표의 마지막 차원 $w$로 나눈 결과값이므로 다음과 같다. $$ -1 \\leq \\frac{x}{w} \\leq 1 $$ $$ -1 \\leq \\frac{y}{w} \\leq 1 $$ $$ -1 \\leq \\frac{z}{w} \\leq 1 $$ $$ -w \\leq x \\leq w $$ $$ -w \\leq y \\leq w $$ $$ -w \\leq z \\leq w $$ 여기서 $x$, $y$, $z$란? $$ P \\cdot \\vec{v} = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; \\frac{n + f}{n - f} \u0026amp; \\frac{2nf}{n - f} \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} v_x \\\\ v_y \\\\ v_z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\end{bmatrix} $$ 이것은 원근 투영 행렬의 4개의 행벡터와 $\\vec{v}$의 내적으로 바꿔 쓸 수 있다. $$ \\begin{bmatrix} P_{row1} \\cdot \\vec{v} \\\\ P_{row2} \\cdot \\vec{v} \\\\ P_{row3} \\cdot \\vec{v} \\\\ P_{row4} \\cdot \\vec{v} \\end{bmatrix} = \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\end{bmatrix} $$ 이것을 부등식에 치환하면 다음과 같다. $$ -P_{row4} \\cdot \\vec{v} \\leq P_{row1} \\cdot \\vec{v} \\leq P_{row4} \\cdot \\vec{v} $$ $$ -P_{row4} \\cdot \\vec{v} \\leq P_{row2} \\cdot \\vec{v} \\leq P_{row4} \\cdot \\vec{v} $$ $$ -P_{row4} \\cdot \\vec{v} \\leq P_{row3} \\cdot \\vec{v} \\leq P_{row4} \\cdot \\vec{v} $$ 이것을 분리해 6개의 부등식으로 표현할 수 있겠다. $$ (P_{row4} + P_{row1} \\cdot \\vec{v}) \\geq 0 $$ $$ (P_{row4} - P_{row1} \\cdot \\vec{v}) \\geq 0 $$ $$ (P_{row4} + P_{row2} \\cdot \\vec{v}) \\geq 0 $$ $$ (P_{row4} - P_{row2} \\cdot \\vec{v}) \\geq 0 $$ $$ (P_{row4} + P_{row3} \\cdot \\vec{v}) \\geq 0 $$ $$ (P_{row4} - P_{row3} \\cdot \\vec{v}) \\geq 0 $$ 이 부등식이 모두 참이면 점 $\\vec{v}$는 절두체 영역 내부에 있음을 의미한다. 여기서 행벡터가 $P_{rown} = (a, b, c, d)$라고 하고, 뷰 공간의 점이 $\\vec{v} = (x, y, z, 1)$라고 할 때 내적의 결과는 다음과 같다. $$ ax + by + cz + d \\geq 0 $$ 하지만 법선벡터 $(a, b, c)$의 크기가 $1$이 아니므로, 정규화 해야 한다. $$ \\frac{ ax + by + cz + d }{ \\sqrt{ a^2 + b^2 + c^2 } } = 0 $$ 이 결과는 모두 절두체 내부를 향할 것이다. 따라서 외부에 있는지를 검출하기 위해서는 부호를 반전시켜 주어야 한다. $$ - ( \\frac{ ax + by + cz + d }{ \\sqrt{ a^2 + b^2 + c^2 } } ) \u0026gt; 0 $$ 원근 투영 행렬을 사용해서 절두체 컬링하는 예제이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 struct Plane { public: FORCEINLINE constexpr float Distance(const Vector3\u0026amp; InPoint) const; FORCEINLINE constexpr bool IsOutside(const Vector3\u0026amp; InPoint) const; Vector3 Normal = Vector3::UnitY; // (a, b, c) float D = 0.f; // 상수 d의 값 }; Plane::Plane(const Vector4\u0026amp; InVector4) { Normal = InVector4.ToVector3(); // (a, b, c) D = InVector4.W; // 상수 d의 값 Normalize(); } // 정규화 한다. void Plane::Normalize() { // a^2 + b^2 + c^2 float squaredSize = Normal.SizeSquared(); // 크기가 1이면 정규화할 필요 없다. if (Math::EqualsInTolerance(squaredSize, 1.f)) { return; } // 1 / sqrt(a^2 + b^2 + c^2)을 고속 역제곱근(Fast inverse square root) 함수로 구한다. float invLength = Math::InvSqrt(squaredSize); // 곱해서 정규화한다. Normal *= invLength; D *= invLength; } // p + d를 리턴한다. FORCEINLINE constexpr float Plane::Distance(const Vector3\u0026amp; InPoint) const { return Normal.Dot(InPoint) + D; } // Distance의 반환값이 양수이면 그 점은 평면의 바깥에 있다. FORCEINLINE constexpr bool Plane::IsOutside(const Vector3\u0026amp; InPoint) const { return Distance(InPoint) \u0026gt; 0.f; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 FORCEINLINE constexpr BoundCheckResult Frustum::CheckBound(const Vector3\u0026amp; InPoint) const { // 6개의 평면에 대해 테스트를 진행한다. for (const auto\u0026amp; p : Planes) { // 한 평면이라도 밖에 있으면 점은 외부에 있음으로 판별하고 함수를 종료한다. if (p.IsOutside(InPoint)) { return BoundCheckResult::Outside; } // 오차 범위 내의 거리가 0에 근접하면 겹치는 것으로 판별하고 종료한다. else if (Math::EqualsInTolerance(p.Distance(InPoint), 0.f)) { return BoundCheckResult::Intersect; } } // 모든 평면에 대해 위 테스트를 통과하면 안쪽으로 판별한다. return BoundCheckResult::Inside; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render3D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 const GameEngine\u0026amp; g = Get3DGameEngine(); auto\u0026amp; r = GetRenderer(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 배경에 기즈모 그리기 DrawGizmo3D(); // 렌더링 로직의 로컬 변수 const Matrix4x4 vMatrix = mainCamera.GetViewMatrix(); const Matrix4x4 pMatrix = mainCamera.GetPerspectiveMatrix(); // 원근 투영 행렬을 가져온다. const Matrix4x4 pvMatrix = mainCamera.GetPerspectiveViewMatrix(); // 절두체 구축을 위한 투영 행렬의 설정 Matrix4x4 ptMatrix = pMatrix.Transpose(); // 절두체를 구성하는 평면의 방정식 // 절두체를 구성하는 6개의 평면을 생성한다. std::array\u0026lt;Plane, 6\u0026gt; frustumPlanes = { Plane(-(ptMatrix[3] - ptMatrix[1])), // +Y Plane(-(ptMatrix[3] + ptMatrix[1])), // -Y Plane(-(ptMatrix[3] - ptMatrix[0])), // +X Plane(-(ptMatrix[3] + ptMatrix[0])), // -X Plane(-(ptMatrix[3] - ptMatrix[2])), // +Z Plane(-(ptMatrix[3] + ptMatrix[2])), // -Z }; // 절두체 선언 Frustum frustumFromMatrix(frustumPlanes); // 평면의 배열을 인자로 넣어 절두체를 구축한다. // 절두체 컬링 테스트를 위한 통계 변수 size_t totalObjects = g.GetScene().size(); // 씬에 속한 전체 게임 오브젝트 수를 파악한다. size_t culledObjects = 0; // 렌더링이 진행된 게임 오브젝트 수를 파악한다. size_t renderedObjects = 0; // 렌더링이 진행된 게임 오브젝트 수를 파악한다. for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); // 절두체 컬링 구현 // 게임 오브젝트의 위치를 뷰 공간으로 변환한다. Vector4 viewPos = vMatrix * Vector4(transform.GetPosition()); // 뷰 공간의 위치가 절두체 영역의 외부에 있는지 검사한다. if (frustumFromMatrix.CheckBound(viewPos.ToVector3()) == BoundCheckResult::Outside) { // 그리지 않고 건너뜀 culledObjects++; continue; } // 최종 행렬 계산 Matrix4x4 finalMatrix = pvMatrix * transform.GetModelingMatrix(); // 메시 그리기 DrawMesh3D(mesh, finalMatrix, gameObject.GetColor()); // 그린 물체를 통계에 포함 renderedObjects++; } r.PushStatisticText(\u0026#34;Total GameObjects : \u0026#34; + std::to_string(totalObjects)); r.PushStatisticText(\u0026#34;Culled GameObjects : \u0026#34; + std::to_string(culledObjects)); r.PushStatisticText(\u0026#34;Rendered GameObjects : \u0026#34; + std::to_string(renderedObjects)); } ","date":"2022-04-20T17:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-13-1/","title":"[Game Math] Chapter 13. 절두체: 최적화된 3차원 공간 (1)"},{"content":" 원근 투영 변환의 원리 투시 원근법(Perspective projection drawing)\n시선을 한 점에 고정시키고, 고정된 점으로부터 화폭까지 곧게 뻗은 실을 활용해서 그림을 그려나가는 것이다. 원근 투영 변환(Perspective projection transformation)\n투시 원근법의 원리를 적용하기 위해서 공간의 모든 점이 한 점을 향해 모이는 형태로 변환하는 것이다. 즉, $x$, $y$, $z$축이 모두 직교하는 정육면체 형태를 가진 뷰 공간을 카메라의 한 점으로 모이는 사각뿔 형태를 가진 공간으로 변환하는 작업이다. 화각(Field of view)\n카메라를 통해서 이미지를 담을 수 있는 각을 말한다. 카메라에 화각을 설정하면 좌우와 위아래가 균등한 사각뿔 영역이 만들어진다. 투영 평면(Projection plane)\n3차원 공간을 원근 투영 변환한 후에는 그것을 2차원의 모니터 평면에 담아내야 한다. 이를 위해서 모든 물체의 상이 맺히는 가상의 평면을 생성해야 하는데 이것을 투영 평면이라고 한다. 초점 거리(Focal length)\n카메라로부터 투영 평면까지의 거리이다. NDC(Normalized device coordinate)\n원근 투영 변환을 위해서는 먼저 투영 평면의 위치를 지정해야 한다. 일반적으로 투영 평면의 위치는 계산의 편의를 위해서 위 아래의 크기가 각각 $1$이 되는 지점으로 결정한다. 따라서 다음과 같이 좌우와 상하가 $[-1, 1]$의 범위를 가지는 정사각형의 모습을 띤다. 이 정사각형 영역은 2차원 평면의 좌표 시스템을 가지는데 이를 NDC라고 한다. NDC는 가운데 중점을 원점으로 설정한다. NDC가 언제나 일정한 값을 가진다면, 화각에 따라 초점 거리가 달라질 수밖에 없다.\n화각이 커질 수록 초점 거리는 가까워지고, 화각이 작아질 수록 초점 거리는 멀어지겠다. $$\\tan(\\frac{\\theta}{2}) = \\frac{1}{d}$$ $$ d = \\frac{1}{\\tan(\\frac{\\theta}{2})} $$ 사영 공간(Projective space) 지금까지의 공간 변환은 $x$, $y$, $z$축이 모두 직교하고 정육면체 형태의 3차원 공간이었다. 하지만 원근 투영 변환을 거치면 사각뿔 형태로 바뀌게 된다. 이것을 사영 공간이라고 한다. $x$, $y$축은 여전히 직교하므로 유클리드 공간과 동일한 성질을 가진다. 하지만 $z$축은 독립적으로 행동하지 않고 $x$, $y$축에 모두 영향을 준다. 이것이 초점 거리에 따라 투영 평면의 면적이 달라지는 이유이기도 하겠다. 그렇다면 원근 투영 변환에 대응하는 행렬은 어떻게 설계할 수 있을까? $x$축을 배제하고 $y$, $z$축으로 공간을 설정하고 투영 평면에 상이 맺히는 과정을 생각해보자. 뷰공간의 점 $P_{view}$가 투영 평면에 투영된 점을 $P_{ndc}$라고 한다면 좌표는 다음과 같다. $P_{view} = (0, v_y, v_z)$ $P_{ndc} = (0, n_y)$ 두 점의 관계를 닮은꼴 삼각형 두개로 알아보면 다음과 같은 비가 성립된다. $n_y : d = v_y : -v_z$ $n_y = \\frac{d \\cdot v_y}{-v_z}$ 카메라의 좌우 상하 시야각은 동일하므로 NDC의 $x$값 또한 $y$값을 $0$으로 고정한 후 $x$, $z$축의 평면을 사용하는 방식으로 구할 수 있다. 따라서 초점 거리와 뷰 좌표로부터 $P_{ndc}$를 구할 수 있다. $$P_{ndc} = (n_x, n_y) = (\\frac{d \\cdot v_x}{-v_z}, \\frac{d \\cdot v_y}{-v_z}) = -\\frac{d}{v_z}(v_x, v_y)$$ 이제 NDC좌표를 계산했으니, 이 좌표를 모니터 해상도 만큼 가로 세로로 늘려주면 최종 스크린 좌표가 완성된다. 근데 가로 세로 해상도가 다르기 때문에 늘리면 물체가 찌그러지겠다. 가로 세로의 비를 종횡비(Aspect ratio) 라고 한다. 종횡비를 파악해서 미리 NDC영역에서 찌그러트린 다음에 펼치면 문제 해결이 가능하겠다. 예를 들어, $800 \\times 600$해상도에서 세로 크기를 기준으로 잡은 종횡비는 $1.3333$이다. 이 종횡비를 $a$라고 하자. 그러면 좌우로 찌그러트리기 위해서 $x$축에 종횡비의 역수 $\\frac{1}{a}$를 곱하면 되겠다. $$P_{ndc} = -\\frac{d}{v_z}(\\frac{v_x}{a}, v_y)$$ 이렇게 최종 NDC값을 계산하는 원근 투영 행렬 $P$를 다음과 같이 설계할 수 있겠다. $$P_{ndc} = P \\cdot \\vec{v} = \\begin{bmatrix} \\frac{1}{a} \\cdot \\frac{d}{-v_z} \u0026amp; 0 \\\\ 0 \u0026amp; \\frac{d}{-v_z} \\end{bmatrix} \\begin{bmatrix} v_x \\\\ v_y \\end{bmatrix}$$ 하지만 한 가지 아쉽다. 변환할 점의 $z$값이 행렬에 사용되다보니 변환할 점마다 항상 행렬을 새롭게 생성해야 한다. Chapter 5에서 본것처럼 미리 곱해둔 행렬을 계속 사용한다면 굉장히 연산량을 줄일 수 있겠다. 이건 어떨까? $-\\vec{v_z}$값을 행렬에서 제거하고 대신 행렬의 결괏값에서 $-\\vec{v_z}$를 나누어 주는 거다. $$P_{ndc} = P \\cdot \\vec{v} = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; d \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; -1 \\end{bmatrix} \\begin{bmatrix} v_x \\\\ v_y \\\\ v_z \\end{bmatrix} = \\begin{bmatrix} \\frac{d}{a} \\cdot v_x \\\\ d \\cdot v_y \\\\ -v_z\\end{bmatrix}$$ 클립 좌표(Clip coordinate) 이렇게 원근 투영 행렬 $P$로 변환되는 좌표계를 클립 좌표라고 부르며 다음과 같이 계산한다. $$P_{clip} = (\\frac{d}{a} \\cdot v_x , d \\cdot v_y , -v_z)$$ 이 클립좌표를 세 번째 값인 $-v_z$로 나누면 NDC좌표를 얻을 수 있다. $$P_{ndc} = (\\frac{d \\cdot v_x}{-v_z \\cdot a}, \\frac{d \\cdot v_y}{-v_z}, 1)$$ 동차 좌표계 동차 좌표계(Homogenous coordinate system) 동차란? 모든 항의 차수가 같음을 의미한다. 한 차원 높인 벡터를 사용하는 것을 동차 좌표계라고 한다. 사영 공간이 사용하는 좌표계는 동차 좌표계이다. 왜냐하면\u0026hellip; 3차원의 사영 공간에서 평행하게 점을 이동시키면?\n카메라에 멀어질 수록 투영된 좌푯값이 투영 평면의 원점에 가까워지고, 카메라에 가까워질수록 커진다. 즉, 사영 공간의 점과 투영된 점의 좌표는 반비례 관계이다. 사영 공간의 점을 $(x\u0026rsquo;, y\u0026rsquo;, z\u0026rsquo;)$라고 하고, 해당 점이 투영된 NDC좌표를 $(x, y)$라고 하자. 그러면 NDC 좌푯값은 마지막 차원값 $z\u0026rsquo;$에 반비례로 영향을 받으므로 다음과 같은 관계가 성립한다. $$ x = \\frac{x\u0026rsquo;}{z\u0026rsquo;}, y = \\frac{y\u0026rsquo;}{z\u0026rsquo;}$$ 사영 공간의 좌표로 직선의 방정식을 표현해보자. 위의 $x$, $y$를 직선의 방정식 $y = ax + b$에 대입해보자.\n$$\\frac{y\u0026rsquo;}{z\u0026rsquo;} = a\\frac{x\u0026rsquo;}{z\u0026rsquo;} + b$$ $$ y\u0026rsquo; = ax\u0026rsquo; + bz\u0026rsquo;$$ 위와 같이 세 미지수의 차수가 모두 1차식으로 동일한 방정식이 만들어진다. 이렇게 미지수에 대한 차수가 동일한 방정식을 동차 방정식이라고 한다. 그래서 사영 공간이 사용하는 좌표계는 동차좌표계라고 부른다. NDC의 원점 $(0, 0)$\n카메라로 멀어질수록 투영된 NDC 좌푯값은 원점 $(0, 0)$에 가까워진다. 이런 NDC의 원점은 회화의 투시 원근 기법에서 사용하는 소실점(Vanishing point) 에 해당한다. 다음은 원근 투영 변환행렬을 사용해서 원근감을 준 코드이다. 또한 입력에 따라 화각을 달리하여 변화되는 모습을 볼 수 있다.\n클립 좌표 값 얻기\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class CameraObject { public: FORCEINLINE Matrix4x4 GetPerspectiveMatrix() const; private: float _FOV = 60.f; // 시야각 }; // 원근 투영 행렬 P를 생성한다. FORCEINLINE Matrix4x4 CameraObject::GetPerspectiveMatrix() const { float invA = 1.f / _ViewportSize.AspectRatio(); float d = 1.f / tanf(Math::Deg2Rad(_FOV) * 0.5f); return Matrix4x4( Vector4::UnitX * invA * d, Vector4::UnitY * d, Vector4(0.f, 0.f, -1.f, 0.f), Vector4(0.f, 0.f, 0, 1.f) ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // 게임 로직을 담당하는 함수 void SoftRenderer::Update3D(float InDeltaSeconds) { // 게임 로직에서 사용하는 모듈 내 주요 레퍼런스 GameEngine\u0026amp; g = Get3DGameEngine(); const InputManager\u0026amp; input = g.GetInputManager(); // 게임 로직의 로컬 변수 static float moveSpeed = 500.f; static float fovSpeed = 100.f; // 시야각 조절 속도 static float minFOV = 15.f; // 최소 시야각 static float maxFOV = 150.f; // 최대 시야각 // 게임 로직에서 사용할 게임 오브젝트 레퍼런스 GameObject\u0026amp; goPlayer = g.GetGameObject(PlayerGo); CameraObject\u0026amp; camera = g.GetMainCamera(); TransformComponent\u0026amp; playerTransform = goPlayer.GetTransform(); // 입력에 따른 플레이어 트랜스폼의 변경 Vector3 inputVector = Vector3(input.GetAxis(InputAxis::XAxis), input.GetAxis(InputAxis::YAxis), input.GetAxis(InputAxis::ZAxis)).GetNormalize(); playerTransform.AddPosition(inputVector * moveSpeed * InDeltaSeconds); // 입력에 따른 카메라 트랜스폼의 변경 // deltaFOV로 시야각 변화량을 계산하고 // 최소, 최댓값 사이로 시야각을 설정한다. camera.SetLookAtRotation(playerTransform.GetPosition()); float deltaFOV = input.GetAxis(InputAxis::WAxis) * fovSpeed * InDeltaSeconds; camera.SetFOV(Math::Clamp(camera.GetFOV() + deltaFOV, minFOV, maxFOV)); } // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render3D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 const GameEngine\u0026amp; g = Get3DGameEngine(); auto\u0026amp; r = GetRenderer(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 배경에 기즈모 그리기 DrawGizmo3D(); // 렌더링 로직의 로컬 변수 const Matrix4x4 vMatrix = mainCamera.GetViewMatrix(); const Matrix4x4 pMatrix = mainCamera.GetPerspectiveMatrix(); for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); // 원근투영행렬 * 뷰행렬 * 모델링행렬 // (1) 결과는 클립 좌표의 값이겠다. Matrix4x4 finalMatrix = pMatrix * vMatrix * transform.GetModelingMatrix(); // 메시 그리기 DrawMesh3D(mesh, finalMatrix, gameObject.GetColor()); if (gameObject == PlayerGo) { // 플레이어의 위치 r.PushStatisticText(\u0026#34;Player: \u0026#34; + transform.GetPosition().ToString()); } } r.PushStatisticText(\u0026#34;Camera: \u0026#34; + mainCamera.GetTransform().GetPosition().ToString()); r.PushStatisticText(\u0026#34;FOV : \u0026#34; + std::to_string(mainCamera.GetFOV())); } 클립 좌표 값을 NDC로 변환하고 해상도 크기로 늘려주기. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 삼각형을 그리는 함수 void SoftRenderer::DrawTriangle3D(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { auto\u0026amp; r = GetRenderer(); const GameEngine\u0026amp; g = Get3DGameEngine(); // (2) 클립 좌표를 NDC 좌표로 변경 for (auto\u0026amp; v : InVertices) { // 무한 원점인 경우, 약간 보정해준다. if (v.Position.Z == 0.f) v.Position.Z = SMALL_NUMBER; float invZ = 1.f / v.Position.Z; v.Position.X *= invZ; v.Position.Y *= invZ; v.Position.Z *= invZ; } // 백페이스 컬링 Vector3 edge1 = (InVertices[1].Position - InVertices[0].Position).ToVector3(); Vector3 edge2 = (InVertices[2].Position - InVertices[0].Position).ToVector3(); Vector3 faceNormal = -edge1.Cross(edge2); Vector3 viewDirection = Vector3::UnitZ; if (faceNormal.Dot(viewDirection) \u0026gt;= 0.f) { return; } // (3) NDC 좌표를 화면 좌표로 늘리기 for (auto\u0026amp; v : InVertices) { v.Position.X *= _ScreenSize.X * 0.5f; v.Position.Y *= _ScreenSize.Y * 0.5f; } LinearColor finalColor = _WireframeColor; if (InColor != LinearColor::Error) { finalColor = InColor; } r.DrawLine(InVertices[0].Position, InVertices[1].Position, finalColor); r.DrawLine(InVertices[0].Position, InVertices[2].Position, finalColor); r.DrawLine(InVertices[1].Position, InVertices[2].Position, finalColor); } 깊이 값 깊이(Depth) 값의 필요성 우리에게 보이는 화면은 결국 2차원 평면이므로 가장 카메라에서 멀리 있는 나중에 그린 물체가 앞에 보일 수 밖에 없다. 이 문제를 해결하기 위해서는 카메라로부터 물체가 얼마나 떨어졌는지에 대한 깊이 값이 필요하다. 깊이 값을 추가하면 2차원 평면이었던 NDC영역이 3차원으로 확장된다. 여기서 깊이값의 범위는 동일하게 $[-1, 1]$ 이다. 절두체(Frustum)\n카메라에 가장 가까이 있는, 깊이 값이 $-1$인 평면을 근평면(Near plane) 이라고 한다. 반대로 가장 멀리에 있는, 깊이 값이 $1$인 평면을 원평면(Far plane) 이라고 한다. 사영 공간을 근평면과 원평면으로 잘라서 만들어진 부분을 절두체라고 한다. 절두체로 생성되는 3차원의 NDC영역의 범위는 다음과 같다. NDC 깊이 값은 멀어질수록 증가하기 때문에 왼손좌표계를 사용한다. 원근 투영 행렬에 깊이 값을 넣기 위해 3행을 4행으로 옮기고 3행을 깊이값을 구하는 용도로 변경하자. 뷰 공간의 점이 $\\vec{v} = (v_x, v_y, v_z, 1)$일 때 다음과 같이 구할 수 있다. $$ P \\cdot \\vec{v} = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ ? \u0026amp; ? \u0026amp; ? \u0026amp; ? \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} v_x \\\\ v_y \\\\ v_z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} \\frac{d}{a} \\cdot v_x \\\\ d \\cdot v_y \\\\ ? \\\\ -v_z\\end{bmatrix}$$ 여기서 깊이 값은 뷰 좌표계의 $x$, $y$축과 직교하므로 영향을 받지 않는다. 그러므로 3행의 앞의 두 요소는 $0$으로 설정할 수 있겠다. $$ P \\cdot \\vec{v} = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; ? \u0026amp; ? \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} v_x \\\\ v_y \\\\ v_z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} \\frac{d}{a} \\cdot v_x \\\\ d \\cdot v_y \\\\ ? \\\\ -v_z\\end{bmatrix}$$ 이제 여기에서 근평면과 원평면의 값을 사용해보자. 근평면에 있는 점을 $P_1$, 원평면에 있는 점을 $P_2$라고 하자. 그리고 카메라부터 근평면까지의 거리를 $n$, 원평면까지의 거리를 $f$라고 하자. 근평면의 경우 뷰 공간의 좌표는 $(0, 0, -n, 1)$이 된다. 근평면은 깊이 값의 시작부분이므로 NDC좌표의 $(0, 0, -1)$에 대응한다. 따라서 다음과 같이 만들어진다. $$ P_1 = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; ? \u0026amp; ? \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 0 \\\\ -n \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ ? \\\\ n \\end{bmatrix}$$ 클립 좌표의 경우 세번째 원소를 마지막 네번째 원소로 나눈 값이 NDC의 세번째 원소인 $-1$이 되므로, $?$는 $-n$이 된다. $$ P_1 = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; ? \u0026amp; ? \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 0 \\\\ -n \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ -n \\\\ n \\end{bmatrix}$$ 원평면의 경우 동일한 방식으로 다음과 같이 구할 수 있겠다. $$ P_2 = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; ? \u0026amp; ? \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 0 \\\\ -f \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ f \\\\ f \\end{bmatrix}$$ 여기서 두행렬의 3행과 뷰 공간의 점을 내적한 후 수식을 정리하면 다음과 같이 최종 원근 투영 행렬을 구할 수 있다. $$ P = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; \\frac{n + f}{n - f} \u0026amp; \\frac{2nf}{n - f} \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} $$ 위에서 봤던 예제 코드에다가 깊이 값까지 계산하는 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class CameraObject { public: FORCEINLINE Matrix4x4 GetPerspectiveMatrix() const; FORCEINLINE Matrix4x4 GetPerspectiveViewMatrix() const; private: float _FOV = 60.f; float _NearZ = 5.5f; float _FarZ = 5000.f; }; // 깊이 값을 계산하는 최종 원근 투영 행렬 FORCEINLINE Matrix4x4 CameraObject::GetPerspectiveMatrix() const { // 투영 행렬. 깊이 값의 범위는 -1~1 float invA = 1.f / _ViewportSize.AspectRatio(); float d = 1.f / tanf(Math::Deg2Rad(_FOV) * 0.5f); // 근평면과 원평면에 반대 부호를 붙여서 계산 float invNF = 1.f / (_NearZ - _FarZ); float k = (_FarZ + _NearZ) * invNF; float l = 2.f * _FarZ * _NearZ * invNF; return Matrix4x4( Vector4::UnitX * invA * d, Vector4::UnitY * d, Vector4(0.f, 0.f, k, -1.f), Vector4(0.f, 0.f, l, 0.f) ); } // 원근투영 행렬과 뷰 행렬을 곱한 행렬 FORCEINLINE Matrix4x4 CameraObject::GetPerspectiveViewMatrix() const { // 뷰 행렬 관련 요소 Vector3 viewX, viewY, viewZ; GetViewAxes(viewX, viewY, viewZ); Vector3 pos = _Transform.GetPosition(); float zPos = viewZ.Dot(pos); // 투영 행렬 관련 요소 float invA = 1.f / _ViewportSize.AspectRatio(); float d = 1.f / tanf(Math::Deg2Rad(_FOV) * 0.5f); float dx = invA * d; float invNF = 1.f / (_NearZ - _FarZ); float k = (_FarZ + _NearZ) * invNF; float l = 2.f * _FarZ * _NearZ * invNF; return Matrix4x4( Vector4(dx * viewX.X, d * viewY.X, k * viewZ.X, -viewZ.X), Vector4(dx * viewX.Y, d * viewY.Y, k * viewZ.Y, -viewZ.Y), Vector4(dx * viewX.Z, d * viewY.Z, k * viewZ.Z, -viewZ.Z), Vector4(-dx * viewX.Dot(pos), -d * viewY.Dot(pos), -k * zPos + l, zPos) ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render3D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 const GameEngine\u0026amp; g = Get3DGameEngine(); auto\u0026amp; r = GetRenderer(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 배경에 기즈모 그리기 DrawGizmo3D(); // 원근 투영 행렬 * 뷰행렬의 결과 행렬 const Matrix4x4 pvMatrix = mainCamera.GetPerspectiveViewMatrix(); for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); // 원근 투영 행렬 * 뷰행렬 * 모델링 행렬 Matrix4x4 finalMatrix = pvMatrix * transform.GetModelingMatrix(); // 메시 그리기 DrawMesh3D(mesh, finalMatrix, gameObject.GetColor()); if (gameObject == PlayerGo) { // 플레이어 관련 정보 나타내기 // 플레이어의 클립 좌표 구하기 Vector4 clippedPos = pvMatrix * Vector4(transform.GetPosition()); // 클립 좌표의 네번째 요소 -Vz float cameraDepth = clippedPos.W; // -Vz가 0인 경우 0이 되지 않도록 보완해주기 if (cameraDepth == 0) cameraDepth = SMALL_NUMBER; // NDC의 깊이값 계산: 클립좌표의 세번째 요소 / 클립좌표의 네번째 요소 float ndcZ = clippedPos.Z / cameraDepth; r.PushStatisticText(\u0026#34;Player: \u0026#34; + transform.GetPosition().ToString()); r.PushStatisticText(\u0026#34;Depth: \u0026#34; + std::to_string(ndcZ)); r.PushStatisticText(\u0026#34;Distance: \u0026#34; + std::to_string(clippedPos.W)); } } r.PushStatisticText(\u0026#34;Camera: \u0026#34; + mainCamera.GetTransform().GetPosition().ToString()); r.PushStatisticText(\u0026#34;FOV : \u0026#34; + std::to_string(mainCamera.GetFOV())); } 원근 보정 매핑 문제가 한 가지 있다. 투영 전과 투영 후의 무게중심좌표가 달라져서 텍스처 매핑을 하면 이상하게 나온다. 예를 들어, 사영 공간의 점 $P_1$, $P_3$가 카메라 시야각에 걸쳐 있고, 카메라 정면에 위치한 점 $P_2$가 있다고 하자. 그러면 $P_2$를 투영한 후에 NDC좌표는 투영 평면의 정 중앙에 위치하며 무게중심좌표가 $0.5$가 된다. 하지만 투영 전을 보면 $0.5$보다 더 작은 값이 나올 것이다. 이것은 변환 과정에서 사영 공간의 마지막 요소인 $-v_z$로 나눴기 때문이다. 이런 반비례 관계때문에 이런 문제가 발생하였다. 따라서 NDC에서의 무게중심좌표가 아니라 투영 전 사영 공간의 무게중심좌표를 써야 한다. 만약 NDC에서의 무게중심좌표를 가지고 투영 전 사영 공간의 무게중심좌표를 알아낼 수 있다면 좋을 것이다. 투영 보정 보간(Perspective correction interpolation) 투영 전의 무게중심좌표 값을 계산해서 텍스처를 매핑하는 것이다. 반비례 함수 $y = -\\frac{1}{x}$가 가진 성질을 먼저 살펴보자. $x$축에 위치한 세 수 중에서 가운데 위치한 $4$의 무게중심좌표 $a$는 다음 식에 의해 구할 수 있으며 $a = 0.5$가 된다. $ 4 = a \\cdot 2 + (1-a) \\cdot 6 $ 그리고 $y$축에서 가운데 위치한 $-\\frac{1}{4}$의 경우 다음과 같으며 $a = 0.25$가 된다. $ -\\frac{1}{4} = a \\cdot - \\frac{1}{2} + (1 - a) \\cdot -\\frac{1}{6}$ 이 둘을 다음과 같이 나타내 보자. $$ x\u0026rsquo; = t_1 \\cdot x_1 + t_2 \\cdot x_2 (t_1 + t_2 = 1) $$ $$ y\u0026rsquo; = q_1 \\cdot y_1 + q_2 \\cdot y_2 (q_1 + q_2 = 1) $$ $x\u0026rsquo;$, $y\u0026rsquo;$는 서로 반비례 관계이므로 $y$값을 $\\frac{1}{x}$로 나타낼 수 있다. $$ \\frac{1}{x\u0026rsquo;} = q_1 \\cdot \\frac{1}{x_1} + q_2 \\cdot \\frac{1}{x_2} $$ $$ x\u0026rsquo; = \\frac{1}{ q_1 \\cdot \\frac{1}{x_1} + q_2 \\cdot \\frac{1}{x_2} }$$ 이 식을 다시 변환해보자. $$ q_1 \\cdot \\frac{x\u0026rsquo;}{x_1} + q_2 \\cdot \\frac{x\u0026rsquo;}{x_2} = 1 = t_1 + t_2 $$ 따라서 다음 식을 도출할 수 있다. $$ t_1 = \\frac{x\u0026rsquo;}{x_1}q_1 $$ $$ t_2 = \\frac{x\u0026rsquo;}{x_2}q_2 $$ 위의 식이 올바르게 적용되는지 확인해보자. $y$축에서 $q_1 = \\frac{1}{4}, q_2 = \\frac{3}{4}$ 이다. $x$축에서 $x_1 = 2, x_2 = 6, x\u0026rsquo; = 4$이다. $t_1 = \\frac{x\u0026rsquo;}{x_1}q_1 = \\frac{4}{2} \\cdot \\frac{1}{4} = 0.5$ $t_2 = \\frac{x\u0026rsquo;}{x_2}q_2 = \\frac{4}{6} \\cdot \\frac{3}{4} = 0.5$ 따라서 $t_1$, $t_2$가 $0.5$임을 알 수 있다. 두 점이 아닌 삼각형의 세 점으로 확장하고, $x$를 $-z$로 치환하면 최종 투영 보정 보간식을 얻을 수 있다. $$ z\u0026rsquo; = \\frac{1}{ q_1 \\cdot \\frac{1}{z_1} + q_2 \\cdot \\frac{1}{z_2} + q_3 \\cdot \\frac{1}{z_3}}$$ $$ t_1 = \\frac{z\u0026rsquo;}{z_1}q_1 $$ $$ t_2 = \\frac{z\u0026rsquo;}{z_2}q_2 $$ $$ t_3 = \\frac{z\u0026rsquo;}{z_3}q_3 $$ 다음은 원근 보정 매핑(Perspective correction mapping) 을 하는 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 삼각형을 그리는 함수 void SoftRenderer::DrawTriangle3D(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { //... // 두 점이 화면 밖을 벗어나는 경우 클리핑 처리 lowerLeftPoint.X = Math::Max(0, lowerLeftPoint.X); lowerLeftPoint.Y = Math::Min(_ScreenSize.Y, lowerLeftPoint.Y); upperRightPoint.X = Math::Min(_ScreenSize.X, upperRightPoint.X); upperRightPoint.Y = Math::Max(0, upperRightPoint.Y); // 각 정점마다 보존된 뷰 공간의 z값: 1/z1, 1/z2, 1/z3 float invZ0 = 1.f / InVertices[0].Position.W; float invZ1 = 1.f / InVertices[1].Position.W; float invZ2 = 1.f / InVertices[2].Position.W; // 삼각형 영역 내 모든 점을 점검하고 색칠 for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++y) { ScreenPoint fragment = ScreenPoint(x, y); Vector2 pointToTest = fragment.ToCartesianCoordinate(_ScreenSize); Vector2 w = pointToTest - InVertices[0].Position.ToVector2(); float wdotu = w.Dot(u); float wdotv = w.Dot(v); float s = (wdotv * udotv - wdotu * vdotv) * invDenominator; float t = (wdotu * udotv - wdotv * udotu) * invDenominator; float oneMinusST = 1.f - s - t; if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { // 투영보정에 사용할 공통 분모: z\u0026#39; float z = invZ0 * oneMinusST + invZ1 * s + invZ2 * t; float invZ = 1.f / z; Vector2 targetUV = ( InVertices[0].UV * oneMinusST * invZ0 + // q1/z1 InVertices[1].UV * s * invZ1 + // q2/z2 InVertices[2].UV * t * invZ2 // q3/z3 ) * invZ; r.DrawPoint(fragment, FragmentShader3D(mainTexture.GetSample(targetUV), LinearColor::White)); } } } } 깊이 버퍼 깊이 테스팅(Depth testing) 이전에 깊이 값을 구해서 멀리 떨어진 물체를 먼저 그렸다. 하지만 물체가 겹쳐 있다면 어떻게 할 것인가? 근본적인 해결방법은 게임 오브젝트 단위가 아니라, 삼각형의 픽셀단위로 깊이를 비교하고, 가까운 곳에 있는 픽셀만 그리는 것이다. 화면의 픽셀마다 깊이 값을 별도로 보관하는 깊이 버퍼(Depth buffer) 를 사용하면 되겠다. 현재 깊이 값을 깊이 버퍼에 저장된 값과 비교해서 현재 깊이 값이 작은 경우에만 픽셀을 찍도록 하면 된다. 이 작업을 깊이 테스팅이라고 한다. 삼각형을 구성하는 세 점의 깊이 값 $z_1$, $z_2$, $z_3$(범위: $[-1, 1]$)으로부터 각 픽셀의 무게중심좌표 $q_1$, $q_2$, $q_3$(범위: $[0, 1]$)을 사용해서 픽셀의 깊이 값을 구할 수 있겠다. $$ z\u0026rsquo; = q_1 \\cdot z_1 + q_2 \\cdot z_2 + q_3 \\cdot z_3$$ $z\u0026rsquo;$ 값의 범위는 $[-1, 1]$이 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 삼각형을 그리는 함수 void SoftRenderer::DrawTriangle3D(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { //... // 삼각형 영역 내 모든 점을 점검하고 색칠 for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++y) { //... if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { //... // 깊이 버퍼 테스팅 if (toggleDepthTesting) { // 깊이 테스팅 float newDepth = InVertices[0].Position.Z * oneMinusST + InVertices[1].Position.Z * s + InVertices[2].Position.Z * t; float prevDepth = r.GetDepthBufferValue(fragment); if (newDepth \u0026lt; prevDepth) { // 픽셀을 처리하기 전 깊이 값을 버퍼에 보관 r.SetDepthBufferValue(fragment, newDepth); } else { // 이미 앞에 무언가 그려져있으므로 픽셀그리기는 생략 continue; } } Vector2 targetUV = (InVertices[0].UV * oneMinusST * invZ0 + InVertices[1].UV * s * invZ1 + InVertices[2].UV * t * invZ2) * invZ; r.DrawPoint(fragment, FragmentShader3D(mainTexture.GetSample(targetUV), LinearColor::White)); } } } } 깊이 값은 카메라에서 멀어질 수록 급격히 $1$과 가까워진다. 이것은 NDC공간에서 깊이 값의 변화가 $y = -\\frac{1}{x}$로 비선형 형태를 띠기 때문이다. 따라서 이를 해결하기 위해 이전에 다뤘던 원근 보정 매핑 방식을 이용해서 뷰 공간의 깊이 값을 활용할 수 있겠다. $$ z\u0026rsquo; = \\frac{1}{ q_1 \\cdot \\frac{1}{z_1} + q_2 \\cdot \\frac{1}{z_2} + q_3 \\cdot \\frac{1}{z_3}}$$ 다음은 깊이 값을 $[0, 1]$범위로 바꾸어서 그 값에 따라 흑백 이미지로 출력하는 예제이다. 뷰 공간에서 절두체가 가지는 깊이의 범위는 원평면에서 근평면을 뺀 $f-n$이다. 따라서 이때 사용할 깊이값은 다음과 같다. $$c_{depth} = \\frac{z\u0026rsquo; - n}{f - n}$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 삼각형을 그리는 함수 void SoftRenderer::DrawTriangle3D(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { auto\u0026amp; r = GetRenderer(); const GameEngine\u0026amp; g = Get3DGameEngine(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 카메라의 근평면과 원평면 값 float n = mainCamera.GetNearZ(); float f = mainCamera.GetFarZ(); //... // 삼각형 영역 내 모든 점을 점검하고 색칠 for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++y) { //... if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { //... if (IsDepthBufferDrawing()) { float grayScale = (newDepth + 1.f) * 0.5f; if (useLinearVisualization) { // 카메라로부터의 거리에 따라 균일하게 증감하는 흑백 값으로 변환 grayScale = (invZ - n) / (f - n); } // 뎁스 버퍼 그리기 r.DrawPoint(fragment, LinearColor::White * grayScale); } else { // 최종 보정보간된 UV 좌표 Vector2 targetUV = (InVertices[0].UV * oneMinusST * invZ0 + InVertices[1].UV * s * invZ1 + InVertices[2].UV * t * invZ2) * invZ; r.DrawPoint(fragment, FragmentShader3D(mainTexture.GetSample(targetUV), LinearColor::White)); } } } } } ","date":"2022-04-15T17:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-12/","title":"[Game Math] Chapter 12. 원근 투영: 화면에 현실감을 부여하는 변환"},{"content":" 벡터의 외적 벡터의 외적(Cross product) $\\vec{a} = (a_x, a_y, a_z), \\vec{b} = (b_x, b_y, b_z)$ $\\vec{a} \\times \\vec{b} = (a_yb_z - a_zb_y, a_zb_x - a_xb_z, a_xb_y - a_yb_x)$ Chapter 10에서 설명했던 회전의 순환 순서 $x$→$y$→$z$→$x$에 맞춰 벡터를 순서대로 나열하는 형태이며, 결과는 언제나 3차원 벡터가 된다. $x$성분의 결과를 만들기 위해 $x$와 관련없는 나머지 두 성분의 $y$와 $z$를 결합해서 만든다. 항상 같은 성분만 사용하는 내적과 대비된다. 외적의 성질 교환법칙이 성립하지 않는다. 위의 식을 살펴보면 교환법칙이 성립하지 않는 뺄셈을 사용한 것을 알 수 있다. $\\vec{a} \\times \\vec{b} \\neq \\vec{b} \\times \\vec{a}$ 뺄셈처럼, 순서를 바꿔서 연산하면 반대 방향이 나온다. $\\vec{a} \\times \\vec{b} = -\\vec{a} \\times \\vec{b}$ 결합법칙이 성립하지 않는다. $\\vec{a} \\times (\\vec{b} \\times \\vec{c}) \\neq (\\vec{a} \\times \\vec{b}) \\times \\vec{c}$ 덧셈에 대한 분배법칙은 성립한다. $\\vec{a} \\times (\\vec{b} + \\vec{c}) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c}$ 내적 외적 계산 결과 스칼라 벡터 교환법칙 성립함 성립하지 않음 결합법칙 성립하지 않음 성립하지 않음 분배법칙 성립함 성립함 연산 방법 같은 위치의 요소만 사용 다른 위치의 요소만 사용 평행성 판별 평행한 두벡터를 외적하면 항상 영벡터가 나온다. 동일한 벡터를 내적하면? 벡터 크기를 제곱한 값이 나왔다. 그렇다면 동일한 벡터를 외적하면? 그 결과는 항상 영벡터가 나온다. $\\vec{a} \\times \\vec{a} = (a_ya_z - a_za_y, a_za_x - a_xa_z, a_xa_y - a_ya_x) = (0, 0, 0)$ 이것은 반대 방향의 벡터 $-\\vec{a}$를 외적하는 경우에도 동일하다. $\\vec{a} \\times -\\vec{a} = (-a_ya_z + a_za_y, -a_za_x + a_xa_z, -a_xa_y + a_ya_x) = (0, 0, 0)$ 평행하지만 크기가 다른 벡터 $k \\cdot \\vec{a}$를 사용해도 마찬가지이다. $\\vec{a} \\times (k \\cdot \\vec{a}) = (ka_ya_z - ka_za_y, ka_za_x - ka_xa_z, ka_xa_y - ka_ya_x) = (0, 0, 0)$ 벡터 $\\vec{b}$를 벡터 $\\vec{a}$에 수평인 벡터 $\\vec{b_{\\parallel}}$와 수직인 벡터 $\\vec{b_{\\perp}}$로 분리하여, 그 둘의 덧셈으로 나타낼 수 있다. $\\vec{a} = \\vec{b_{\\parallel}} + \\vec{b_{\\perp}}$ 이것을 $\\vec{a} \\times \\vec{b}$에 적용하면 다음과 같다. $\\vec{a} \\times \\vec{b} = \\vec{a} \\times (\\vec{b_{\\parallel}} + \\vec{b_{\\perp}})= \\vec{a} \\times \\vec{b_{\\parallel}} + \\vec{a} \\times \\vec{b_{\\perp}}$ 여기서 $\\vec{a} \\times \\vec{b_{\\parallel}}$는 서로 평행해서 영벡터이므로 다음과 같아진다. $\\vec{a} \\times \\vec{b} = \\vec{a} \\times \\vec{b_{\\perp}}$ 이처럼 외적은 상대방에 직교하는 벡터 성분만 사용되는 성질이 있다. 외적의 크기는 $\\sin$함수에 비례하며, 두 벡터가 만드는 평행사변형의 넓이와 같다. 아래 그림을 보면, (1)과 같이 두 벡터의 사잇각이 크면 직교 성분 $\\vec{b_{\\perp}}$의 크기는 커지고, 반대로 (2)와 같이 사잇각이 작으면 $\\vec{b_{\\perp}}$의 크기는 작아진다. 따라서, 외적의 크기도 $\\sin$함수에 비례할 것이다. 이것을 수식으로 확인해보기 위해 $|\\vec{a} \\times \\vec{b}|^2$, $(|\\vec{a}||\\vec{b}|)^2$, $(\\vec{a} \\cdot \\vec{b})^2$를 구해보면 다음과 같은 관계를 도출할 수 있다. (풀이 생략) $|\\vec{a} \\times \\vec{b}|^2 = (|\\vec{a}||\\vec{b}|)^2 - (\\vec{a} \\cdot \\vec{b})^2$ $ = (|\\vec{a}||\\vec{b}|)^2 - (|\\vec{a}||\\vec{b}|\\cos\\theta)^2$ $ = (|\\vec{a}||\\vec{b}|)^2 (1 - \\cos^2\\theta)$ $ = (|\\vec{a}||\\vec{b}|)^2 \\sin^2\\theta$ $|\\vec{a} \\times \\vec{b}| = |\\vec{a}||\\vec{b}| |\\sin\\theta|$ 이처럼 벡터 외적의 크기는 $\\sin$함수에 비례하는 것을 알 수 있다. 또한 이것은 두 벡터가 만드는 평행사변형의 넓이와 같다. 내적 외적 판별성($0$이 된다) 직교성 평행성 삼각함수 $\\cos\\theta$ $\\sin\\theta$ 법선 벡터 벡터의 외적은 두 벡터에 직교하는 벡터를 생성한다. 두 벡터의 외적에다가 한 가지 벡터를 내적하면 어떻게 될까? $\\vec{a} \\cdot (\\vec{a} \\times \\vec{b}) = a_xa_yb_z - a_xa_zb_y + a_ya_zb_x - a_ya_xb_z + a_za_xb_y - a_za_yb_x = 0$ $\\vec{b} \\cdot (\\vec{a} \\times \\vec{b}) = b_xa_yb_z - b_xa_zb_y + b_ya_zb_x - b_ya_xb_z + b_za_xb_y - b_za_yb_x = 0$ 그 결과는 늘 $0$이 되며 이것은 외적 결과값이 두 벡터에 직교한다는 의미가 된다. Chapter 3에서 말했듯이, 선형 독립 관계를 가지는 두 벡터의 선형 결합은 평면을 만든다. 그렇다면 벡터의 외적은 그 평면이 향하는 방향(직교)에 대한 벡터를 만드는 것이다. 이 벡터를 법선 벡터(Normal vector) 또는 노멀 벡터라고 한다. 외적은 교환법칙이 성립하지 않는다. 따라서 연산의 순서를 바꾸면 반대방향의 법선 벡터가 생성된다. 오른손 좌표계를 사용한다면, 오른손 법칙을. 왼손 좌표계를 사용한다면, 왼손 법칙을 사용해서 법선 벡터의 방향을 파악할 수 있다. 좌우 방향 판별 월드 공간의 $y$축 $\\vec{y} = (0, 1, 0)$에 직교하는 평면에 캐릭터와 몬스터가 놓여 있다. 이 때, 캐릭터의 정면을 향하는 시선 벡터 $\\vec{f}$와 캐릭터에서 몬스터로 향하는 벡터 $\\vec{v}$를 외적하면? 결과 벡터는 오른손 법칙의 경우 평면의 위쪽으로 향할 것이다.\n외적의 결과에 평면의 위쪽 방향을 나타내는 벡터 $\\vec{y}$를 내적하면, 두 벡터의 방향이 같으면 양수가 나오고, 반대 방향이라면 음수가 나온다. 몬스터의 위치 판별식의 값 왼쪽에 있다 $(\\vec{f} \\times \\vec{v}) \\cdot \\vec{y} \u0026gt; 0$ 오른쪽에 있다 $(\\vec{f} \\times \\vec{v}) \\cdot \\vec{y} \u0026lt; 0$ 정확히 시선 방향과 일치한다 $(\\vec{f} \\times \\vec{v}) = 0$ 이러한 성질은 외적이 $\\sin$함수에 비례하는 성질을 가졌기 때문이다. 반면, 내적은 $\\cos$함수에 비례하기 때문에 앞뒤 판별에 사용된다. 내적 외적 방향 판별 앞뒤 좌우 벡터로부터 회전행렬 생성 Chapter 10에서는 오일러 각 방식을 사용해서 카메라의 회전을 지정하였다. 외적을 사용하면 카메라의 시선 벡터 하나를 가지고 카메라를 구성하는 세 가지 로컬 축을 구할 수가 있다. 로컬 $z$축 물체의 위치에서 카메라의 위치를 뺀 후 크기를 $1$로 정규화 시킨 시선 벡터이다. 로컬 $x$축 월드 공간의 $y$축(업벡터라고 한다; Up vector)과 카메라의 로컬 $x$축을 외적한 후 정규화하면 얻을 수 있다. 로컬 $y$축 로컬 $z$축과 로컬 $x$축을 외적하면 얻을 수 있다. 따라서 시선 벡터 $\\vec{v}$와 업 벡터 $\\vec{u}$로부터 다음과 같이 구할 수 있다. $\\vec{x} = \\frac{\\vec{v} \\times \\vec{u}}{|\\vec{v} \\times \\vec{u}|}$ $\\vec{y} = \\vec{x} \\times \\vec{z}$ $\\vec{z} = \\frac{\\vec{v}}{|\\vec{v}|}$ 그렇다면 카메라 트랜스폼의 회전 행렬 $R$은 로컬 벡터를 열벡터로 지정해서 다음과 같이 생성할 수 있다. $$R = \\begin{bmatrix} x_x \u0026amp; y_x \u0026amp; z_x \u0026amp; 0 \\\\ x_y \u0026amp; y_y \u0026amp; z_y \u0026amp; 0 \\\\ x_z \u0026amp; y_z \u0026amp; z_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 예외 상황 (1) 카메라의 위쪽방향이 월드 공간의 $y$축과 반대인 경우(뒤집힌 경우) 월드 공간 $y$축과 반대인 $(0, -1, 0)$을 사용해야 한다. (2) 카메라의 시선방향이 월드 공간의 $y$축과 평행한 경우 로컬 $z$축에 직교하는 로컬 $x$축의 값을 수동으로 지정해야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 목표물의 위치로부터 카메라의 세 로컬 축을 구해서 트랜스폼에 반영한다. // InUp은 카메라가 뒤집힌 경우에는 반대 방향의 월드 Y축이 전달되겠다. (1) void CameraObject::SetLookAtRotation(const Vector3\u0026amp; InTargetPosition, const Vector3\u0026amp; InUp) { Vector3 localX, localY, localZ; localZ = (InTargetPosition - _Transform.GetPosition()).Normalize(); // 시선 방향과 월드 Y축(0, 1, 0)이 평행한 경우 (2) // 단위 벡터 Z축의 y값이 1과 가까우면... if (Math::Abs(localZ.Y) \u0026gt;= (1.f - SMALL_NUMBER)) { localX = Vector3::UnitX; // 로컬 X 좌표 값을 임의로 지정. } else { localX = InUp.Cross(localZ).Normalize(); } localY = localX.Cross(localX); // 최종 계산된 세 로컬 축을 카메라의 트랜스폼에 반영한다. _Transform.SetLocalAxes(localX, localY. localZ); } 렌더링 계산량을 줄여주는 백페이스 컬링 백페이스 컬링(Backface culling) 카메라와 마주보지 않는 메시의 뒷면은 그리지 않고 건너뛰는 것이다. 덕분에 빠르게 렌더링할 수 있겠다. 삼각형의 세 점을 지정하는 인덱스 버퍼에는 점의 순서가 나열되어있다. 외적을 사용해서 삼각형이 향하는 방향을 파악할 수 있다. 이러한 삼각형의 방향과 카메라의 시선 방향을 내적해서 그 결과 값이 음수라면, 방향이 마주보고 있다는 것이므로 그린다. 나머지 경우에는 두 방향이 같은 방향을 바라보는 것이므로 그리지 않는다. 백페이스 컬링 구현 코드 삼각형의 면이 향하는 법선 벡터 $\\vec{n} = \\vec{P_0P_1} \\times \\vec{P_0P_2}$ 뷰 공간에서 카메라가 바라보는 시선이 $-z$축이므로 $(0, 0, -1)$과 내적을 한다. $(n_x, n_y, n_z) \\cdot (0, 0, -1) \u0026lt; 0$ 일 때만 그린다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void SoftRenderer::DrawTriangle3D(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { auto\u0026amp; r = GetRenderer(); const GameEngine\u0026amp; g = Get3DGameEngine(); if (useBackfaceCulling) { // 백페이스 컬링 ( 뒷면이면 그리기 생략 ) Vector3 edge1 = (InVertices[1].Position - InVertices[0].Position).ToVector3(); Vector3 edge2 = (InVertices[2].Position - InVertices[0].Position).ToVector3(); Vector3 faceNormal = edge1.Cross(edge2); Vector3 viewDirection = -Vector3::UnitZ; if (faceNormal.Dot(viewDirection) \u0026gt;= 0.f) { return; } } LinearColor finalColor = _WireframeColor; if (InColor != LinearColor::Error) { finalColor = InColor; } r.DrawLine(InVertices[0].Position, InVertices[1].Position, finalColor); r.DrawLine(InVertices[0].Position, InVertices[2].Position, finalColor); r.DrawLine(InVertices[1].Position, InVertices[2].Position, finalColor); } 오일러 각의 문제를 해결하는 로드리게스 회전 공식 Chapter 10에서 본 것처럼, 오일러 각은 짐벌락 현상이 발생하고 회전 보간이 어렵다는 문제가 있었다. 축-각 회전(Axis-Angle rotation)을 사용해서 해결할 수 있다. 임의의 축에 직교하는 평면에서 회전을 하는 방법이다. 아래 그림과 같을 때 $\\vec{u\u0026rsquo;}$를 구해보자. 먼저 점 $P$의 좌표가 $P = (x, y, z, 1)$이라면 $\\vec{u} = P - O$이므로 $\\vec{u} = (x, y, z, 0)$라고 할 수 있겠다. $\\vec{OO\u0026rsquo;}$의 경우에는 Chapter 7에서 본 투영 공식에 의해서 구할 수 있다. $\\vec{v} = (\\vec{u} \\cdot \\hat{n}) \\cdot \\hat{n}$ 이것을 간단히 $\\vec{v}$라고 부르자. 그렇다면 $\\vec{O\u0026rsquo;P}$의 경우에는 $\\vec{u} - \\vec{v}$로 구할 수 있다. 이번에는 회전 평면을 위에서 내려다 보자. 벡터 $\\vec{O\u0026rsquo;P\u0026rsquo;}$의 가로 성분 $\\cos\\theta \\cdot (\\vec{u} - \\vec{v})$ 벡터 $\\vec{O\u0026rsquo;P\u0026rsquo;}$의 세로 성분 세로 성분과 같은 방향을 향하는 벡터를 $\\vec{O\u0026rsquo;Q}$라고 하자. 이것은 법선 벡터 $\\hat{n}$와 벡터 $\\vec{OP\u0026rsquo;}$를 외적해서 얻을 수 있다. $\\vec{O\u0026rsquo;Q} = \\hat{n} \\times (\\vec{u} - \\vec{v})$ 여기에 $\\sin\\theta$를 곱하면 세로 성분에 대한 벡터를 얻을 수 있다. $\\sin\\theta \\cdot (\\hat{n} \\times (\\vec{u} - \\vec{v}))$ 따라서 다음과 같이 벡터 $\\vec{O\u0026rsquo;P\u0026rsquo;}$를 계산할 수 있겠다. $\\vec{O\u0026rsquo;P\u0026rsquo;} = \\cos\\theta \\cdot (\\vec{u} - \\vec{v}) + \\sin\\theta \\cdot (\\hat{n} \\times (\\vec{u} - \\vec{v}))$ $ = \\cos\\theta \\cdot (\\vec{u} - \\vec{v}) + \\sin\\theta \\cdot (\\hat{n} \\times \\vec{u} - \\hat{n} \\times \\vec{v})$ $\\hat{n}$과 $\\vec{v}$는 평행하므로 $\\hat{n} \\times \\vec{v}$는 $0$이므로 다음과 같이 정리된다. $\\vec{O\u0026rsquo;P\u0026rsquo;} = \\cos\\theta \\cdot (\\vec{u} - \\vec{v}) + \\sin\\theta \\cdot (\\hat{n} \\times \\vec{u})$ 이제 우리의 목표인 $\\vec{u\u0026rsquo;}$를 구해보자. 이것은 $\\vec{O\u0026rsquo;P\u0026rsquo;}$에다가 $\\vec{v}$를 더해서 얻을 수 있다. $\\vec{u\u0026rsquo;} = \\vec{v} + \\cos\\theta \\cdot (\\vec{u} - \\vec{v}) + \\sin\\theta \\cdot (\\hat{n} \\times \\vec{u})$ 이제 $\\vec{v}$를 $(\\vec{u} \\cdot \\hat{n}) \\cdot \\hat{n}$로 치환하면 최종 수식이 유도된다. $\\vec{u\u0026rsquo;} = \\cos\\theta \\cdot \\vec{u} + (1- \\cos\\theta)(\\vec{u} \\cdot \\hat{n})\\cdot \\hat{n} + \\sin\\theta \\cdot (\\hat{n} \\times \\vec{u})$ 이 공식은 프랑스 수학자 로드리게스가 1840년에 발표했으며, 그의 이름을 인용해서 로드리게스 회전 공식(Rodrigues\u0026rsquo; rotation formula)이라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 메시를 그리는 함수 void SoftRenderer::DrawMesh3D(const Mesh\u0026amp; InMesh, const Matrix4x4\u0026amp; InMatrix, const Vector3\u0026amp; InScale, const LinearColor\u0026amp; InColor) { size_t vertexCount = InMesh.GetVertices().size(); size_t indexCount = InMesh.GetIndices().size(); size_t triangleCount = indexCount / 3; // 렌더러가 사용할 정점 버퍼와 인덱스 버퍼로 변환 std::vector\u0026lt;Vertex3D\u0026gt; vertices(vertexCount); std::vector\u0026lt;size_t\u0026gt; indice(InMesh.GetIndices()); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = Vector4(InMesh.GetVertices()[vi]); if (InMesh.HasColor()) { vertices[vi].Color = InMesh.GetColors()[vi]; } if (InMesh.HasUV()) { vertices[vi].UV = InMesh.GetUVs()[vi]; } } // 정점 변환 진행 for (Vertex3D\u0026amp; v : vertices) { float sin = 0.f, cos = 0.f; Math::GetSinCos(sin, cos, thetaDegree); Vector3 u = v.Position.ToVector3(); // 원점에서 정점으로 향하는 벡터 u. 계산의 편의를 위해 4차원 벡터의 마지막 요소는 생략했다. float udotn = u.Dot(n); Vector3 ncrossu = n.Cross(u); // 스케일을 적용한 후 로드리게스 공식으로 회전을 적용한다. Vector3 result = Vector3(u * cos + n * (1.f - cos) * udotn + ncrossu * sin) * InScale; // 그다음 뷰 행렬(InMatrix로 전달됨)을 적용한다. v.Position = InMatrix * Vector4(result); } // 삼각형 별로 그리기 for (int ti = 0; ti \u0026lt; triangleCount; ++ti) { int bi0 = ti * 3, bi1 = ti * 3 + 1, bi2 = ti * 3 + 2; std::vector\u0026lt;Vertex3D\u0026gt; tvs = { vertices[indice[bi0]] , vertices[indice[bi1]] , vertices[indice[bi2]] }; size_t triangles = tvs.size() / 3; for (size_t ti = 0; ti \u0026lt; triangles; ++ti) { size_t si = ti * 3; std::vector\u0026lt;Vertex3D\u0026gt; sub(tvs.begin() + si, tvs.begin() + si + 3); DrawTriangle3D(sub, InColor, FillMode::Color); } } } 로드리게스 회전 공식을 활용하면 오일러 각으로 구현하기 어려운 임의의 축에 대한 회전 변환을 수행할 수 있다. 하지만, 행렬로의 변환이 어려워서 지금까지 구축했던 렌더링 파이프라인에 연동하기가 까다롭다. 그래서 게임 엔진에서는 동일한 기능을 제공하지만 간결하고, 행렬로 변환이 용이한 사원수(Chapter 16)를 사용한다. 삼중곱 삼중곱(Triple product) 연산 벡터의 외적과 내적을 두 번 연속 사용 하는 연산이다. 다음과 같은 경우의 수가 있다. (1) $\\vec{u} \\cdot (\\vec{v} \\cdot \\vec{w})$ → 결과 값이 스칼라이므로 제외한다. (2) $\\vec{u} \\cdot (\\vec{v} \\times \\vec{w})$ (3) $\\vec{u} \\times (\\vec{v} \\cdot \\vec{w})$ → 벡터와 스칼라는 외적할 수 없으므로 연산이 불가능해서 제외한다. (4) $\\vec{u} \\times (\\vec{v} \\times \\vec{w})$ 스칼라 삼중곱 스칼라 삼중곱(Scalar triple product) (2) $\\vec{u} \\cdot (\\vec{v} \\times \\vec{w})$ 왼쪽과 오른쪽 판별 방법과, 벡페이스 컬링에 사용했던 공식이 바로 스칼라 삼중곱이었다. $(\\vec{f} \\times \\vec{v}) \\cdot \\vec{y}$ $-\\hat{z} \\cdot (\\vec{P_0P_1} \\times \\vec{P_0P_2})$ 스칼라 삼중곱의 절댓값은 세 벡터가 만드는 평행육면체(Parallelepiped)의 부피를 의미한다. 임의의 벡터 $\\vec{u}$를 법선 벡터 $\\vec{v} \\times \\vec{w}$에 투영한 벡터의 높이는 $|\\vec{u}|\\cos\\theta$이다. 여기에 평행사변형의 넓이 $|\\vec{v} \\times \\vec{w}|$를 곱하면 육면체의 부피가 나온다. $|\\vec{u}||\\vec{v} \\times \\vec{w}|\\cos\\theta$ 이것은 스칼라 삼중곱이 만들어내는 값의 절댓값과 동일하다. $|\\vec{u} \\cdot (\\vec{v} \\times \\vec{w})| = |\\vec{u}||\\vec{v} \\times \\vec{w}|\\cos\\theta$ 이 세 백터에서 바닥에 해당하는 두 벡터를 다른 벡터로 변경해도 최종 육면체의 부피 값은 변하지 않아서 삼중곱의 결과는 동일하다. 따라서 다음과 같은 성질을 도출할 수 있다. $\\vec{u} \\cdot (\\vec{v} \\times \\vec{w}) = \\vec{v} \\cdot (\\vec{w} \\times \\vec{u}) = \\vec{w} \\cdot (\\vec{u} \\times \\vec{v})$ 스칼라 삼중곱이 $0$이 아니면 세 백터는 모두 선형 독립의 관계를 가진다. Chapter 5에서 보았던 행렬식의 절댓값은 평행사변형의 넓이였다. 이것은 평면에서 평행사변형을 이루는 두 벡터가 서로 선형 독립의 관계를 가지는지 판단하는 수식이었다. 외적으로 생성된 벡터의 크기는 평행사변형의 넓이와 같다. 따라서 스칼라 삼중곱은 3차원 공간의 세 벡터가 모두 선형 독립의 관계를 가지는지 판단하는 판별식으로 생각할 수 있다. 스칼라 삼중곱이 $0$이 나오는 경우 (1) 외적의 결과가 영벡터이므로 스칼라 삼중곱이 $0$이 된다. (2) 외적의 결과로 만들어진 법선 벡터에 벡터 $\\vec{u}$가 직교하므로 이의 내적은 $0$이 된다. 따라서 스칼라 삼중곱은 $0$이 된다. 벡터 삼중곱 벡터 삼중곱(Vector triple product) (4) $\\vec{u} \\times (\\vec{v} \\times \\vec{w})$ 삼중곱 전개(Triple product expansion) 또는 라그랑주 공식(Lagrange\u0026rsquo;s formula) 벡터 삼중곱은 다음과 같은 성질을 지닌다. $(\\vec{u} \\cdot \\vec{w}) \\cdot \\vec{v} - (\\vec{u} \\cdot \\vec{v}) \\cdot \\vec{w}$ 이것을 직접 확인해보자. (풀이 간단 설명) $(\\vec{u} \\times (\\vec{v} \\times \\vec{w}))_x = v_x(\\vec{u} \\cdot \\vec{w}) - w_x(\\vec{u} \\cdot \\vec{v})$ $(\\vec{u} \\times (\\vec{v} \\times \\vec{w}))_y = v_y(\\vec{u} \\cdot \\vec{w}) - w_y(\\vec{u} \\cdot \\vec{v})$ $(\\vec{u} \\times (\\vec{v} \\times \\vec{w}))_z = v_z(\\vec{u} \\cdot \\vec{w}) - w_z(\\vec{u} \\cdot \\vec{v})$ 이것은 $a\\vec{v} + b\\vec{w}$형태의 선형 결합식이므로, 벡터 삼중곱으로 만들어지는 벡터는 두 벡터$\\vec{v}$, $\\vec{w}$가 만드는 평면에 속한다. 이것은 2차원에서 동일 평면에 있는 직교 벡터를 구하는 데도 유용하게 쓸 수 있다. $(\\vec{u} \\times \\vec{v}) \\times \\vec{u}$ ","date":"2022-04-13T18:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-11/","title":"[Game Math] Chapter 11. 외적: 3차원 공간의 분석과 응용"},{"content":" 3차원 공간의 설계 $x$축에서 $y$축 방향으로 손을 감았을 때, $z$축이 어느쪽 손의 엄지 손가락의 방향과 일치하는가에 따라 나뉜다.\n오른손 좌표계(Right-handed coordinate system) 왼손 좌표계(Left-handed coordinate system) 프로그램 마다 각 축의 용도를 다르게 설정한다.\n아래 그림에서 (a)3DS맥스는 $z$업 오른손 좌표계이고, (b)유니티는 $y$업, (c)언리얼은 $z$업 왼손 좌표계이다. (저자가 제시한) 우리의 좌표계는 유니티 좌표계에서 $z$축의 방향이 반대인 형상이다. ($y$업 오른손 좌표계)\n3차원 공간의 트랜스폼 3차원 공간 역시 이동 변환을 위해서 한 차원 더 늘어난 4차원 공간을 사용한다.\n$$S = \\begin{bmatrix} s_x \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; s_y \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; s_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_x \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 3차원 공간의 회전 변환은?\n세 가지 표준기저벡터가 동일한 크기와 직교성을 유지한 상태로 함께 움직여야한다. 회전변환으로 달라진 세 표준기저벡터값을 열벡터로 꽂아 널어 회전변환행렬 $R$을 만들 수 있을 것이다. 오일러 각 오일러 각(Euler\u0026rsquo;s angle) 3차원 공간에서 물체가 놓인 방향을 3개의 각을 사용해서 표시하는 방법이다. 오일러 각은 표준기저벡터를 중심으로해서 회전한 각의 크기로 나타낸다. $(\\theta_x, \\theta_y, \\theta_z)$ 하지만 소프트웨어마다 $x$, $y$, $z$축의 용도가 다르다는 문제가 있다. 예를 들면 언리얼에서 사용하는 $x$축 회전은 유니티의 $x$축 회전과 다르게 동작하므로, 언리얼 엔진에서의 오일러 각 정보를 그대로 유니티 엔진으로 넘겨서 사용할 수 없다. 이런 문제를 해결하기 위해 회전의 움직임으로 회전 동작을 구분하는 방법을 사용한다. 요, 롤, 피치의 움직임으로 오일러 각을 지정하면, 서로 다른 좌표계를 사용하는 프로그램 간에도 데이터를 쉽게 변환할 수 있다. 회전 방향 유니티 언리얼 요(Yaw) 위 $y$ $z$ 롤(Roll) 앞 $z$ $x$ 피치(Pitch) 오른쪽 $x$ $y$ 오일러 각에서 회전은 표준기저벡터를 중심으로 진행되는 세 번의 연속적인 회전을 의미한다. 따라서 다음과 같이 각 기저축의 회전행렬을 구할 수 있겠다. 3차원 공간에서는 $x$→$y$→$z$→$x$→$y$의 순서로 세 축이 순환된다. $x$축 회전은 $yz$평면의 회전을 의미한다. $$R_x = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; \\cos\\theta \u0026amp; -\\sin\\theta \\\\ 0 \u0026amp; \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix}$$ $y$축 회전은 $zx$평면의 회전을 의미한다. (위의 순서에 따르므로 $xz$가 아니다) $$R_x = \\begin{bmatrix} \\cos\\theta \u0026amp; 0 \u0026amp; \\sin\\theta \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ -\\sin\\theta \u0026amp; 0 \u0026amp; \\cos\\theta \\end{bmatrix}$$ $z$축 회전은 $xy$평면의 회전을 의미한다. $$R_x = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \u0026amp; 0 \\\\ \\sin\\theta \u0026amp; \\cos\\theta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 회전행렬의 유도 각 기저축의 회전행렬을 순서대로 적용해서 최종 회전행렬을 만들어야 한다. 어떤 순서로 적용할 것인가에 대한 경우의 수는 다양하다. 그 중에서 언리얼 엔진은 $Roll$→$Pitch$→$Yaw$의 순서를 채택한다. 이 순서로 회전행렬 $R$을 구하면 다음과 같다. $ R = R_{yaw} \\cdot R_{pitch} \\cdot R_{roll} $ (저자가 제시한) 우리의 좌표계는 $Roll$→$Pitch$→$Yaw$가 $z$→$x$→$y$에 대응되므로 요, 피치, 롤 각의 값을 $\\alpha$, $\\beta$, $\\gamma$라고 한다면 행렬 곱은 다음과 같이 계산할 수 있다. $$R_{\\alpha} \\cdot R_{\\beta} \\cdot R_{\\gamma} = \\begin{bmatrix} \\cos\\alpha \u0026amp; 0 \u0026amp; \\sin\\alpha \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ -\\sin\\alpha \u0026amp; 0 \u0026amp; \\cos\\alpha \\end{bmatrix} \\begin{bmatrix} \\cos\\beta \u0026amp; 0 \u0026amp; \\sin\\beta \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ -\\sin\\beta \u0026amp; 0 \u0026amp; \\cos\\beta \\end{bmatrix} \\begin{bmatrix} \\cos\\gamma \u0026amp; -\\sin\\gamma \u0026amp; 0 \\\\ \\sin\\gamma \u0026amp; \\cos\\gamma \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$= \\begin{bmatrix} \\cos\\alpha\\cos\\gamma + \\sin\\alpha\\sin\\beta\\sin\\gamma \u0026amp; -\\cos\\alpha\\sin\\gamma + \\sin\\alpha\\sin\\beta\\cos\\gamma \u0026amp; \\sin\\alpha\\cos\\beta \\\\ \\cos\\beta\\sin\\gamma \u0026amp; \\cos\\beta\\cos\\gamma \u0026amp; -\\sin\\beta \\\\ -\\sin\\alpha\\cos\\gamma + \\cos\\alpha\\sin\\beta\\sin\\gamma \u0026amp; \\sin\\alpha\\sin\\gamma + \\cos\\alpha\\sin\\beta\\cos\\gamma \u0026amp; \\cos\\alpha\\cos\\beta \\end{bmatrix}$$ 이렇게 계산한 회전행렬의 열벡터는 표준기저벡터가 회전 변환된 로컬 축을 의미한다. 따라서 다음과 같이 나타낼 수 있겠다. $x_{local} = ( \\cos\\alpha\\cos\\gamma + \\sin\\alpha\\sin\\beta\\sin\\gamma, \\cos\\beta\\sin\\gamma, -\\sin\\alpha\\cos\\gamma + \\cos\\alpha\\sin\\beta\\sin\\gamma )$ $y_{local} = ( -\\cos\\alpha\\sin\\gamma + \\sin\\alpha\\sin\\beta\\cos\\gamma, \\cos\\beta\\cos\\gamma, \\sin\\alpha\\sin\\gamma + \\cos\\alpha\\sin\\beta\\cos\\gamma )$ $z_{local} = ( \\sin\\alpha\\cos\\beta, -\\sin\\beta, \\cos\\alpha\\cos\\beta )$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 struct Rotator { public: // 0~360 범위로 각도 값을 바꿔준다. FORCEINLINE void Clamp() { Yaw = GetAxisClampedValue(Yaw); Roll = GetAxisClampedValue(Roll); Pitch = GetAxisClampedValue(Pitch); } FORCEINLINE float GetAxisClampedValue(float InRotatorValue) { float angle = Math::FMod(InRotatorValue, 360.f); if (angle \u0026lt; 0.f) { angle += 360.f; } return angle; } // 오일러각으로 회전된 3차원 공간의 로컬 축을 계산해서 반환한다. FORCEINLINE void GetLocalAxes(Vector3\u0026amp; OutRight, Vector3\u0026amp; OutUp, Vector3\u0026amp; OutForward) { float cy = 0.f, sy = 0.f, cp = 0.f, sp = 0.f, cr = 0.f, sr = 0.f; Math::GetSinCos(sy, cy, Yaw); Math::GetSinCos(sp, cp, Pitch); Math::GetSinCos(sr, cr, Roll); OutRight = Vector3(cy * cr + sy * sp * sr, cp * sr, -sy * cr + cy * sp * sr); OutUp = Vector3(-cy * sr + sy * sp * cr, cp * cr, sy * sr + cy * sp * cr); OutForward = Vector3(sy * cp, -sp, cy * cp); } public: // 오일러 각을 구성하는 요, 롤, 피치는 각도법을 사용해서 관리한다. float Yaw = 0.f; float Roll = 0.f; float Pitch = 0.f; } 3차원 공간의 트랜스폼도 회전 변환이 발생할 때마다 로컬 축 데이터를 갱신한다면, 로컬 축 벡터가 $\\vec{x} = (x_x, x_y, x_z), \\vec{y} = (y_x, y_y, y_z), \\vec{z} = (z_x, z_y, z_z)$일 때 이들을 열벡터로 꽂아넣어 회전행렬을 구할 수 있다. $$R = \\begin{bmatrix} x_x \u0026amp; y_x \u0026amp; z_x \u0026amp; 0 \\\\ x_y \u0026amp; y_y \u0026amp; z_y \u0026amp; 0 \\\\ x_z \u0026amp; y_z \u0026amp; z_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class TransformComponent { public: // 오일러 각의 정보가 변경되면 항상 Update함수를 호출해서 로컬 축을 갱신한다. void AddYawRotation(float InDegree) { _Rotation.Yaw += InDegree; Update(); } void AddRollRotation(float InDegree) { _Rotation.Roll += InDegree; Update(); } void AddPitchRotation(float InDegree) { _Rotation.Pitch += InDegree; Update(); } void SetRotation(const Rotator \u0026amp; InRotation) { _Rotation = InRotation; Update(); } const Vector3\u0026amp; GetLocalX() const { return _Right; } const Vector3\u0026amp; GetLocalY() const { return _Up; } const Vector3\u0026amp; GetLocalZ() const { return _Forward; } // 로컬 축 값을 직접 설정한다. void SetLocalAxes(const Vector3 \u0026amp; InRight, const Vector3 \u0026amp; InUp, const Vector3 \u0026amp; InForward) { _Right = InRight; _Up = InUp; _Forward = InForward; } private: FORCEINLINE void Update(); Vector3 _Position = Vector3::Zero; Rotator _Rotation; // 트랜스폼의 회전을 관리하기 위해 오일러 각 방식의 Rotator 구조체를 사용한다. Vector3 _Scale = Vector3::One; Vector3 _Right = Vector3::UnitX; Vector3 _Up = Vector3::UnitY; Vector3 _Forward = Vector3::UnitZ; }; FORCEINLINE void TransformComponent::Update() { _Rotation.Clamp(); // 오일러 각의 범위를 0~360 범위로 바꿔준다. _Rotation.GetLocalAxes(_Right, _Up, _Forward); // 오일러 각으로부터 세 로컬 축 값을 가져와서 로컬 축에 저장한다. } 3차원 모델링 행렬 크기, 회전, 이동 변환행렬 $$S = \\begin{bmatrix} s_x \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; s_y \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; s_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$R = \\begin{bmatrix} x_x \u0026amp; y_x \u0026amp; z_x \u0026amp; 0 \\\\ x_y \u0026amp; y_y \u0026amp; z_y \u0026amp; 0 \\\\ x_z \u0026amp; y_z \u0026amp; z_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_x \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 모델링 행렬 $$M = T \\cdot R \\cdot S = \\begin{bmatrix} x_xs_x \u0026amp; y_xs_y \u0026amp; z_xs_z \u0026amp; t_x \\\\ x_ys_x \u0026amp; y_ys_y \u0026amp; z_ys_z \u0026amp; t_y \\\\ x_zs_x \u0026amp; y_zs_y \u0026amp; z_zs_z \u0026amp; t_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 1 2 3 4 5 6 7 8 9 10 // 3차원 모델링 행렬을 생성한다. FORCEINLINE Matrix4x4 TransformComponent::GetModelingMatrix() const { return Matrix4x4( Vector4(_Right * _Scale.X, false), // 두번째 인자값이 false이면 점이고, 네번째 원소값이 0이 된다. Vector4(_Up * _Scale.Y, false), Vector4(_Forward * _Scale.Z, false), Vector4(_Position, true) // 두번째 인자값이 true이면 벡터이고, 네번째 원소값이 1이 된다. ); } 카메라 공간 2차원 카메라를 구현할 때에는 이동 기능만 부여 했지만, 3차원 공간의 카메라에는 이동과 회전 기능을 함께 부여할 것이다. 카메라의 경우 크기의 개념이 없기 때문에 제외한다. 카메라 트랜스폼에 저장된 위치값을 $t = (t_x, t_y, t_z)$로 지정하고, 로컬 축 값을 각각 $\\vec{x} = (x_x, x_y, x_z), \\vec{y} = (y_x, y_y, y_z), \\vec{z} = (z_x, z_y, z_z)$로 지정한다면 이동 행렬과 회전 행렬은 다음과 같다. $$T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_x \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$R = \\begin{bmatrix} x_x \u0026amp; y_x \u0026amp; z_x \u0026amp; 0 \\\\ x_y \u0026amp; y_y \u0026amp; z_y \u0026amp; 0 \\\\ x_z \u0026amp; y_z \u0026amp; z_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ Chapter 9에서 보았듯이 상대 좌표는 역행렬로 구할 수 있다. 이동 행렬의 역행렬은 덧셈의 역원인 반대수로 구한다. 회전 행렬의 역행렬은 전치행렬로 구한다. $$T^{-1} = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; -t_x \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; -t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; -t_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$R^{-1} = \\begin{bmatrix} x_x \u0026amp; x_y \u0026amp; x_z \u0026amp; 0 \\\\ y_x \u0026amp; y_y \u0026amp; y_z \u0026amp; 0 \\\\ z_x \u0026amp; z_y \u0026amp; z_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 순서는? 모든 물체의 좌표를 카메라를 중심으로 옮긴 후, 회전을 해야하므로 이동의 역행렬 → 회전의 역행렬 순이다. 이것은 트랜스폼의 순서를 바꾸는 것이며, 즉 크기 변환 $S$를 제외한 모델링 행렬의 역행렬이 뷰 행렬이 된다. $M^{-1} = (T \\cdot R)^{-1} = R^{-1} \\cdot T^{-1}$ 따라서 뷰 행렬은 다음과 같으며, 마지막 4열은 내적을 사용해서 간단하게 정리할 수 있다. $$R^{-1} \\cdot T^{-1} = \\begin{bmatrix} x_x \u0026amp; x_y \u0026amp; x_z \u0026amp; -x \\cdot t \\\\ y_x \u0026amp; y_y \u0026amp; y_z \u0026amp; -y \\cdot t \\\\ z_x \u0026amp; z_y \u0026amp; z_z \u0026amp; -z \\cdot t \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ (저자가 제시한) 우리의 좌표계의 경우 카메라가 양의 $z$축을 바라보면 카메라가 만드는 화면 좌표계에서는 $x$축이 왼쪽을 향해서 2차원 데카르트 좌표계와 다르게 된다. 따라서 $x$축이 오른쪽을 향하도록 $y$축을 기준으로 $180^{\\circ}$회전 시켜서 뷰 공간을 구성한다. 이것을 위해 $x$축 기저와 $z$축 기저를 반전시킨다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 카메라 트랜스폼으로부터 x, y, z 로컬 축 값을 얻는다. FORCEINLINE void CameraObject::GetViewAxes(Vector3\u0026amp; OutViewX, Vector3\u0026amp; OutViewY, Vector3\u0026amp; OutViewZ) const { // (x축과 z축을 반전시킨다) OutViewZ = -_Transform.GetLocalZ(); OutViewY = _Transform.GetLocalY(); OutViewX = -_Transform.GetLocalX(); } // 뷰 행렬을 얻는다. FORCEINLINE Matrix4x4 CameraObject::GetViewMatrix() const { Vector3 viewX, viewY, viewZ; GetViewAxes(viewX, viewY, viewZ); Vector3 pos = _Transform.GetPosition(); return Matrix4x4( Vector4(Vector3(viewX.X, viewY.X, viewZ.X), false), Vector4(Vector3(viewX.Y, viewY.Y, viewZ.Y), false), Vector4(Vector3(viewX.Z, viewY.Z, viewZ.Z), false), Vector4(-viewX.Dot(pos), -viewY.Dot(pos), -viewZ.Dot(pos), 1.f) ); } 오일러 각의 특징 오일러 각의 장점\n오일러 각은 표준기저벡터를 회전축으로 삼아서 회전한 각의 크기를 설정하기 때문에 인터페이스가 직관적이다. 따라서 사용자 입장에서 물체의 회전을 설정하기에 용이하다. 행렬을 사용해서 3차원 공간의 회전을 표현하려면 최소 9개의 실수 데이터가 필요하지만, 오일러 각은 3개의 데이터만 있으면 된다. 따라서 적은 용량으로 게임 데이터를 관리할 수 있게 도와준다. 오일러 각의 단점\n짐벌락 현상이 발생한다. 짐벌락 현상 짐벌락(Gimbal lock) 현상\n오브젝트의 두 회전 축이 겹쳐서 자유도를 잃는 것을 말한다. 짐벌락 참고 영상 해결 방법\n로드리게스 회전 공식(Chapter 11) 사원수(Chapter 16) 회전 보간의 계산 회전 보간(Rotational interpolation) 카메라의 움직임이나 캐릭터의 애니메이션을 구현할 때는 3차원 공간에서 시작 회전과 끝 회전을 지정하고 시간에 따라 두 회전 사이를 부드럽게 전환하는 기능이 필요할 수 있다. 이를 위해서 중간 회전 값을 계산하는 것을 회전 보간이라고 한다. 선형 보간식을 사용해서 중간 회전 값을 얻을 수 있다. $ \\theta\u0026rsquo; = (1-t)\\theta_{start} + t\\theta_{end} $ 예를 들어, 동일한 평면 상에서 $15^{\\circ}$에서 시작해서 $165^{\\circ}$로 끝나는 회전의 $\\frac{1}{3}$비율에 해당하는 회전 보간 값은 다음과 같이 구해서 $65^{\\circ}$가 되겠다. $\\frac{2}{3} \\cdot 15^{\\circ} + \\frac{1}{3} \\cdot 165^{\\circ} = 65^{\\circ}$ 선형 보간식이 성립하려면 두 각의 회전 변환을 곱합 결과가 두 각의 합의 회전 변환과 동일해야한다. $R_{\\beta} \\cdot R_{\\alpha} = R_{(\\alpha + \\beta)}$ Chapter 5에서 보았듯이 2차원 공간의 회전에서는 위 식이 만족하므로, 선형 보간식을 사용하는 데 문제가 없었다. 그렇다면 3차원 공간의 오일러 각 회전에서도 문제가 없을까? 한 축으로만 회전하는 경우 맨 처음에 보았던 회전 행렬을 구하는 식: $ R = R_{yaw} \\cdot R_{pitch} \\cdot R_{roll} $ 만약 $y$축으로 $\\alpha$와 $\\beta$만큼 회전한다면\u0026hellip; $R_{(\\alpha + \\beta)} = R_{yaw(\\alpha + \\beta)} \\cdot I \\cdot I = R_{yaw(\\alpha + \\beta)}$ $yaw$회전만 수행하므로 $pitch$와 $roll$회전 행렬은 변화가 없는 항등행렬이 된다. $R_{\\beta} \\cdot R_{\\alpha} = (R_{yaw\\beta} \\cdot I \\cdot I) \\cdot (R_{yaw\\alpha} \\cdot I \\cdot I)$ $ = R_{yaw\\beta} \\cdot R_{yaw\\alpha}$ $ = R_{yaw(\\alpha + \\beta)}$ 이처럼, 오일러 각에서 한 축만 사용한다는 것은 결국 2차원 평면에서의 회전과 동일하므로, 선형 보간식을 사용하는 데 문제가 없다. 두 축에 대해서 회전하는 경우 만약 $x$축과 $y$축에 대해서 회전한다면\u0026hellip; $R_{(\\alpha + \\beta)} = R_{yaw(\\alpha + \\beta)} \\cdot R_{pitch(\\alpha + \\beta)} \\cdot I = R_{yaw(\\alpha + \\beta)} \\cdot R_{pitch(\\alpha + \\beta)}$ $R_{\\beta} \\cdot R_{\\alpha} = (R_{yaw\\beta} \\cdot R_{pitch\\beta} \\cdot I) \\cdot (R_{yaw\\alpha} \\cdot R_{pitch\\alpha} \\cdot I)$ $ = R_{yaw\\beta} \\cdot R_{pitch\\beta} \\cdot R_{yaw\\alpha} \\cdot R_{pitch\\alpha}$ $ \\neq R_{(\\alpha + \\beta)}$ 이처럼, 두 축 이상을 사용하는 오일러 각은 선형 보간식을 사용할 수 없다. 해결 방법 로드리게스 회전 공식(Chapter 11) 사원수(Chapter 16) ","date":"2022-04-12T18:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-10/","title":"[Game Math] Chapter 10. 3차원 공간: 입체 공간의 생성"},{"content":" 게임 엔진의 구성 요소 게임 엔진의 인터페이스는 게임 콘텐츠가 담기는 게임 공간을 설계하는 작업 공간과, 게임 데이터를 관리하는 작업 공간으로 나뉜다. 게임 공간: 씬(Scene), 레벨(Level) 데이터: 리소스(Resource), 애셋(Asset) 게임엔진은 씬 데이터와 리소스 데이터를 결합해서 최종 게임 화면이 렌더링되로록 설계됐다. 씬의 구조 콘텐츠를 구성하는 기본단위: 액터(Actor), 게임 오브젝트(GameObject) 크기, 회전, 위치로 구성된 트랜스폼(Transform)의 정보를 사용해서 관리한다. 이 트랜스폼 정보에 모델링 행렬을 사용해서 렌더링할 물체의 정점을 변환한다. 모델링 행렬의 설계 트랜스폼의 크기, 회전, 이동 데이터\n크기(S): 2차원 벡터 $(s_x, s_y)$ 회전(R): 각 $\\theta$ 이동(T): 2차원 벡터 $(t_x, t_y)$ 크기, 회전, 이동에 대한 세 가지 아핀 변환행렬에 대응된다.\n$$S = \\begin{bmatrix} a \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; b \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$R = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \u0026amp; 0 \\\\ \\sin\\theta \u0026amp; \\cos\\theta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; a\\\\ 0 \u0026amp; 1 \u0026amp; b \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 그렇다면 아핀 변환을 어떤 순서로 적용해야 할까?\n회전과 이동변환을 할 경우 아래처럼 순서에 따라서 다른 결과가 나온다. 이것은 회전 대신 크기변환을 해도 마찬가지이다. 따라서 이동변환은 가장 마지막에 해야하겠다. 이동변환을 제외하면 크기변환과 회전변환이 남는다. 크기와 회전변환을 할 경우에도 순서에 따라서 다른 결과가 나온다. Chapter 7에서 보았듯이 회전변환은 물체의 형태를 그대로 보존해주는 강체 변환(Rigid Transform)이기 때문에 회전변환을 나중에 해서 형태를 유지하는 것이 사용자 입장에서 직관적인 변환이겠다. 따라서 아핀 변환의 순서는 크기 → 회전 → 위치순서로 이뤄지며 행렬곱으로 나타내면 다음과 같다. (열 기준 행렬으로 설명한다. 따라서 변환의 순서는 오른쪽에서 왼쪽으로 진행된다.)\n$T \\cdot R \\cdot S$ 이 3가지 변환을 수행하는 합성행렬인 **모델링 행렬(Modeling matrix)**은 다음과 같다.\n$$M = T \\cdot R \\cdot S = \\begin{bmatrix} \\cos\\theta \\cdot s_x \u0026amp; -\\sin\\theta \\cdot s_y \u0026amp; t_x \\\\ \\sin\\theta \\cdot s_x \u0026amp; \\cos\\theta \\cdot s_y \u0026amp; t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 로컬 공간과 로컬 축 로컬 공간(Local space) Chapter 8에서 보았듯이, 하나의 물체를 표현하기 위해서 만들어진 메시 데이터는 자신만의 공간에서 물체를 구성하는 각 정점의 위치 정보가 저장된다. 이렇게 물체의 정보를 담기 위해 부여한 공간을 로컬 공간이라고 한다. 월드 공간(World space) 게임 콘텐츠는 단일 물체가 아니라 여러가지 물체를 모아서 하나의 배경을 만든다. 이럴 때 사용하는 새로운 공간을 월드 공간이라고 한다. 예를 들어, 비행기 게임을 만든다고 하자. 그러면 월드 공간을 중심으로 설정된 비행기의 위치좌표가 필요하다. 또한 앞으로 나아가는 비행기의 방향을 조종하려면 월드 공간과 무관하게 비행기가 바라보는 방향 정보도 필요할 것이다. 로컬 축(Local Axis)\n이렇게 물체를 기준으로 설정된 방향 정보를 로컬 축이라고 한다. 로컬 축 정보는 로컬 공간의 기저벡터와 동일한 값을 가진다. 게임 엔진은 월드의 $X$, $Y$, $Z$축과 구분하기 위해 각 로컬 축의 이름을 다음과 같이 부른다. 로컬 축 로컬 축의 이름 $+X$ 라이트벡터 (Right Vector) $+Y$ 업벡터 (Up Vector) $+Z$ 포워드벡터 (Forward Vector) 트랜스폼의 이동과 크기 정보가 변경되더라도 게임 오브젝트가 보는 방향은 변함이 없기 때문에, 로컬 축 정보는 오직 회전 정보에만 영향을 받는다. 게임 오브젝트에 새로운 회전 값 $\\theta$가 설정되면 로컬 축을 구성하는 표준기저벡터도 이에 따라 변한다. $e_1$이 변화된 값을 $\\vec{r}$로, $e_2$가 변화된 값을 $\\vec{u}$로 표현하면 그 값은 다음과 같다. $\\vec{r} = (\\cos\\theta, \\sin\\theta)$ $\\vec{u} = (-\\sin\\theta, \\cos\\theta)$ 여기서 로컬축 벡터의 원소를 각각 $\\vec{r} = (r_x, r_y)$, $\\vec{u} = (u_x, u_y)$로 지정하면, 아핀 회전 변환행렬은 삼각함수 대신 로컬 축 벡터를 사용해 생성할 수 있다. 따라서 모델링 행렬 역시 삼각함수 대신 로컬 축 정보를 사용해 계산할 수 있다. $$M = T \\cdot R \\cdot S = \\begin{bmatrix} r_x \\cdot s_x \u0026amp; u_x \\cdot s_y \u0026amp; t_x \\\\ r_y \\cdot s_x \u0026amp; u_y \\cdot s_y \u0026amp; t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class TransformComponent { // 회전하면 로컬 축을 갱신한다. void SetRotation(float InDegree) { _Rotation = InDegree; Update(); } void AddRotation(float InDegree) { _Rotation += InDegree; Update(); } // ... private: Vector2 _Right = Vector2::UnityX; // e1 Vector2 _Up = Vector2::UnityY; // e2 }; // 열벡터를 사용해서 모델링 행렬을 만든다. FORCEINLINE Matrix3x3 TransformComponent::GetModelingMatrix() const { return Matrix3x3( Vector3(_Scale.X * _Right.X, _Scale.X * _Right.Y, 0.f), Vector3(_ScaleY. * _Up.X, _ScaleY. * _Up.Y, 0.f), Vector3(_Position.X, _Position.Y, 1.f) ); } // sin cos함수를 이용해서 현재 회전 정보에 맞는 로컬 축 벡터를 갱신한다. FORCEINLINE void TransformComponent::Update() { float sin, cos; Math::GetSinCos(sin, cos, _Rotation); _Right = Vector2(cos, sin); // e1 _Up = Vector2(-sin, cos); // e2 } 리소스 관리 월드 공간에 동일한 게임 오브젝트를 여러 개 배치한다고 하자.\n모델링 행렬을 사용해서 로컬 공간 정보를 월드 공간 정보로 변환하여 트랜스폼 정보를 설정해야할 것이다. 여기서 각각의 게임 오브젝트들은 각자의 트랜스폼 정보를 포함하고 있다. 그렇다면 리소스 데이터는 어떨까? 용량이 큰 메시 정보를 모두 각각 가지고 있다면 메모리 공간이 낭비될 것이다. 따라서 리소스 데이터는 여러 게임 오브젝트들이 함께 사용할 수 있는 공유 자원의 형태로 관리하는 것이 바람직하다. 리소스 저장소(Resource repository)\n씬과 무관하게 별도로 리소스를 모아두는 저장소이다. 게임 오브젝트는 리소스의 키 값만 저장하며, 이것을 통해서 리소스에 접근한다. 게임 엔진의 워크플로우 워크플로우(Workflow)\n실행의 흐름. 게임 엔진의 워크플로우는 크게 씬을 완성하는 과정, 완성된 씬으로부터 화면을 그려내는 과정으로 나뉜다. (저자가 제작한) 게임 엔진의 워크플로우\n1. 리소스 로딩 단계 메시, 텍스처 같은 리소스는 게임을 진행하면서 불러들이기에는 데이터 양이 크기 때문에 게임 시작 전에 미리 불러들여서 메모리에 올려둬야 안정적으로 게임을 진행할 수 있다. LoadResources() 2. 씬 구축 단계 게임 오브젝트의 트랜스폼 정보가 설정되며 리소스 정보가 게임 오브젝트에 연결된다. LoadScene2D() 3. 게임 로직 단계 프레임마다 게임 오브젝트의 트랜스폼 값을 변경한다. Update2D() 4. 렌더링 로직 단계 트랜스폼 정보와 리소스 데이터를 활용해서 최종화면을 그린다. Render2D() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 1. 리소스 로딩 단계 // 메시 const std::size_t GameEngine::QuadMesh = std::hash\u0026lt;std::string\u0026gt;()(\u0026#34;SM_Quad\u0026#34;); // 텍스처 const std::size_t GameEngine::BaseTexture = std::hash\u0026lt;std::string\u0026gt;()(\u0026#34;Base\u0026#34;); const std::string GameEngine::CharacterTexturePath(\u0026#34;CKMan.png\u0026#34;); bool GameEngine::LoadResources() { // 사각형 메시 데이터 객체를 생성하고 QuadMesh 키를 부여한다. Mesh\u0026amp; quadMesh = CreateMesh(GameEngine::QuadMesh); constexpr float squareHalfSize = 0.5f; constexpr int vertexCount = 4; constexpr int triangleCount = 2; constexpr int indexCount = triangleCount * 3; auto\u0026amp; v = quadMesh.GetVertices(); // 정점 버퍼 auto\u0026amp; i = quadMesh.GetIndices(); // 인덱스 버퍼 auto\u0026amp; uv = quadMesh.GetUVs(); // UV 값 v = { Vector2(-squareHalfSize, -squareHalfSize), Vector2(-squareHalfSize, squareHalfSize), Vector2(squareHalfSize, squareHalfSize), Vector2(squareHalfSize, -squareHalfSize) }; uv = { Vector2(0.125f, 0.75f), Vector2(0.125f, 0.875f), Vector2(0.25f, 0.875f), Vector2(0.25f, 0.75f) }; i = { 0, 2, 1, 0, 3, 2 }; // 텍스처 객체를 생성하고 BaseTexture 키를 부여한다. Texture\u0026amp; baseTexture = CreateTexture(GameEngine::BaseTexture, GameEngine::CharacterTexturePath); // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 2. 씬 구축 단계 // 게임 오브젝트 목록 static const std::string PlayerGo(\u0026#34;Player\u0026#34;); // 최초 씬 로딩을 담당하는 함수 void SoftRenderer::LoadScene2D() { // 최초 씬 로딩에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; g = Get2DGameEngine(); // 플레이어의 생성과 설정 constexpr float playerScale = 30.f; GameObject\u0026amp; goPlayer = g.CreateNewGameObject(PlayerGo); // 게임 오브젝트를 생성한다. goPlayer.SetMesh(GameEngine::QuadMesh); // 메시 키를 설정한다. goPlayer.GetTransform().SetScale(Vector2::One * playerScale); // 최초 트랜스폼을 설정한다. goPlayer.SetColor(LinearColor::Red); // 100개의 배경 게임 오브젝트 생성과 설정 char name[64]; constexpr float squareScale = 20.f; std::mt19937 generator(0); std::uniform_real_distribution\u0026lt;float\u0026gt; dist(-1000.f, 1000.f); for (int i = 0; i \u0026lt; 100; ++i) { std::snprintf(name, sizeof(name), \u0026#34;GameObject%d\u0026#34;, i); GameObject\u0026amp; newGo = g.CreateNewGameObject(name); newGo.GetTransform().SetPosition(Vector2(dist(generator), dist(generator))); newGo.GetTransform().SetScale(Vector2::One * squareScale); newGo.SetMesh(GameEngine::QuadMesh); newGo.SetColor(LinearColor::Blue); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 3. 게임 로직 단계 // 게임 로직을 담당하는 함수 void SoftRenderer::Update2D(float InDeltaSeconds) { // 게임 로직에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; g = Get2DGameEngine(); const InputManager\u0026amp; input = g.GetInputManager(); // 게임 로직의 로컬 변수 static float moveSpeed = 200.f; static float rotateSpeed = 180.f; static float scaleMin = 15.f; static float scaleMax = 30.f; static float scaleSpeed = 180.f; // 플레이어에 대한 주요 레퍼런스 GameObject\u0026amp; goPlayer = g.GetGameObject(PlayerGo); TransformComponent\u0026amp; transform = goPlayer.GetTransform(); // 입력에 따른 플레이어 위치와 크기의 변경 float newScale = Math::Clamp(transform.GetScale().X + scaleSpeed * input.GetAxis(InputAxis::ZAxis) * InDeltaSeconds, scaleMin, scaleMax); transform.SetScale(Vector2::One * newScale); transform.AddRotation(input.GetAxis(InputAxis::XAxis) * rotateSpeed * InDeltaSeconds); transform.AddPosition(transform.GetLocalY() * input.GetAxis(InputAxis::YAxis) * moveSpeed * InDeltaSeconds); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 4. 렌더링 로직 단계 // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render2D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; r = GetRenderer(); const auto\u0026amp; g = Get2DGameEngine(); // 배경에 격자 그리기 DrawGizmo2D(); // 렌더링 로직의 로컬 변수 size_t totalObjectCount = g.GetScene().size(); // 씬을 구성하는 모든 게임 오브젝트의 순회 for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { // 게임 오브젝트의 레퍼런스를 얻기 const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); Matrix3x3 finalMatrix = transform.GetModelingMatrix(); // 게임 오브젝트의 렌더링 수행 - 다음 절의 렌더링 파이프라인의 시작. DrawMesh2D(mesh, finalMatrix, gameObject.GetColor()); // 플레이어의 정보를 화면에 출력 if (gameObject == PlayerGo) { r.PushStatisticText(\u0026#34;Player Position : \u0026#34; + transform.GetPosition().ToString()); r.PushStatisticText(\u0026#34;Player Rotation : \u0026#34; + std::to_string(transform.GetRotation()) + \u0026#34; (deg)\u0026#34;); r.PushStatisticText(\u0026#34;Player Scale : \u0026#34; + std::to_string(transform.GetScale().X)); } } } 렌더링 파이프라인 렌더링 파이프라인(Rendering pipeline)\n게임 제작의 렌더링은 GPU가 처리한다. GPU 내부에 설정된 렌더링 워크플로우를 렌더링 파이프라인이라고 한다. 드로우 콜(Drawcall)\nCPU가 GPU에게 렌더링 작업을 수행하도록 명령을 하는 것이다. (저자가 제작한 게임 엔진에서는) DrawMesh2D()를 호출하는 것이 드로우 콜이라고 할 수 있겠다. (저자가 제작한) 렌더링 파이프라인 1. 정점 변환과 처리 단계 메시에 설정된 정점의 데이터는 로컬 공간을 기준으로 설정되어 있다. 이것을 월드 공간 중심으로 변환하여 화면에 그려질 정점의 최종 위치 값을 구한다. 즉, 모델링 행렬에 로컬 공간의 좌표를 곱한다. DrawMesh2D(), VertexShader2D() 2. 픽셀화와 픽셀 처리 단계 Chapter 8에서 보았던 무게중심좌표를 활용해서 삼각형 영역의 픽셀을 추려내고, 색상을 결정한다. 해당 픽셀의 UV에 대응되는 색상을 가져온 후 필요하다면 추가로 조명 효과 등을 적용해서 최종 픽셀 색상을 설정한다. DrawTriangle2D(), FragmentShader2D() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // 1. 정점 변환과 처리 // 메시를 그리는 함수 void SoftRenderer::DrawMesh2D(const class DD::Mesh\u0026amp; InMesh, const Matrix3x3\u0026amp; InMatrix, const LinearColor\u0026amp; InColor) { // 메시의 구조를 파악하기 위한 로컬 변수 size_t vertexCount = InMesh.GetVertices().size(); size_t indexCount = InMesh.GetIndices().size(); size_t triangleCount = indexCount / 3; // 메시 정보를 렌더러가 사용할 정점 버퍼와 인덱스 버퍼로 변환 std::vector\u0026lt;Vertex2D\u0026gt; vertices(vertexCount); std::vector\u0026lt;size_t\u0026gt; indice(InMesh.GetIndices()); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = InMesh.GetVertices()[vi]; if (InMesh.HasColor()) { vertices[vi].Color = InMesh.GetColors()[vi]; } if (InMesh.HasUV()) { vertices[vi].UV = InMesh.GetUVs()[vi]; } } // 정점 변환 진행!! VertexShader2D(vertices, InMatrix); // 그리기모드 설정 FillMode fm = FillMode::None; if (InMesh.HasColor()) { fm |= FillMode::Color; } if (InMesh.HasUV()) { fm |= FillMode::Texture; } // 메시를 삼각형으로 쪼개서 각각 그리기 for (int ti = 0; ti \u0026lt; triangleCount; ++ti) { int bi0 = ti * 3, bi1 = ti * 3 + 1, bi2 = ti * 3 + 2; std::vector\u0026lt;Vertex2D\u0026gt; tvs = { vertices[indice[bi0]] , vertices[indice[bi1]] , vertices[indice[bi2]] }; // 2. 픽셀화 DrawTriangle2D(tvs, InColor, fm); } } 셰이더(Shader)\nGPU의 렌더링 파이프라인의 몇몇 부분은 프로그래밍이 가능하다. 이런 부분을 개발자가 프로그래밍해서 만들어낸, 렌더링 효과를 계산하는 함수를 셰이더라고 한다. 정점 셰이더(Vertex Shader)\n개발자들이 변환을 직접 설계해서 만든 정점 처리 함수이다. 1 2 3 4 5 6 7 8 9 10 // 정점 셰이더 FORCEINLINE void VertexShader2D(std::vector\u0026lt;Vertex2D\u0026gt;\u0026amp; InVertices, const Matrix3x3\u0026amp; InMatrix) { // 위치 값에 최종 행렬을 적용해 변환 for (Vertex2D\u0026amp; v : InVertices) { v.Position = InMatrix * v.Position; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 2. 픽셀화와 픽셀 처리 // 삼각형을 그리는 함수 void SoftRenderer::DrawTriangle2D(std::vector\u0026lt;DD::Vertex2D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; r = GetRenderer(); const GameEngine\u0026amp; g = Get2DGameEngine(); const Texture\u0026amp; texture = g.GetTexture(GameEngine::BaseTexture); if (IsWireframeDrawing()) { // 와이어 프레임 모드 } else { // ... 삼각형 칠하기 // 삼각형 영역 내 모든 점을 점검하고 색칠 for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++y) { ScreenPoint fragment = ScreenPoint(x, y); Vector2 pointToTest = fragment.ToCartesianCoordinate(_ScreenSize); Vector2 w = pointToTest - InVertices[0].Position; float wdotu = w.Dot(u); float wdotv = w.Dot(v); float s = (wdotv * udotv - wdotu * vdotv) * invDenominator; float t = (wdotu * udotv - wdotv * udotu) * invDenominator; float oneMinusST = 1.f - s - t; if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { Vector2 targetUV = InVertices[0].UV * oneMinusST + InVertices[1].UV * s + InVertices[2].UV * t; // 색상 결정 진행!! r.DrawPoint(fragment, FragmentShader2D(texture.GetSample(targetUV), LinearColor::White)); } } } } } 파편(Fragment) GPU에서는 삼각형을 구성하는 픽셀을 파편이라고 한다. 파편 셰이더(Fragment Shader) 혹은 픽셀 셰이더(Pixel Shader) 개발자들이 직접 설계한, 최종 픽셀을 계산하는 함수이다. 1 2 3 4 5 6 // 픽셀 셰이더 (단순하게 흰색을 합성해서 고유의 색을 표현하도록 함) FORCEINLINE LinearColor FragmentShader2D(LinearColor\u0026amp; InColor, const LinearColor\u0026amp; InColorParam) { return InColor * InColorParam; } 카메라 시스템 게임 엔진에는 개발자 관점에서 바라보는 게임 공간과 게이머가 바라보는 게임 공간, 이 두 가지 화면을 제공한다. 그렇다면 게이머를 위한 카메라는 월드 공간에 어떻게 설정할 수 있을까? 가상 공간의 카메라 뷰포트(Viewport)\n카메라는 자신이 출력할 화면의 해상도 정보를 가지고 월드의 일부를 그려낸다. 이 때 카메라가 출력할 화면의 크기 정보를 뷰포트라고 한다. 즉, 게이머가 보는 게임 공간의 크기가 바로 뷰포트다. 뷰 공간(View space)\n카메라에 설정된 뷰포트 정보를 바탕으로 월드 공간의 일부분을 렌더링해야 한다. 이를 위해서는 카메라를 중심으로 물체의 트랜스폼을 재조정하는 작업이 필요하다. 여기서 카메라를 중심으로 변환한 공간을 뷰 공간이라고 한다. 로컬 공간, 월드 공간, 뷰 공간의 개념을 정리하면 다음과 같다. 카메라를 중심으로 전개되는 뷰 공간을 어떻게 설계할 수 있을까?\n예를 들어, 월드 공간에 카메라가 $(-10, -10)$에 있고, 어떤 물체가 $(10, 10)$에 있다고 하자. 그렇다면 카메라로부터 해당 게임 오브젝트의 상대적 위치는 $(20, 20)$이 된다. 어떻게 하면 그 물체의 월드 공간 좌표인 $(10, 10)$을 뷰 공간 좌표인 $(20, 20)$로 바꿀 수 있을까? 뷰 행렬(View matrix)\n모델링 행렬이 로컬 공간의 좌표를 월드 공간의 좌표로 변환해준다면, 뷰 행렬은 월드 공간의 좌표를 뷰 공간의 좌표로 변환해준다. 이전 예제를 다시보면, 뷰 공간 좌표인 $(20, 20)$은 물체의 월드 공간 좌표에다가 카메라의 위치를 기준으로 측정한 월드 원점의 상대 좌표인 $(10, 10)$을 더하면 얻을 수 있다. 그리고 그 상대 좌표는 카메라의 월드 공간 좌표를 반전시켜서 얻을 수 있다. 즉, 이동 행렬의 역행렬을 사용해서 계산하면 된다. $$V = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; -t_x \\\\ 0 \u0026amp; 1 \u0026amp; -t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 따라서, 로컬 공간 $v_{local}$을 뷰 공간 $v_{view}$으로 변환하는 과정은 다음과 같다.\n$v_{view} = V \\cdot M \\cdot v_{local}$ 즉, 행렬 $VM$은 로컬 공간을 뷰 공간으로 변환한다. 다음은 플레이어를 따라가는 카메라의 로직을 구현한 예제이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 게임 로직을 담당하는 함수 void SoftRenderer::Update2D(float InDeltaSeconds) { // 게임 로직에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; g = Get2DGameEngine(); const InputManager\u0026amp; input = g.GetInputManager(); // 게임 로직의 로컬 변수 static float moveSpeed = 200.f; static float rotateSpeed = 180.f; static float scaleMin = 15.f; static float scaleMax = 30.f; static float scaleSpeed = 180.f; static float minDistance = 1.f; // 플레이어와 카메라의 위치가 일치할 최소거리 static float lerpSpeed = 2.f; // 플레이어가 카메라를 쫒아가는 속도 // 플레이어에 대한 주요 레퍼런스 GameObject\u0026amp; goPlayer = g.GetGameObject(PlayerGo); TransformComponent\u0026amp; transform = goPlayer.GetTransform(); // 입력에 따른 플레이어 위치와 크기의 변경 transform.AddPosition(Vector2(input.GetAxis(InputAxis::XAxis), input.GetAxis(InputAxis::YAxis)).GetNormalize() * moveSpeed * InDeltaSeconds); float newScale = Math::Clamp(transform.GetScale().X + scaleSpeed * input.GetAxis(InputAxis::ZAxis) * InDeltaSeconds, scaleMin, scaleMax); transform.SetScale(Vector2::One * newScale); transform.AddRotation(input.GetAxis(InputAxis::WAxis) * rotateSpeed * InDeltaSeconds); // 플레이어를 따라다니는 카메라의 트랜스폼 TransformComponent\u0026amp; cameraTransform = g.GetMainCamera().GetTransform(); Vector2 playerPos = transform.GetPosition(); Vector2 cameraPos = cameraTransform.GetPosition(); if ((playerPos - cameraPos).SizeSquared() \u0026lt; minDistance * minDistance) { // 최소거리보다 작으면 플레이어 위치로 간다. cameraTransform.SetPosition(playerPos); } else // 최소거리보다 크면 서서히 이동한다. { float ratio = Math::Clamp(lerpSpeed * InDeltaSeconds, 0.f, 1.f); Vector2 newCameraPos = cameraPos + (playerPos - cameraPos) * ratio; cameraTransform.SetPosition(newCameraPos); } } // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render2D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; r = GetRenderer(); const auto\u0026amp; g = Get2DGameEngine(); const auto\u0026amp; texture = g.GetTexture(GameEngine::BaseTexture); // 배경에 격자 그리기 DrawGizmo2D(); // 렌더링 로직의 로컬 변수 size_t totalObjectCount = g.GetScene().size(); Matrix3x3 viewMatrix = g.GetMainCamera().GetViewMatrix(); // 뷰 행렬 // 씬을 구성하는 모든 게임 오브젝트의 순회 for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { // 게임 오브젝트의 레퍼런스를 얻기 const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); Matrix3x3 finalMatrix = viewMatrix * transform.GetModelingMatrix(); // 뷰행렬 * 모델링 행렬으로 VM을 구한다 // 게임 오브젝트의 렌더링 수행 DrawMesh2D(mesh, finalMatrix, gameObject.GetColor()); // 플레이어의 정보를 화면에 출력 if (gameObject == PlayerGo) { r.PushStatisticText(\u0026#34;Player Position : \u0026#34; + transform.GetPosition().ToString()); r.PushStatisticText(\u0026#34;Player Rotation : \u0026#34; + std::to_string(transform.GetRotation()) + \u0026#34; (deg)\u0026#34;); r.PushStatisticText(\u0026#34;Player Scale : \u0026#34; + std::to_string(transform.GetScale().X)); } } } ","date":"2022-04-08T18:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-09/","title":"[Game Math] Chapter 9. 게임 엔진: 콘텐츠를 만드는 기술"},{"content":" 세 점의 결합 Chapter 6에서 보았듯이, 아핀 결합은 여러개의 점을 결합해서 새로운 점을 생성하는 수식이다. 이 때 스칼라 값들은 그 합이 모두 $1$이어야 했다. 세 점 $P_1$, $P_2$, $P_3$를 결합하는 경우에도 스칼라값 3개의 합은 $1$이 되어야 할 것이다. $P\u0026rsquo; = s \\cdot P_1 + t \\cdot P_2 + (1 - s - t) \\cdot P_3$ $(P\u0026rsquo; - P_3) = s(P_1 - P_3) + t(P_2 - P_3)$ $\\vec{w} = s \\cdot \\vec{u} + t \\cdot \\vec{v}$ 이 때 벡터 $\\vec{u}$와 $\\vec{v}$가 선형 독립의 관계라면, 벡터 $\\vec{w}$는 2차원 벡터 공간 $\\mathbb{R}^2$에 존재하는 모든 벡터가 될 수 있다. 즉, 세 점의 아핀 결합은 평면의 모든 점을 만들어낸다. 여기서 $s$와 $t$의 값의 범위를 $[0, 1]$로 고정시키면 어떻게 될까? 해당 영역은 삼각형이 된다. 이렇게 아핀 결합에서 모든 스칼라 값을 $[0, 1]$ 범위로 한정한 결합을 컨벡스 결합(Convex combination) 이라고 부른다. 컨벡스 결합은 Chapter 6의 아핀 결합식에 각 스칼라 범위를 $[0, 1]$로 제한하는 조건을 추가해서 다음과 같이 표현할 수 있다. $$\\displaystyle\\sum_{i=1}^{n} c_i \\cdot P_i (s.t. \\displaystyle\\sum_{i=1}^{n} c_i = 1, 0 \\leq c_i \\leq 1)$$ 컨벡스 영역(Convex region)\n선분이나 삼각형처럼 컨벡스 결합으로 만든 영역. 컨벡스는 사전적으로 \u0026lsquo;볼록한\u0026rsquo;을 뜻한다. 수학에서 정의하는 볼록함이란, 영역 내 임의의 두 점을 연결한 선분을 만들었을 때, 그 선분은 언제나 해당 컨벡스 영역 안에 속하는 성질을 의미한다. 컨케이브 영역(Concave region)\n컨벡스 영역과 반대로, 임의의 두 점을 연결한 선분이 영역 밖으로 벗어나는 경우가 있는 영역이다. 아래 사진에서 왼쪽이 컨벡스 영역, 오른쪽이 컨케이브 영역이다. 4개의 점을 결합하는 컨벡스 결합은 어떻게 구성될까? $\\vec{x} = a \\cdot \\vec{u} + b \\cdot \\vec{v} + c \\cdot \\vec{w}$ 세 벡터 $\\vec{u}$, $\\vec{v}$, $\\vec{w}$가 선형 독립 관계를 이룬다면 3차원 공간의 모든 벡터를 생성할 수 있으므로, 벡터 $\\vec{x}$는 3차원 공간의 벡터가 된다. 여기서 스칼라 값을 $[0, 1]$ 범위로 제한한다면 삼각뿔(Tetrahedron) 영역이 형성된다. 이 또한 컨벡스 성질을 가진다. 메시 메시(Mesh) 삼각형을 중심으로 물체에 관련된 정보를 기록한 데이터이다. 메시는 다수의 삼각형으로 구성되고, 삼각형은 세 개의 점으로 구성되므로, 메시는 결국 다수의 점으로 구성된다고 볼 수 있다. 메시는 삼각형으로 물체의 외형을 표현하므로 삼각형의 위치정보를 가지고 있어야 한다. 이에 추가로 위치 뿐만 아니라 색상, 방향과 같은 부가 정보도 함께 제공한다. 이렇게 $위치 정보와 부가 정보를 묶은 특별한 점을 정점(Vertex) 이라고 한다. 즉, 메시는 정점들이 모인 데이터라고 할 수 있다. 와이어 프레임(Wireframe) 삼각형의 외곽선만 그려 메시를 표현하는 방법을 와이어 프레임이라고 한다. 정점 버퍼(Vertex buffer) 메시의 정점 정보를 빠르게 읽기 위해서 메모리에 정점 정보를 일렬로 나열하는 배열의 형태로 관리한다. 이것을 정점 버퍼라고 한다. 인덱스 버퍼(Index buffer) 정점 정보만으로는 삼각형을 만들 수 없으므로, 삼각형을 구성하는 정점의 인덱스(순번)만 기록한 배열을 별도로 만들어서 관리한다. 이것을 인덱스 버퍼라고 한다. 인덱스 버퍼는 삼각형의 수만큼 필요하기 때문에 인덱스 버퍼의 크기는 항상 3의 배수이다. 다음은 정사각형의 와이어 프레임을 그리는 예제이다. 정사각형을 구성하는 메시 정보를 표현하면 다음과 같다. 여기서 정점 0, 2번은 두 삼각형이 공유해 사용할 수 있다. 정점 버퍼 순서 좌표 0 (-0.5, -0.5) 1 (-0.5, 0.5) 2 (0.5, 0.5) 3 (0.5, -0.5) 인덱스 버퍼 순서 삼각형 정점 순서 0 0 0 1 0 1 2 0 2 3 1 0 4 1 2 5 1 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 정점 배열 static constexpr std::array\u0026lt;Vertex2D, vertexCount\u0026gt; rawVertices = { Vertex2D(Vector2(-sqareHalfSize, -squareHalfSize)), Vertex2D(Vector2(-sqareHalfSize, squareHalfSize)), Vertex2D(Vector2(sqareHalfSize, squareHalfSize)), Vertex2D(Vector2(sqareHalfSize, -squareHalfSize)) }; // 인덱스 배열 static constexpr std::array\u0026lt;size_t, triangleCount * 3\u0026gt; indices = { 0, 1, 2, 0, 2, 3 }; // ... 아핀 변환행렬을 곱해서 최종 행렬 finalMatrix를 생성한다. // 최종 행렬을 곱해서 위치 지정 static std::vector\u0026lt;Vertex2D\u0026gt; vertices(vertexCount); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = finalMatrix * rawVertices[vi].Position; } // 정점 배열과 인덱스 배열을 사용해서 삼각형의 점을 서로 이어준다. for (size_t ti = 0; ti \u0026lt; triangleCount; ++i) { size_t bi = ti * 3; r.DrawLine(vertices[indices[bi]].Position, vertices[indices[bi + 1]].Position, _WireframeColor); r.DrawLine(vertices[indices[bi]].Position, vertices[indices[bi + 2]].Position, _WireframeColor); r.DrawLine(vertices[indices[bi + 1]].Position, vertices[indices[bi + 2]].Position, _WireframeColor); } 무게중심좌표 무게중심좌표(Barycentric coordinate) $P\u0026rsquo; = s \\cdot P_1 + t \\cdot P_2 + (1 - s - t) \\cdot P_3$ 위 식에서 스칼라 값 $s$, $t$, $1 - s - t$는 모두 실수이다. 이들을 묶어서 하나의 3차원 벡터로 생성할 수 있다. 이렇게 아핀 결합의 스칼라를 묶어서 만든 좌표를 무게중심좌표라고 한다. 무게중심좌표의 계산 이전에 보았듯이 아핀 결합이 삼각형이 되려면 스칼라 값 $s$, $t$, $1 - s - t$는 $[0, 1]$ 범위 내에 있어야 한다.\n따라서 $[0, 1]$ 외부에 있다면 아핀 결합으로 생성된 점이 삼각형 외부에 있다고 볼 수 있다. 아핀 결합으로 생성된 점이 삼각형 내부에 있는지 판별하는 법 $\\vec{w} = s \\cdot \\vec{u} + t \\cdot \\vec{v}$ 이전에 보았던 이 수식에 벡터 $\\vec{u}$와 $\\vec{v}$를 내적해보자.\n$\\vec{w} \\cdot \\vec{u} = ( s \\cdot \\vec{u} + t \\cdot \\vec{v}) \\cdot \\vec{u}$ $\\vec{w} \\cdot \\vec{v} = ( s \\cdot \\vec{u} + t \\cdot \\vec{v}) \\cdot \\vec{v}$ 이것을 분배법칙에 따라 풀어준다.\n$ \\vec{w} \\cdot \\vec{u} = s(\\vec{u} \\cdot \\vec{u}) + t (\\vec{u} \\cdot \\vec{v})$ $ \\vec{w} \\cdot \\vec{v} = s(\\vec{u} \\cdot \\vec{v}) + t (\\vec{v} \\cdot \\vec{v})$ 위의 식에는 $(\\vec{u} \\cdot \\vec{v})$를, 및에 식에는 $(\\vec{u} \\cdot \\vec{u})$를 곱해 각각 전개해보자.\n$(\\vec{w} \\cdot \\vec{u})(\\vec{u} \\cdot \\vec{v}) = s(\\vec{u} \\cdot \\vec{u})(\\vec{u} \\cdot \\vec{v}) + t(\\vec{u} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{v})$ $(\\vec{w} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{u}) = s(\\vec{u} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{u}) + t(\\vec{v} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{u})$ 위에 식에서 아래식을 빼 $s$를 소거하고 $t$만 남긴다.\n$$ t = \\frac{ (\\vec{w} \\cdot \\vec{u})(\\vec{u} \\cdot \\vec{v}) - (\\vec{w} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{u}) }{ (\\vec{u} \\cdot \\vec{v})^2 - (\\vec{u} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v}) }$$ 예전 식에서 이번에는 위의 식에 $(\\vec{v} \\cdot \\vec{v})$를, 및에 식에는 $(\\vec{u} \\cdot \\vec{v})$를 곱해 각각 전개해보자.\n$(\\vec{w} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v}) = s(\\vec{u} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v}) + t(\\vec{u} \\cdot \\vec{v})(\\vec{v} \\cdot \\vec{v})$ $(\\vec{w} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{v}) = s(\\vec{u} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{v}) + t(\\vec{v} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{v})$ 위의 식에서 아래 식을 빼 $t$를 소거하고 $s$만 남긴다.\n$$ s = \\frac{ (\\vec{w} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{v}) - (\\vec{w} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v}) }{ (\\vec{u} \\cdot \\vec{v})^2 - (\\vec{u} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v}) }$$ 이렇게 얻어진 무게중심좌표 $(s, t, 1-s-t)$의 세 값 모두 $[0, 1]$ 범위 내에 있다면 새로 생성된 점은 삼각형 안에 있다고 할 수 있다. 반대로 그 범위를 벗어난다면, 삼각형 밖에 있다고 판단할 수 있다. 공통분모 $(\\vec{u} \\cdot \\vec{v})^2 - (\\vec{u} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v})$의 결과가 $0$이 나올 수도 있으므로 주의해야한다. 분모 값이 $0$이면 무게중심좌표를 구할 수가 없다. 공통분모에서 내적을 $\\cos$공식으로 변경하면 다음과 같아진다. $(|\\vec{u}||\\vec{v}|)^2 \\cdot \\cos^2\\theta - (|\\vec{u}||\\vec{v}|)^2$ 이 값이 $0$이 되기 위한 조건은 $\\vec{u}$ 혹은 $\\vec{v}$의 크기가 $0$이거나, 그 두 벡터가 이루는 각 $\\theta$가 $0^{\\circ}$ 혹은 $180^{\\circ}$일 때다. 이것은 두 벡터가 평행함을 의미한다. 두 벡터가 평행하면 선형 종속의 관계를 가지며 삼각형이 아니라 선분을 만들어낸다. 이런 삼각형을 퇴화삼각형(Degenerate triangle) 이라고 하며, 퇴화삼각형은 그리기에서 제외한다. 다음은 무게중심좌표를 사용해서 정사각형을 칠하는 예제이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // ... 이전 예제와 똑같은 과정을 거친다. for (size_t ti = 0; ti \u0026lt; triangleCount; ++i) { size_t bi = ti * 3; // 삼각형의 세 점 std::array\u0026lt;Vertex2D, 3\u0026gt; tv = {vertices[indices[bi]], vertices[indices[bi + 1]], vertices[indices[bi + 2]]}; // ... 삼각형의 세 점을 통해 minX, minY, maxX, maxY를 구한다. // u벡터와 v벡터 Vector2 u = tv[1].Position - tv[0].Position; Vector2 v = tv[2].Position - tv[0].Position; // 공통분모 구하기 float uDotv = u.Dot(v); float vDotv = v.Dot(v); float uDotu = u.Dot(u); float denominator = uDotv * uDotv - vDotv * uDotu; // 퇴화삼각형은 그리지 않는다!! if (denominator == 0.0f) continue; float invDenominator = 1.f / denominator; // ... minX, minY, maxX, maxY를 스크린 좌표계로 옮기고, 화면을 넘어서면 클리핑한다. // 삼각형을 둘러싸는 사각형 영역의 픽셀을 모두 순회한다. for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++x)) { // 스크린 좌표계와 데카르트 좌표계 ScreenPoint fragment = ScreenPoint(x, y); Vector2 pointToTest = fragment.ToCartesianCoordinate(_ScreenSize); // w벡터 Vector2 w = pointToTest - tv[0].Position; float wDotu = w.Dot(u); float wDotv = w.Dot(v); // s, t, 1-s-t 구하기 float s = (wDotv * uDotv - wDotu * vDotv) * invDenominator; float t = (wDotu * uDotv - wDotv * uDotu) * invDenominator; float oneMinusST = 1.f - s - t; // 컨벡스 조건을 만족할 때만 점 찍기!! if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp;((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { r.DrawPoint(fragment, LinearColor::Blue); } } } } 정점에 설정된 부가 정보의 활용 무게중심좌표의 값은 주어진 픽셀이 삼각형의 세 점으로부터 얼마나 영향을 받는지 파악하는 용도로도 활용할 수 있다. 예를 들어 어떤점의 무게중심좌표가 $(0.333, 0.333, 0.333)$이라면 삼각형의 세 점이 균일하게 영향을 미치는 삼각형의 무게중심에 그 점이 위치한다고 볼 수 있다. 다음은 무게중심좌표를 사용해서 삼각형에 색상을 입히는 예제이다. 정점 버퍼 인덱스 좌표 색상(RGB) 0 (0, 0.25) (1, 0, 0) Red 1 (-0.5, -0.25) (0, 1, 0) Green 2 (0.5, -0.25) (0, 0, 1) Blue 인덱스 버퍼 순서 삼각형 정점 순서 0 0 0 1 0 2 2 0 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 정점 배열에 색상정보도 추가한다. std::array\u0026lt;Vertex2D, vertexCount\u0026gt; rawVertices = { Vertex2D(Vector2(0.f, 0.25f), LinearColor(1.f, 0.f, 0.f)), Vertex2D(Vector2(-0.5f, -0.25f), LinearColor(0.f, 1.f, 0.f)), Vertex2D(Vector2(0.5f, -0.25f), LinearColor(0.f, 0.f, 1.f)) }; // 인덱스 배열 static constexpr std::array\u0026lt;size_t, triangleCount * 3\u0026gt; indices = { 0, 2, 1 }; // ... 아핀 변환행렬을 곱해서 최종 행렬 finalMatrix를 생성한다. // 최종 행렬을 곱해서 위치 지정. 색상 정보도 함께 복사한다. static std::vector\u0026lt;Vertex2D\u0026gt; vertices(vertexCount); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = finalMatrix * rawVertices[vi].Position; vertices[vi].Color = rawVertices[vi].Color; } for (size_t ti = 0; ti \u0026lt; triangleCount; ++i) { // ... for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++x)) { // ... // 무게중심좌표와 정점의 색상정보를 선형 보간해서 최종 픽셀 색상값을 계산한다. if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp;((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { LinearColor outColor = tv[0].Color * oneMinusST + tv[1].Color * s + tv[2].Color * t; r.DrawPoint(fragment, outColor); } } } } 텍스처 매핑 무게중심좌표는 메시에 이미지를 입하는 용도로도 활용할 수 있다.\n텍스처(Texture)\n메시에 이미지를 입히기 위해 변환된 데이터. 텍스처 매핑(Texture mapping)\n메시에 이미지를 입하는 작업. UV 좌표계\n사진이나 그림을 저장한 이미지는 각기 고유한 해상도를 가진다. 메시에 이것을 입히기 위해서 텍스처로 변환하면 관리 방식을 통일하기 위해 이미지 고유의 해상도에 관계없이 가로, 세로 크기가 $1$로 정규화된다. 이처럼 렌더링 과정에서 텍스처를 사용할 때는 $[0, 1]$범위로 구성된 2차원 좌표계를 사용하는 데 이 좌표계를 UV좌표계라고 한다. U는 가로정보, V는 세로정보를 나타낸다. 예를 들어, 왼쪽 하단을 원점으로 잡고 우상단으로 증가하는 방식의 UV좌표계는 다음과 같을 것이다. 텍스처 매핑 방법 삼각형의 세 정점에 UV 좌표 정보를 추가한다. 그리고 삼각형을 구성하는 각 픽셀들의 무게중심좌표를 계산해서 UV좌표와 선형보간한다. 이렇게 하면 해당 픽셀에 해당하는 UV값을 얻어낼 수 있다. 이 UV값에 대응하는 텍스처의 색상 정보를 얻은 후에 이것을 최정 픽셀의 색상으로 지정하면 텍스처 매핑이 완성된다. 다음은 무게중심좌표와 UV좌표를 사용해서 정사각형에 얼굴 텍스처를 입히는 예제이다. 정점 버퍼 인덱스 좌표 UV좌표 0 (-0.5, -0.5) (0.125, 0.75) 1 (-0.5, 0.5) (0.125, 0.875) 2 (0.5, 0.5) (0.25, 0.75) 3 (0.5, -0.5) (0.25, 0.875) 인덱스 버퍼 순서 삼각형 정점 순서 0 0 0 1 0 1 2 0 2 3 1 0 4 1 2 5 1 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 텍스쳐를 가져온다. const auto\u0026amp; texture = g.GetTexture(GameEngine::BaseTexture); //... // 정점 배열에 UV값도 추가한다. std::array\u0026lt;Vertex2D, vertexCount\u0026gt; rawVertices = { Vertex2D(Vector2(-sqareHalfSize, -squareHalfSize), LinearColor(), Vector2(0.125f, 0.75f)), Vertex2D(Vector2(-sqareHalfSize, squareHalfSize), LinearColor(), Vector2(0.125f, 0.875f)), Vertex2D(Vector2(sqareHalfSize, squareHalfSize), LinearColor(), Vector2(0.25f, 0.875f)), Vertex2D(Vector2(sqareHalfSize, -squareHalfSize), LinearColor(), Vector2(0.25f, 0.75f)), }; // 인덱스 배열 static constexpr std::array\u0026lt;size_t, triangleCount * 3\u0026gt; indices = { 0, 1, 2, 0, 2, 3 }; // ... 아핀 변환행렬을 곱해서 최종 행렬 finalMatrix를 생성한다. // 최종 행렬을 곱해서 위치 지정. UV 정보도 함께 복사한다. static std::vector\u0026lt;Vertex2D\u0026gt; vertices(vertexCount); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = finalMatrix * rawVertices[vi].Position; vertices[vi].UV = rawVertices[vi].UV; } // 정점 배열과 인덱스 배열을 사용해서 삼각형의 점을 서로 이어준다. for (size_t ti = 0; ti \u0026lt; triangleCount; ++i) { // ... for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++x)) { // ... // 무게중심좌표와 정점의 UV좌표를 선형 보간해서 최종 UV값을 계산한다. if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp;((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { Vector2 targetUV = tv[0].UV * oneMinusST + tv[1].UV * s + tv[2].UV * t; r.DrawPoint(fragment, targetUV.GetSample(targetUV)); } } } } ","date":"2022-04-07T18:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-08/","title":"[Game Math] Chapter 8. 삼각형: 물체를 구성하는 가장 작은 단위"},{"content":" 벡터의 내적 내적(Dot product) 같은 차원의 두 벡터가 주어졌을 때, 벡터를 구성하는 각 성분을 곱한 후 이들을 더해 스칼라를 만들어내는 연산이다. $\\vec{u} = (a, b)$, $\\vec{v} = (c, d)$ 일 때, $\\vec{u} \\cdot \\vec{v} = a \\cdot c + b \\cdot d$ 내적의 성질 교환법칙이 성립한다. $\\vec{u} \\cdot \\vec{v} = \\vec{v} \\cdot \\vec{u}$ 결합법칙이 성립하지 않는다. $\\vec{u} \\cdot (\\vec{v} \\cdot \\vec{w}) \\neq (\\vec{u} \\cdot \\vec{v}) \\cdot \\vec{w}$ 덧셈에 대한 분배법칙이 성립한다. $\\vec{w} \\cdot (\\vec{u} + \\vec{v}) = \\vec{u} \\cdot \\vec{w} + \\vec{v} \\cdot \\vec{w}$ 같은 벡터를 내적하면 크기를 제곱한 결과가 나온다. $\\vec{v} \\cdot \\vec{v} = |\\vec{v}|^2$ 두 벡터의 합의 내적은 두 벡터의 크기로 표현할 수 있다. $(\\vec{u} + \\vec{v}) \\cdot (\\vec{u} + \\vec{v}) = |\\vec{u}|^2 + |\\vec{v}|^2 + 2(\\vec{u} \\cdot \\vec{v})$ 내적과 삼각함수와의 관계 벡터의 내적은 두 벡터의 사잇각에 대한 $\\cos$함수와 비례한다. $\\vec{u} \\cdot \\vec{v} = |\\vec{u}||\\vec{v}|\\cos\\theta$ 이 식을 유도해보자. 그림과 같이 구성되었을 때 벡터 $\\vec{b}$의 크기를 제곱하면 다음과 같다.\n$|\\vec{b}|^2 = (|\\vec{a}| - |\\vec{c}|\\cos\\theta)^2 + |\\vec{c}|^2\\sin^2\\theta$ $ = |\\vec{a}|^2 - 2 |\\vec{a}||\\vec{c}|\\cos\\theta + |\\vec{c}|^2\\cos^2\\theta + |\\vec{c}|^2\\sin^2\\theta$ $ = |\\vec{a}|^2 + |\\vec{c}|^2 - 2 |\\vec{a}||\\vec{c}|\\cos\\theta$ 같은 벡터를 내적하면 벡터 크기의 제곱이 된다.\n$|\\vec{b}|^2 = \\vec{b} \\cdot \\vec{b}$ $ = (\\vec{a} + (-\\vec{c})) \\cdot (\\vec{a} + (-\\vec{c}))$ $ = |\\vec{a}|^2 + |\\vec{c}|^2 - 2\\vec{a} \\cdot \\vec{c}$ 따라서 다음 식이 성립한다.\n$\\vec{a} \\cdot \\vec{c} = |\\vec{a}||\\vec{c}|\\cos\\theta$ 여기서 두 벡터의 크기가 $1$이면, 두 벡터의 내적은 $\\cos$함수가 된다. $\\vec{u} \\cdot \\vec{v} = \\cos\\theta$ 두 벡터의 내적이 $0$이면, 두 벡터는 직교한다. 위의 공식에 따르면, 내적 값이 $0$이 되기 위한 조건은 $\\cos$함수의 값이 $0$이 되는 경우 뿐이다. $\\cos$함수의 값이 $0$이 되는 경우는 두 벡터의 사잇각이 $90^\\circ$ 혹은$270^\\circ(-90^\\circ)$인 경우다. 이것은 두 벡터가 서로 직교하는 경우이다. 벡터 공간에서 직교하는 두 표준기저벡터 $(0, 1)$, $(1, 0)$을 내적한 결과는 $0$이다. 그리고 이것을 $\\theta$만큼 회전한 두 기저벡터 $(\\cos\\theta, \\sin\\theta)$, $(-\\sin\\theta, \\cos\\theta)$도 직교하기 때문에 내적한 결과는 똑같이 $0$이다. 행렬의 곱셈을 내적으로 표현하기 행렬과 벡터의 곱셈 연산을 내적으로 표현해보자.\n$$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix}$$ $$ = \\begin{bmatrix} (a, b) \\cdot (x, y) \\\\ (c, d) \\cdot (x, y) \\end{bmatrix} $$ 이제 행렬과 행렬의 곱셈 연산을 내적으로 표현해보자.\n$$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\begin{bmatrix} e \u0026amp; f \\\\ g \u0026amp; h \\end{bmatrix} = \\begin{bmatrix} ae + bg \u0026amp; af + bh \\\\ ce + dg \u0026amp; cf + dh \\end{bmatrix}$$ $$ = \\begin{bmatrix} (a, b) \\cdot (e, g) \u0026amp; (a, b) \\cdot (f, h) \\\\ (c, d) \\cdot (e, g) \u0026amp; (c, d) \\cdot (f, h) \\end{bmatrix} $$ 직교 행렬(Orthogonal matrix)\n정방행렬을 구성하는 모든 행벡터와 열벡터의 크기가 $1$이고, 벡터들이 서로 직교하는 행렬이다. $$Q = \\begin{bmatrix} a \u0026amp; c \\\\ b \u0026amp; d \\end{bmatrix}$$ 위 행렬에서 $(a, c)$, $(b, d)$, $(a, b)$, $(c, d)$의 크기가 $1$이고, $(a, b)$와 $(c, d)$가 직교하면 직교 행렬이다. 직교행렬의 특징은 전치행렬이 곧 역행렬이라는 점이다. 따라서 직교행렬과 그 전치행렬의 곱은 항등행렬이된다.\n$Q \\cdot Q^T = I$ 이는 내적을 사용해서 증명할 수 있다. $(a, b)$와 $(c, d)$는 서로 직교하므로 두 벡터의 내적은 $0$이다. 그리고 행벡터와 열벡터의 크기가 $1$이므로 자기 자신과 내적한 결과는 $1$이 된다. $$Q = \\begin{bmatrix} a \u0026amp; c \\\\ b \u0026amp; d \\end{bmatrix}$$ $$Q^T \\cdot Q = \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\begin{bmatrix} a \u0026amp; c \\\\ b \u0026amp; d \\end{bmatrix} $$ $$ = \\begin{bmatrix} (a, b) \\cdot (a, b) \u0026amp; (a, b) \\cdot (c, d) \\\\ (c, d) \\cdot (a, b) \u0026amp; (c, d) \\cdot (c, d) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix} = I$$ 회전 변환행렬은 직교행렬이다.\n$$R_{\\theta} = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix}$$ $$R_{\\theta}^T \\cdot R_{\\theta} = \\begin{bmatrix} \\cos^2\\theta + \\sin^2\\theta \u0026amp; 0 \\\\ 0 \u0026amp; \\cos^2\\theta + \\sin^2\\theta \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix} = I$$ 강체 변환(Rigid Transformation)\n물체의 형태가 그대로 유지되는 선형 변환이다. 조건 변화된 기저벡터의 크기는 모두 $1$이어야 한다. 모든 기저벡터는 서로 직교해야한다. 행렬식 값이 $1$이어야 한다. 회전 변환은 강체 변환이다.\n회전 행렬은 앞서 보았듯이 직교 행렬이기 때문에 1, 2번 조건을 만족한다. 3번의 경우 행렬식 $ad - bc$가 다음과 같이 $1$이 된다. $det(R) = \\cos^2\\theta + \\sin^2\\theta = 1$ 시야 판별 앞뒤 판별 벡터의 크기 값은 언제나 양수이다. 따라서 내적의 부호는 $\\cos$ 함수가 결정한다.\n$\\cos$함수는 $(-90^\\circ, 90^\\circ)$에서 양의 부호를 가지고 $-90^\\circ$와 $90^\\circ$에서는 $0$이며, 나머지 범위에서는 음의 부호를 가진다. 따라서 이를 응용하면 벡터 내적의 부호만 가지고도 다음과 같이 판단할 수 있다.\n벡터 내적의 결과가 양수이다. 두 벡터는 같은 방향을 향하고 있다. 벡터 내적의 결과가 음수이다. 두 벡터는 다른 방향을 향하고 있다. (서로 마주보고 있다.) 벡터 내적의 결과가 $0$이다. 두 벡터는 직교한다. 이것들을 응용해서 목표물이 캐릭터 앞에 있는지 뒤에 있는지를 판별할 수 있겠다. $\\vec{f} \\cdot \\vec{v}$이 양수 캐릭터 앞에 목표물이 있다. $\\vec{f} \\cdot \\vec{v}$이 음수 캐릭터 뒤에 목표물이 있다. $\\vec{f} \\cdot \\vec{v}$이 $0$ 캐릭터 바로 옆에 목표물이 있다. 시야 판별 캐릭터에게 부여한 시야각이 $\\beta$라고 하자. 그리고 캐릭터에서 목표물로 향하는 벡터 $\\vec{v}$와의 사잇각을 $\\alpha$라고 하자. $\\cos$함수의 경우 $[0^\\circ, 180^\\circ]$에서는 각이 커질 수록 값이 작아진다. 이것을 활용해서 다음의 과정으로 캐릭터 시야 안에 목표물이 있는지 판별할 수 있다.\n(1) 시야각을 절반 나눈 각의 $\\cos\\frac{\\beta}{2}$를 미리 계산해둔다. (2) 캐릭터 시선 벡터의 크기를 $1$로 정규화시킨 단위 벡터 $\\hat{f}$을 구한다. (3) 캐릭터에서 목표물로 향하는 벡터를 정규화시킨 단위 벡터 $\\hat{v}$을 구한다. (4) 그 두 벡터의 내적 결과는 $\\hat{f} \\cdot \\hat{v} = \\cos\\alpha$가 된다. 이것을 앞서 계산해 두었던 $\\cos\\frac{\\beta}{2}$와 비교한다. 이 때 $\\hat{f} \\cdot \\hat{v}$가 $\\cos\\frac{\\beta}{2}$보다 크다면 사잇각이 시야보다 작다는 것을 의미하므로 물체가 시야 영역에 들어왔음을 의미한다. $\\hat{f} \\cdot \\hat{v} \\lt \\cos\\frac{\\beta}{2}$\n목표물이 시야 범위 안에 있다. $\\hat{f} \\cdot \\hat{v} \u0026gt; \\cos\\frac{\\beta}{2}$\n목표물이 시야 범위 밖에 있다. $atan2$함수를 사용해서 두 벡터가 이루는 각 $\\alpha$를 구한 후 이것을 $\\cos\\frac{\\beta}{2}$와 비교해도 동일한 결과를 얻을 수 있다. 하지만 위의 방법이 더 효율적이다. 조명 효과의 구현 램버트 반사(Lambertian reflection) 표면에서의 조명 모델 계산을 위해 쓰인다. 빛을 받아서 표면에서 반사되는 빛의 세기는 두 벡터가 만드는 사잇각의 $cos$함수에 비례한다는 것이다. 즉, 사잇각이 커질 수록 $\\cos$함수의 값이 적어져서 빛도 줄어든다는 것이다. 표면이 향하는 단위벡터 $\\hat{N}$과 표면에서 광원으로 향하는 단위벡터 $\\hat{L}$이 있다. 여기서 두 벡터를 내적하여 사잇각의 $\\cos$값을 얻을 수 있다. $\\hat{N} \\cdot \\hat{L} = \\cos\\theta$ 1 2 3 4 5 6 7 8 9 10 // circle에 존재하는 모든 픽셀 v에 대해 적용한다. for (auto const\u0026amp; v : circle) { Vector2 n = (v - circlePosition).GetNormalize(); Vector2 l = (lightPosition - v).GetNormalize(); float shading = Math::Clamp(n.Dot(l), 0.f, 1.f); // 음수는 의미가 없으므로 0으로 만든다. r.DrawPoint(v, lightColor * shading); // 빛의 색상과 shading을 곱해서 해당 픽셀에 적용한다. } 투영 벡터 벡터의 내적은 어떤 벡터를 다른 벡터에 직교 투영하는 용도로도 사용된다. 예를 들면, 다음과 같이 카메라와 물체 사이의 깊이 값을 구할 때, 내적을 사용해서 투영 벡터를 구할 수 있겠다. 투영 벡터를 구하는 공식\n$\\vec{A} \\cdot \\vec{B} = |\\vec{A}| \\cdot |\\vec{B}| \\cdot \\cos\\theta = |\\vec{A}| \\cdot |\\vec{B}| \\cdot \\frac{|\\vec{proj}|}{|\\vec{A}|} = |\\vec{B}| \\cdot |\\vec{proj}|$ $|\\vec{proj}| = \\frac{\\vec{A} \\cdot \\vec{B}}{|\\vec{B}|}$ $\\vec{proj}$는 $\\vec{B}$와 방향이 같으므로 $|\\vec{proj}| \\cdot \\hat{B}$으로도 표현할 수 있다. $\\vec{proj} = |\\vec{proj}| \\cdot \\hat{B}$ 여기에 맨 위의 공식을 대입하면 다음과 같다. $\\vec{proj} = \\frac{\\vec{A} \\cdot \\vec{B}}{|\\vec{B}|} \\cdot \\hat{B}$ $\\vec{proj} = \\frac{\\vec{A} \\cdot \\vec{B}}{|\\vec{B}|} \\cdot \\frac{\\vec{B}}{|\\vec{B}|} = \\frac{\\vec{A} \\cdot \\vec{B}}{|\\vec{B}|^2} \\cdot \\vec{B}$ 여기서 $\\vec{B}$ 크기가 $1$이라면 다음과 같이 단순하게 정리할 수 있다. $\\vec{proj} = (\\vec{A} \\cdot \\hat{B}) \\cdot \\hat{B}$ 1 2 3 4 5 6 Vector2 unitB = (lineEnd - lineStart).GetNormalize(); Vector2 A = point - lineStart; Vector2 proj = unitB * (A.Dot(unitB)); Vector2 projectedPoint = lineStart - proj; float depth = (projectedPoint - point).Size(); ","date":"2022-04-05T18:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-07/","title":"[Game Math] Chapter 7. 내적: 벡터 공간의 분석과 응용"},{"content":" 이동 변환을 위한 아핀 공간 행렬 곱으로 어떻게 이동 기능을 구현할 수 있을까? $$A \\cdot \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} x + a \\\\ y + b \\end{bmatrix}$$ 이러한 행렬 곱을 만족하는 정방행렬 $A$는 존재하지 않는다. 왜냐하면, 표준기저벡터의 원점을 이동시키기 위해서는 $A$가 선형성을 만족해야 한다. 그러나 선형성이 되기 위해서는 Chapter 5에서 본 것처럼 기저벡터가 원점에서 출발해야한다. 전단 변환을 생각해보자.\n전단 변환으로 공간을 오른쪽으로 밀면, $y$값이 $1$인 영역의 $x$범위는 밀어낸만큼 이동한다. 따라서 다음과 같이 벡터의 $y$값을 $1$로 고정한다면 $x$를 이동시킬 수 있다. $$\\begin{bmatrix} 1 \u0026amp; a\\\\ 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x + a \\\\ 1 \\end{bmatrix} $$ 그렇다면, 2차원을 3차원으로 확장해서 마지막 차원 $z$값을 1로 고정한 전단 변환을 시행하면 $x$와 $y$를 이동시킬 수 있겠다.\n$$\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; a\\\\ 0 \u0026amp; 1 \u0026amp; b \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x + a \\\\ y + b \\\\ 1 \\end{bmatrix} $$ 이동 변환행렬(Translate transformation matrix)\n마지막 차원의 값이 1이라는 특정 조건을 가지는 전단 변환을 활용해서 이동 기능을 행렬로 구현한 것이다. $$ T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; a\\\\ 0 \u0026amp; 1 \u0026amp; b \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 우리가 Chapter 5에서 보았던 크기와 회전 변환행렬의 경우 $2 \\times 2$정방행렬이기 때문에 이동 변환행렬과 같이 $3 \\times 3$으로 맞추어 줄 필요가 있겠다. $$S = \\begin{bmatrix} a \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; b \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$R = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \u0026amp; 0 \\\\ \\sin\\theta \u0026amp; \\cos\\theta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 아핀 공간(Affine space)\n벡터 공간에서 이동을 위해 마지막 차원 값을 $1$로 한정한 부분 공간을 말한다. 위의 그림에서 파란색으로 칠한 공간이다. 아핀 변환(Affine transformation)\n한 차원을 높여서 설계해서, 점, 직선, 평면을 보존하는 선형 변환을 말한다. 아핀 공간의 구성요소 점(Point)\n물체를 표현하고 위치를 지정하는 요소. 마지막 차원의 값은 항상 $1$이다. 2차원 공간의 점: $(x, y, 1)$ 3차원 공간의 점: $(x, y, z, 1)$ 이동 벡터 혹은 변위 벡터(Displacement vector)\n물체를 움직이는 데 사용하는 요소. 마지막 차원의 값은 항상 $0$이다. 아핀 공간의 점 $P_1$에 이동 벡터 $\\vec{v}$를 더한 결과는 아핀 공간의 다른 점 $P_2$에 대응된다. $P_1 + \\vec{v} = P_2$ $\\vec{v} = P_2 - P_1$ 여기서 벡터 $\\vec{v}$는 $P_1$에서 $P_2$를 향하는 벡터를 의미한다. (순서를 거꾸로하면 반대로 향한다.) 점 $P_1$이 $(x_1, y_1, 1)$이고 $P_2$이 $(x_2, y_2, 1)$이라면 두 점을 빼서. 만든 이동 벡터 $\\vec{v}$는 $x$, $y$값과 무관하게 $0$이다. $(x_1 - x_2, y_1 - y_2, 0)$ 아핀 공간의 성질 유클리드 공간(Euclidean space) → 아핀 공간에 대응 물리적인 관점에서 바라본 현실 세계의 3차원 공간. 유클리드 벡터(Euclidean vector) → 이동 벡터에 대응 유클리드 공간에서 작용하는 힘. 점과 이동 벡터의 마지막 차원 값을 토대로 다음과 같은 연산 규칙이 성립한다. 점 $-$ 점 $=$ 벡터 $(1 - 1 = 0)$ 점 $+$ 벡터 $=$ 점 $(1 + 0 = 1)$ 벡터 $+$ 벡터 $=$ 벡터 $(0 + 0 = 0)$ 점 $+$ 점 $\\neq$ 점 $(1 + 1 = 2)$ 마지막 차원 값이 $2$가 되므로 아핀 공간 영역을 벗어나게 되어서 성립하지 않는다. 아핀 결합 점 $+$ 점 $\\neq$ 점\n만약 선형 결합의 형태로 점에 스칼라를 곱한 후 더한다면 특정 조건에서 새로운 점을 생성하는 것이 가능하다. 점 $(x_1, y_1, 1)$과 $(x_2, y_2, 1)$에 각각 스칼라 $a$, $b$를 곱한 선형 결합은 다음과 같다.\n$a \\cdot P_1 + b \\cdot P_2 = (ax_1 + ax_2, ay_1 + by_2, a + b)$ 여기서 $a + b = 1$ 조건을 유지한다면 점과 점을 결합해서 새로운 점을 만들 수 있다. 동일한 원리로 점 세개를 가지고도 새로운 점을 만들 수 있다. $a \\cdot P_1 + b \\cdot P_2 + c \\cdot P_3 (s.t. a + b + c = 1)$ 아핀 결합(Affine combination)\n이렇게 여러 개의 점을 결합해서 새로운 점을 생성하는 수식을 아핀 결합이라고 한다. $n$개의 점을 아핀 결합하는 경우 $$\\displaystyle\\sum_{i=1}^{n} c_i \\cdot P_i (s.t. \\displaystyle\\sum_{i=1}^{n} c_i = 1)$$ 두 점의 결합 $b = 1 - a$을 대입하면, $a \\cdot P_1 + (1 - a) \\cdot P_2 = P\u0026rsquo;$이 된다. $a$에 $1$을 대입하면, 점 $P_1$이 생성된다. $a$에 $0$을 대입하면, 점 $P_2$가 생성된다. $a$에 $0.5$을 대입하면, 점 $P_1$과 $P_2$의 중점이 생성된다. $(\\frac{x_1 + x_2}{2}, \\frac{y_1 + y_2}{2}, 1)$ 이렇듯 두 점 $P_1$, $P_2$의 아핀 결합으로 새로운 점을 생성하면 $a$값이 양의 방향으로 커질 수록. $P_1$의 바깥쪽에 점이 생성되고, $a$의 값이 음의 방향으로 커질 수록 $P_2$의 바깥쪽 방향에 점이 생성된다. 따라서 아핀 결합으로 생성되는 점을 모두 모으면 두 점 $P_1$, $P_2$을 지나는 무한한 긴 선이 만들어질 것이다. 이것을 수식으로 확인해보면, $a \\cdot + (1 - a) \\cdot P_2 = P\u0026rsquo;$을 $a$로 묶어서 다시 정리하면 $a(P_1. - P_2) = (P\u0026rsquo; - P_2)$이다. 이것을 두 이동 벡터로 나타내면, $a \\cdot \\vec{u} = \\vec{v}$이다. 이 식으로 두 벡터가 평행하다는 것을 알 수 있고, 따라서 아핀 결합으로 생성되는 점은 두 점을 지나는 직선 상에 위치함을 보장받게 된다. 직선의 방정식 $L(a) = a \\cdot P_1 + (1 - a) \\cdot P_2$ 직선의 방정식은 $a$의 범위에 따라 다양한 종류의 선에 대응된다. (a) 직선(Line) 양쪽 받향으로 무한히 뻗어나가는 선. 추상적인 선의 성질을 표현할 때 사용한다. (b) 반직선(Ray) 지정한 위치에서 한쪽으로만 뻗어나가는 선. 레이캐스팅(Raycasting), 레이트레이싱(Raytracing)에 사용된다. (c) 선분(Line segment) 시작점과 끝점의 위치가 정해져 있는 선. 프로그래밍을 활용해서 화면에 선을 그릴 때 사용한다. 선 그리기 알고리즘 벡터를 모니터의 점으로 표현 데카르트 좌표계가 빈틈 없이 연속된(Continuous) 실수로 평면을 채우는 반면, 스크린 좌표계는 서로 독립된 영역을 가지는 이산적인(Discrete) 정수를 사용한다.\n픽셀(Pixel)\n스크린 좌표계를 사용해서 화면에 무언가를 표현하려면 스크린 좌표와 색상이 함께 지정되어야 한다. 이 때, 좌표와 색상에 대응하는 화면의 구성 요소를 픽셀이라고 한다. 픽셀화(Rasterization)\n벡터를 화면의 점으로 표현하기 위해서 실수로 표현된 벡터 좌표를 정수로 변환한 후 색상을 부여하는 과정을 픽셀화라고 한다. 데카르트 좌표계와 스크린 좌표계의 차이 데카르트 좌표계 스크린 좌표계 수 집합 실수 정수 수의 성질 연속성 이산성 단위 원소 벡터 픽셀 수의 범위 실수 범위 $0$부터 해상도 크기까지 선 그리기 알고리즘 브레젠험 알고리즘(Bresenham\u0026rsquo;s algorithm) 화면을 8등분영역으로 구분한 후, 각 영역별로 그려내는 방식을 사용한다. 픽셀을 선택하기 위해서 중간값 $0.5$를 사용하기 때문에 중점 알고리즘(Midpoint algorithm) 이라고도 한다. 첫 번째 영역인 1팔분면(Octant)은 $[0^\\circ , 45^\\circ]$의 범위를 가진다. 이것은 해당 영역에 존재하는 모든 선의 기울기가 $1$을 넘어설 수 없음을 의미한다. 시작 위치의 픽셀 $(x_0, y_0)$을 찍은 후에 그 다음 픽셀을 어디에 찍어야 할까? 1팔분면의 특성상 평행으로 이동하거나 아래로 한 칸 내려가게 될 것이다. 오른쪽으로 한 칸 이동한 $x$좌표는 $x_0 + 1$이 된다. $y$좌표는 평행($y_0$)이거나, 아래로 한 칸 내려갈($y_0 + 1$) 것이다. 둘 중에서 어떤 것일지 판단하기 위해서 중간값인 $y_0 + 0.5$를 사용한다. 즉, $y_0 + 0.5$를 기준으로 우리가 그리려는 $y$값이 더 작으면 수평으로 이동하고($y_0$), 그렇지 않으면 아래로 한 칸 내려가는($y_0 + 1$) 것이다. 이것을 직선의 방정식 $y = ax + b$을 사용해서 구하면 $2h - w \u0026lt; 0$이라는 판별식이 도출된다. (풀이 생략) 그 다음 픽셀은? 이전에 평행이동을 했다면, $(x_0 + 2, y_0 + 0.5)$을 직선의 방정식에 대입해서 판별식이 $4h - w \u0026lt; 0$이 된다. 이전에 아래로 내려갔다면, $(x_0 + 2, y_0 + 1.5)$을 직선의 방정식에 대입해서 판별식이 $4h - 3w \u0026lt; 0$이 된다. 이처럼 $x$값이 증가할 수록 판별식은 언제나 $2h$만큼 증가하며, 한 칸 내려갈 수록 $2w$만큼 줄어든다. 2팔분면은 1팔분면에서 $x$, $y$가 변경되었을 뿐 전개 방식은 동일하다. 3팔분면은 2팔분면에서 선분의 진행방향만 반대일 뿐 기본 원리는 동일하다. 따라서 다음과 같이 구현해 볼 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 void DrawLine(const Vector2\u0026amp; InStartPos, const Vector2\u0026amp; InEndPos, const LinearColor\u0026amp; InColor) { // 시작점과 끝점이 화면 영역을 벗어나면 클리핑 알고리즘을 수행한다(다음 절에서 살펴본다) Vector2 clippedStart = InStartPos; Vector2 clippedEnd = InEndPos; Vector2 screenExtend = Vector2(_ScreenSize.X, _ScreenSize.Y) * 0.5f; Vector2 minScreen = -screenExtend; Vector2 maxScreen = screenExtend; if (!CohenSutherlandLineClip(clippedStart, clippedEnd, minScreen, maxScreen)) { return; } ScreenPoint startPosition = ScreenPoint::ToScreenCoordinate(_ScreenSize, clippedStart); ScreenPoint endPosition = ScreenPoint::ToScreenCoordinate(_ScreenSize, clippedEnd); int width = endPosition.X - startPosition.X; int height = endPosition.Y - startPosition.Y; // 완만한 경사(1, 4, 5, 8팔분면)인가? 아닌가(2, 3, 6, 7팔분면)? bool isGradualSlope = (Math::Abs(width) \u0026gt;= Math::Abs(height)); // x, y축의 진행방향 int dx = (width \u0026gt;= 0) ? 1 : -1; int dy = (height \u0026gt; 0) ? 1 : -1; int fw = dx * width; int fh = dy * height; // 경사에 따른 판별식 int f = isGradualSlope ? fh * 2 - fw : 2 * fw - fh; // 변화 없을 시 판별식에 적용할 값 int f1 = isGradualSlope ? 2 * fh : 2 * fw; // 변화 있을 시 판별식에 적용할 값 int f2 = isGradualSlope ? 2 * (fh - fw) : 2 * (fw - fh); // 최초 선 그리기 지점 int x = startPosition.X; int y = startPosition.Y; // 완만한 경사(1, 4, 5, 8) if (isGradualSlope) { while (x != endPosition.X) { SetPixel(ScreenPoint(x, y), InColor); if (f \u0026lt; 0) // 변화가 없는 경우 { f += f1; } else. // 변화가 있는 경우 { f += f2; y += dy; // 변화가 있을 때만 y가 이동한다. } x += dx; // 언제나 x는 이동한다. } } else // 급격한 경사(2, 3, 6, 7) { while (y != endPosition.Y) { SetPixel(ScreenPoint(x, y), InColor); if (f \u0026lt; 0) { f += f1; } else { f += f2; x += dx; // x, y가 완만한 경우와 반대이다. } y += dy; } } } 라인 클리핑 알고리즘 클리핑(Clipping) 선분이 가진 성질은 유지하면서 지정된 영역에 맞는 데이터로 재설정하는 작업이다. 코헨-서덜랜드 라인 클리핑 알고리즘(Cohen-Sutherland line clipping algorithm) 그릴 영역을 정 가운데에 두고 그 외의 바깥 영역을 포함해서 총 9개로 영역을 설정한다. 상위 두 비트는 상하 정보를, 하위 두 비트는 좌우 정보를 담아서 총 4자리의 이진수 값으로 고유한 값을 부여한다. 여기서 정 가운데의 0000이 눈에 보이는 화면 영역이다. 선분을 그릴 때 고려해야 할 상황은 세 가지로 나뉜다. (1) 화면 안에 위치해서 자를 필요가 없는 경우 시작점과 끝점 모두 0000이다. (2) 화면 밖에 위치해서 그릴 필요가 없는 경우 시작점과 끝점의 \u0026amp;연산 결과가 $0$보다 큰 값이 나온다. 혹은 $0$이 나올 때도 있다. 이 경우에는 클리핑을 한 후 다시 검사한다. (3) 화면을 가로질러서 화면에 유효한 영역으로 잘라내야 하는 경우 시작점과 끝점의 \u0026amp;연산 결과가 $0$이 나온다. 따라서 클리핑을 한다. 따라서 다음과 같이 구현해 볼 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 // 주어진 점의 영역값을 돌려준다. int TestRegion(const Vector2\u0026amp; InVectorPos, const Vector2\u0026amp; InMinPos, const Vector2\u0026amp; InMaxPos) { int result = 0; if (InVectorPos.X \u0026lt; InMinPos.X) { result = result | 0b0001; } else if (InVectorPos.X \u0026gt; InMaxPos.X) { result = result | 0b0010; } if (InVectorPos.Y \u0026lt; InMinPos.Y) { result = result | 0b0100; } else if (InVectorPos.Y \u0026gt; InMaxPos.Y) { result = result | 0b1000; } return result; } // 클리핑한다. bool CohenSutherlandLineClip(Vector2\u0026amp; InOutStartPos, Vector2\u0026amp; InOutEndPos, const Vector2\u0026amp; InMinPos, const Vector2\u0026amp; InMaxPos) { int startTest = TestRegion(InOutStartPos, InMinPos, InMaxPos); int endTest = TestRegion(InOutEndPos, InMinPos, InMaxPos); float width = (InOutEndPos.X - InOutStartPos.X); float height = (InOutEndPos.Y - InOutStartPos.Y); while (true) { if ((startTest == 0) \u0026amp;\u0026amp; (endTest == 0)) // 화면 안에 두 점이 있으면 바로 그리기 { return true; } else if (startTest \u0026amp; endTest) // 화면 밖에 선이 있으므로 그릴 필요가 없음 { return false; } else // 양쪽을 조사해 클리핑 진행 { Vector2 clippedPosition; bool isStartTest = (startTest != 0); int currentTest = isStartTest ? startTest : endTest; if (currentTest \u0026lt; 0b0100) { if (currentTest \u0026amp; 1) { clippedPosition.X = InMinPos.X; } else { clippedPosition.X = InMaxPos.X; } if (Math::EqualsInTolerance(height, 0.0f)) { clippedPosition.Y = InOutStartPos.Y; } else { clippedPosition.Y = InOutStartPos.Y + height * (clippedPosition.X - InOutStartPos.X) / width; } } else { if (currentTest \u0026amp; 0b0100) { clippedPosition.Y = InMinPos.Y; } else { clippedPosition.Y = InMaxPos.Y; } if (Math::EqualsInTolerance(width, 0.0f)) { clippedPosition.X = InOutStartPos.X; } else { clippedPosition.X = InOutStartPos.X + width * (clippedPosition.Y - InOutStartPos.Y) / height; } } // 클리핑한 결과로 다시 테스트 진행. if (isStartTest) { InOutStartPos = clippedPosition; startTest = TestRegion(InOutStartPos, InMinPos, InMaxPos); } else { InOutEndPos = clippedPosition; endTest = TestRegion(InOutEndPos, InMinPos, InMaxPos); } } } return true; } ","date":"2022-04-04T18:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-06/","title":"[Game Math] Chapter 6. 아핀 공간: 움직이는 가상 세계의 구축"},{"content":" 선형성: 예측 가능한 비례 관계 선형성(Linearity) 이란? 직선의 형태를 띠는 성질을 의미한다. 함수 $f$에 대해 다음 두 가지 조건을 만족하면 함수 $f$는 선형이라고 한다. (1) 가법성(Additivity) 임의의 수 $x_1$, $x_2$에 대해 $f(x_1 + x_2) = f(x_1) + f(x_2)$ (2) 1차 동차성(Homogeneity) 임의의 수 $x$, $k$에 대해 $f(kx) = kf(x)$ 선형 함수 직선의 함수 $f(x) = ax$의 경우 가법성: $f(x_1 + x_2) = f(x_1) + f(x_2)$ $a(x_1 + x_2) = ax_1 + ax_2$이므로, $a$, $x_1$, $x_2$가 모두 체의 성질을 가지는 실수라면 분배법칙이 성립해서 OK 1차 동시성: $f(kx) = kf(x)$ $a(kx) = k(ax)$이므로, $a$, $x$, $k$가 모두 체의 성질을 가지는 실수라면 체는 곱셈에 대해 결합법칙과 교환법칙이 성립하므로 OK 곡선의 형태를 띠는 $f(x) = x^2$의 경우 가법성: $f(x_1 + x_2) = f(x_1) + f(x_2)$ $x_1^2 + x_2^2 + 2x_1x_2 = x_1^2 x_2^2$이므로, NO 스칼라 $b$를 더해본 $f(x) = ax + b$의 경우 가법성: $f(x_1 + x_2) = f(x_1) + f(x_2)$ $ax_1 + ax_2 + b = ax_1 + b + ax_2 + b$이므로, NO 어째서 직선의 형태를 띰에도 선형성을 만족하지 않을까? 선형성이란 두 집합의 순수한 비로 구성된 1차적 대응 관계를 의미한다. 단지 곧게 뻗은 직선의 성질을 뜻하는 것이 아니다. 순수한 비로 구성되어 있기 때문에 다른 입력값을 투여했을 때 어떤 출력값이 나올지 쉽게 예측할 수 있고, 반대로 역함수($f(x) = \\frac{1}{a}x$)를 사용해서 출력값으로부터 입력값을 계산하는 것이 가능하다. 따라서 원점에서 벗어난 $f(x) = ax + b$의 경우 선형성을 만족하지 못한다. 벡터 공간의 선형 변환 그렇다면, 입력과 출력을 실수가 아닌 벡터를 넣어보자!\n선형성을 가지는 함수는 순수한 비의 형태로 구성되어 있으므로, $\\vec{v} = (x, y)$에서 $x$와 $y$에 선형성을 유지하고자 한다면 다음과 같이 설계해 볼 수 있겠다. $f(\\vec{v}) = f(x, y) = (ax + by, cx + dy)$\n이 식은 가법성과 1차 동차성을 만족하므로 선형성을 지닌다. (풀이 생략) 따라서 순수한 비를 통해 예측할 수 있는 형태로 변환되며, 역함수를 통해 변환 후의 벡터로부터 변환 전의 벡터를 파악할 수 있다. 표준기저벡터의 선형 결합으로 형성된 벡터 공간은 선형성을 지닌다. 그리고 이 벡터 공간을 위와 같은 선형 함수를 이용해서 변화시킨 새로운 공간도 표준기저벡터의 선형 결합으로 형성되므로 선형성을 지니겠다.\n이렇게 동일한 구조를 지니는 두 공간의 대응관계를 변환(Transformation)이라고 하며, 선형성을 유지시켜주는 위와같은 선형 함수를 선형 변환(Linear transformation) 이라고 한다. 스칼라 곱셈 $f(\\vec{v}) = f(x, y) = (kx, ky)$의 경우\n$(ax + by, cx + dy)$에다가 $a = k, b = 0, c = 0, d = k$를 대입한 것이므로, 선형변환이다. 벡터를 회전시키는 $f(\\vec{v}) = f(x, y) = (\\cos\\theta x - \\sin\\theta y, \\cos\\theta x + \\sin\\theta y)$의 경우\n$(ax + by, cx + dy)$에다가 $a = \\cos\\theta, b = - \\sin\\theta, c = \\cos\\theta, d = \\sin\\theta$를 대입한 것이므로, 선형변환이다. 게임 세계에서 모든 변환들은 선형 변환에 기초를 두고 있다. 이런 선형 변환의 계산 과정을 체계화해서 손쉽게 계산할 수 있다면 좋겠다! 그것이 바로 행렬(Matrix) 이다. 행렬 행렬은 수를 사각형의 형태로 행과 열을 맞춰 배열한 테이블이다.\n행렬로 벡터를 나타낼 수 있다.\n열벡터: $$ \\begin{bmatrix} x \\\\ y \\end{bmatrix} $$ 행벡터: $$ \\begin{bmatrix} x \u0026amp; y \\end{bmatrix} $$ 선형변환을 표현할 때는 행과 열의 크기가 같은 정방행렬(Square matrix) 을 사용한다.\n$f(x, y) = (ax + by, cx + dy)$의 경우에는 $$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix}$$과 같이 표현할 수 있겠다. 행렬의 기본 연산 반드시 알아야 하는 행렬의 연산들 (1) 행렬과 행렬의 덧셈 $$A + B = \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} + \\begin{bmatrix} e \u0026amp; f \\\\ g \u0026amp; h \\end{bmatrix} = \\begin{bmatrix} a+e \u0026amp; b+f \\\\ c+g \u0026amp; d+h \\end{bmatrix} $$ (2) 행렬과 스칼라의 곱셈 $$k \\cdot A = k \\cdot \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} = \\begin{bmatrix} k \\cdot a \u0026amp; k \\cdot b \\\\ k \\cdot c \u0026amp; k \\cdot d \\end{bmatrix} $$ (3) 행렬의 전치(Transpose of a matrix) 첨자 $T$으로 표시하며, 행과 열을 바꾸는 연산이다. $$\\begin{bmatrix} a \u0026amp; d \\\\ b \u0026amp; e \\\\ c \u0026amp; f \\end{bmatrix}^T = \\begin{bmatrix} a \u0026amp; b \u0026amp; c \\\\ d \u0026amp; e \u0026amp; f \\end{bmatrix}$$ (4) 행렬과 행렬의 곱셈 (행렬 곱) 행렬과 행렬의 곱셈 앞의 행벡터와 뒤의 열벡터를 각각 곱해서 더한다. $$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\cdot \\begin{bmatrix} e \u0026amp; f \\\\ g \u0026amp; h \\end{bmatrix} = \\begin{bmatrix} ae + bg \u0026amp; af + bh \\\\ ce + dg \u0026amp; cf + dh \\end{bmatrix}$$ 교환법칙이 성립하지 않는다. $A \\cdot B \\neq B \\cdot A$ 결합법칙이 성립한다. $A \\cdot (B \\cdot C) = (A \\cdot B) \\cdot C$ 행렬 곱을 전치한 결과는 순서를 바꾼 후 각각 전치해서 곱한 결과와 동일하다. $(A \\cdot B)^T = B^T \\cdot A^T$ 2차원 벡터에 선형 변환을 적용해서 새로운 벡터를 생성하는 작업. $f(x, y) = (ax + by, cx + dy)$ 를 표현하면 다음과 같다. $$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix}$$ 연산의 순서는 오른쪽에서 왼쪽으로 역방향으로 이루어짐을 알 수 있다. 정방행렬의 곱셈 $2 \\times 2$정방행렬 간의 곱은 합성함수에 대응되는 연산이다. 벡터 $\\vec{v}$에 선형 변환을 나타내는 $2 \\times 2$정방행렬 $A$, $B$를 순서대로 연산하는 것은 다음과 같다. $B \\cdot A \\cdot \\vec{v}$ 행렬의 곱셈은 결합법칙이 성립하기 때문에 컴퓨터 그래픽 연산에서 계산량을 크게 줄일 수 있다. 예를 들어, 100개의 점을 5번씩 선형 변환($A$, $B$, $C$, $D$, $E$)을 한다고 하면, $E \\cdot D \\cdot C \\cdot B \\cdot A \\cdot \\vec{v_1}$과 같은 작업이 100번 이루어지며, 총 500번의 행렬곱 연산이 필요하다. 하지만 $F = E \\cdot D \\cdot C \\cdot B \\cdot A$과 같이 합성함수에 해당하는 $F$를 미리 만들어 두면, $F \\cdot \\vec{v_1}$과 같이 점 당 한 번씩만 행렬곱을 하면 된다. 그래서 총 104번의 행렬곱 연산만 하면 된다. 열 기준 행렬과 행 기준 행렬 열 기준 행렬 역방향으로 연산된다. 사례: DirectX, Unity $$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix}$$ 행 기준 행렬 순방향으로 연산된다. 사례: OpenGL, Unreal 열 기준 행렬에 전치연산을 적용하면 된다. $(A \\cdot \\vec{v})^T = \\vec{v}^T \\cdot A^T$ $$\\begin{bmatrix} x \u0026amp; y \\end{bmatrix} \\cdot \\begin{bmatrix} a \u0026amp; c \\\\ b \u0026amp; d \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix}$$ 행렬의 설계 평면 상의 물체를 원하는 대로 변환하기 위해 $2 \\times 2$행렬을 설계해보자. 아래 그림과 같이 표준기저벡터를 변화시켜서 벡터와 선형 결합을 하면 $$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix}$$와 동일한 값을 가진다. 따라서 표준기저벡터를 변화시킨 벡터인 $(a, c)$와 $(b, d)$는 정방행렬을 구성하는 열벡터임을 알 수 있다. 크기 변환행렬 (Scale transformation matrix) 물체를 크기를 변경하는 행렬을 설계해보자. 표준기저벡터 $e_1$을 $a$배 늘리거나 줄인 벡터: $a \\cdot (1, 0) = (a, 0)$ 표준기저벡터 $e_2$을 $b$배 늘리거나 줄인 벡터: $b \\cdot (0, 1) = (0, b)$ 그렇다면 이 두 표준기저벡터를 열벡터로 설정하면 다음과 같은 크기 변환행렬을 만들 수 있겠다. $$S = \\begin{bmatrix} a \u0026amp; 0 \\\\ 0 \u0026amp; b \\end{bmatrix}$$ 회전 변환행렬 (Rotation transformation matrix) 물체를 각 $\\theta$만큼 회전시키는 행렬을 설계해보자. Chapter 4에서 살펴본 바와 같이 표준기저벡터가 $\\theta$만큼 회전한 결과는 $(\\cos\\theta, \\sin\\theta)$와 $(-\\sin\\theta, \\cos\\theta)$가 된다. 따라서 이 두 표준기저벡터를 열벡터로 설정해서 다음과 같은 회전 변환행렬을 만들 수 있겠다. $$R_\\theta = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix}$$ 전단 변환행렬 (Shear transformation matrix) 표준기저벡터 $e_1$은 고정한 상태에서 $e_2$를 $x$축 방향으로 $a$만큼 미는 변환을 생각해보자. 이러한 것을 전단변환이라고 하며, 전단변환행렬은 다음과 같을 것이다. $$S = \\begin{bmatrix} 1 \u0026amp; a \\\\ 0 \u0026amp; 1 \\end{bmatrix}$$ 삼각함수의 덧셈 정리 위 그림과 같이 $\\alpha$와 $\\beta$를 합한 만큼 회전한 행렬은 다음과 같이 나타낼 수 있다. $$R_(\\alpha + \\beta) = \\begin{bmatrix} \\cos(\\alpha + \\beta) \u0026amp; -\\sin(\\alpha + \\beta) \\\\ \\sin(\\alpha + \\beta) \u0026amp; \\cos(\\alpha + \\beta) \\end{bmatrix}$$ 여기서 $\\alpha + \\beta$의 회전변환은 $\\alpha$만큼 회전한 후, $\\beta$만큼 회전한 것과 같다. 따라서 다음과 같은 결과가 나온다. $$R_\\beta \\cdot R_\\alpha = \\begin{bmatrix} \\cos(\\beta) \u0026amp; -\\sin(\\beta) \\\\ \\sin(\\beta) \u0026amp; \\cos(\\beta) \\end{bmatrix} \\begin{bmatrix} \\cos(\\alpha) \u0026amp; -\\sin(\\alpha) \\\\ \\sin(\\alpha) \u0026amp; \\cos(\\alpha) \\end{bmatrix}$$ $$ = \\begin{bmatrix} \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta \u0026amp; -(\\cos\\alpha\\sin\\beta + \\sin\\alpha\\cos\\beta) \\\\ \\cos\\alpha\\sin\\beta + \\sin\\alpha\\cos\\beta \u0026amp; \\cos\\alpha\\cos\\beta-\\sin\\alpha\\sin\\beta \\end{bmatrix}$$ 여기서 삼각함수의 덧셈 정리를 얻을 수 있다. $\\cos(\\alpha + \\beta) = \\cos\\alpha\\cos\\beta- \\sin\\alpha\\sin\\beta$ $\\sin(\\alpha + \\beta) = \\cos\\alpha\\sin\\beta + \\sin\\alpha\\cos\\beta$ 추가적으로 삼각함수의 배각 공식은 각 $\\beta$대신 $\\alpha$를 대입해서 얻을 수 있다. $\\cos 2 \\alpha = 1 - 2 \\sin^2 \\alpha$ $\\sin 2 \\alpha = 2 \\sin \\alpha \\cos \\alpha$ 역행렬 행렬은 본질적으로 함수의 성질을 지니기 때문에 항등행렬과 역행렬이라는 개념이 존재한다.\n항등행렬(Identity matrix)\n원 공간의 변화없이 동일한 공간으로 유지하는 변환을 의미한다. 표준기저벡터 $(1, 0)$과 $(0, 1)$을 순서대로 넣어 만들 수 있다. $$I = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix}$$ 역행렬(Inverse matrix)\n행렬 곱의 결과가 항등행렬이 나오는 행렬을 의미한다. $A \\cdot A^{-1} = A^{-1} \\cdot A = I$ 역행렬을 시각적으로 나타내본다면, 아래 그림과 같이 선형 변환된 벡터 공간을 원 벡터 공간으로 다시 되돌리는 선형 변환이라고 볼 수 있다. 역행렬의 존재를 판별하는 성립식 역행렬 또한 함수이므로, 두 공간의 변환이 전단사로 대응될 때만 역행렬이 존재한다. 역행렬이 존재하는지 파악할 수 있는 특별한 수식이 있는 데 이것을. 행렬식(Determinant) 이라고 한다. $2 \\times 2$정방행렬 $A$의 행렬식은 다음과 같이 계산한다. $$A = \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix}$$ $det(A) = ad - bc$ $det(A)$의 값이 $0$인 선형 변환은 전단사 대응이 성립하지 않아서 역행렬이 존재하지 않는다. 행렬식이 $0$이라는 것의 의미는 무엇일까? 임의의 행렬 $$A = \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix}$$를 사용해서 표준기저벡터가 $(a, c)$와 $(b, d)$로 변환된 새로운 벡터 공간의 넒이는 어떻게 될까? 이 넓이 $Area(P)$는 전체 사각형의 넓이에서 평행사변형을 제외한 삼각형과 사각형을 빼서 구할 수 있으며, 결과적으로 행렬식과 동일하게 된다. $Area(P) = ad - bc$ 따라서 이 넓이가 $0$이라는 것은 2차원의 평면 영역이 1차원의 직선 영역으로 압축되었다는 것을 뜻하며, 그렇기 때문에 다시 2차원으로 돌아갈 수 없게된다. 행렬식이 음수가 나온다면? $ad - bc$에서 모든 수가 양수일 때 $a \u0026lt; b$이고, $d \u0026lt; c$이면 계산 결과는 음수가 나온다. 이것은 두 표준기저벡터가 엇갈리면서 평면이 뒤집힌 것이라고 볼 수 있다. 크기 변환행렬의 역행렬 $$S = \\begin{bmatrix} a \u0026amp; 0 \\\\ 0 \u0026amp; b \\end{bmatrix}$$ $$S^{-1} = \\begin{bmatrix} \\frac{1}{a} \u0026amp; 0 \\\\ 0 \u0026amp; \\frac{1}{b} \\end{bmatrix}$$ 전단 변환행렬의 역행렬 $$S = \\begin{bmatrix} 1 \u0026amp; a \\\\ 0 \u0026amp; 1 \\end{bmatrix}$$ $$S^{-1} = \\begin{bmatrix} 1 \u0026amp; -a \\\\ 0 \u0026amp; 1 \\end{bmatrix}$$ 회전 변환행렬의 역행렬 Chapter 4에서 보았던 $\\sin$, $\\cos$함수의 다음과 같은 성질을 사용해서 역행렬을 구할 수가 있겠다. $\\cos(-\\theta) = \\cos(\\theta)$ $\\sin(\\theta) = -\\sin(\\theta)$ $$R_{\\theta} = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix}$$ $$R_{\\theta}^{-1} = \\begin{bmatrix} \\cos\\theta \u0026amp; \\sin\\theta \\\\ -\\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix}$$ 이 결과는 전치행렬과 동일하므로, 회전 변환행렬의 역행렬은 전치연산을 적용하는 방법으로 쉽게 구할 수 있겠다. $R_{\\theta}^{-1} = R_{\\theta}^{T}$ 행렬 곱의 역행렬 행렬 곱은 합성 함수이므로 다음과 같은 수식이 성립한다. $(g \\circ f)^{-1} = f^{-1} \\circ g^{-1}$ $(A \\cdot B)^{-1} = B^{-1} \\cdot A^{-1}$ ","date":"2022-04-01T18:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-05/","title":"[Game Math] Chapter 5. 행렬: 가상 세계의 변환 도구"},{"content":" 삼각함수 삼각비(Trigonometric ratio) 직각삼각형을 구성하는 세 변에서, 직각이 아닌 각에 대한 두 변의 비례관계를 나타낸 것이다. 삼각비를 구하려면 꼭 직각삼각형이어야 하므로, $\\theta$는 늘 $0^\\circ$와 $90^\\circ$ 사이이다. 그렇다면 $90^\\circ$를 넘어서는 각에 대해서는 삼각비를 구할 수 없을까? 삼각함수(Trigonometric function)\n각의 크기를 삼각비로 나타내는 함수이다. 직각삼각형을 데카르트 좌표계 상에 배치하고, 사잇각의 범위를 실수 전체인 $\\mathbb{R^2}$집합으로 확장하였다. 반지름이 $1$인 원을 사용하면 삼각함수를 좀 더 쉽게 파악할 수 있다.\n$\\sin\\theta = \\frac{b}{1} = b$이고, $\\cos\\theta = \\frac{a}{1} = a$이므로, 원주 위의 모든 좌표는 $(\\cos\\theta, \\sin\\theta)$에 대응한다. 이것을 피타고라스 정리에 대입하면, $\\cos^2\\theta + \\sin^2\\theta = 1$과 같은 공식을 얻을 수 있다. 이번에는 반지름을 $r$으로 일반화시켜 생각해보자.\n벡터의 개념으로 생각했을 때, 길이가 $1$에서 $r$만큼 증가 했으므로, 스칼라 곱셈에 의해 $r\\cdot(\\cos\\theta, \\sin\\theta)$라는 좌표를 얻을 수 있다. 따라서 밑변과 높이는 각각 $r\\cdot\\cos\\theta$와 $r\\cdot\\sin\\theta$가 된다. 이것을 피타고라스 정리에 대입하면, $r^2(\\cos^2\\theta + \\sin^2\\theta) = r^2$이므로, 반지름 길이와 무관하게 $\\cos^2\\theta + \\sin^2\\theta = 1$식은 성립한다. 삼각함수의 성질 데카르트 좌표계에서의 각도란? $x$축에서 원의 궤적을 따라 반시계 방향으로 회전한 크기를 의미한다. 반지름이 $1$인 단위 원에서 반시계 방향의 회전을 생각해보자. 아직 회전하지 않은 상태에서 빗변 $\\vec{v}$는 $x$축에 위치하며, 좌표는 $(1, 0)$이다. 이것의 각도는 $0^\\circ$이겠다. 여기서 각도를 서서히 증가시키다면? $v_x$와 $v_y$의 변화량을 나타내면 아래 그림과 같을 것이다. 값의 변화는 $[-1, 1]$범위(진폭, Amplitude) 내에서 $360^\\circ$마다 반복(주기, Period)된다. 짝함수(Even function) $y$축을 기준으로 좌우를 접었을 때 $\\cos$함수와 같이 좌우 대칭인 함수. $\\cos(-\\theta) = \\cos(\\theta)$ 홀함수(Odd function) $\\sin$함수와 같이 원점 대칭인 함수. $\\sin(-\\theta) = -\\sin(\\theta)$ $\\tan$함수의 특징 빗변과 무관하게 밑변과 높이의 관계만을 나타낸다. $\\tan\\theta = \\frac{b}{a}$ 분자와 분모를 모두 빗변 값으로 나누면? $\\tan\\theta = \\frac{\\frac{b}{c}}{\\frac{a}{c}} = \\frac{\\sin\\theta}{\\cos\\theta}$ 분모의 값은 0이 될 수 없기 때문에, 분모인 $\\cos$함수의 값이 $0$이 되는 각도(예를 들면, $90^\\circ$)에서는 $\\tan$값이 존재하지 않는다. $\\sin$함수처럼 홀함수의 성질을 지닌다. 각의 측정법 각도법(Degree)\n우리가 일상생활에서 사용하듯이 $0$에서 $360$까지의 수를 사용하는 방법. 호도법(Radian)\n호의 길이를 기준으로 각을 측정하는 방법. 크기 1인 단위벡터를 사용해서 크기를 비교하는 것처럼, 호의 길이가 1이 되는 부채꼴의 각을 기준으로 각을 측정한다. 반원의 호길이는 $\\pi$이므로 다음과 같은 변환식을 만들 수 있다. $1^\\circ = \\frac{\\pi}{180} (rad)$ $1 (rad) = (\\frac{180}{\\pi})^\\circ$ 삼각함수를 활용한 물체의 회전 물체를 이동시키고, 크기를 늘리는 것은 $x$축과 $y$축이 서로 독립적으로 적용된다. 따라서 이 두 축을 서로 분리해서 따로 계산한 후 결합한 것과 동일하다. 하지만 회전은 $x$와 $y$값이 함께 영향을 미치기 때문에 분리해서 독립적으로 계산할 수 없다. 기저벡터 개념을 활용해서 회전시켜보자.\n$\\mathbb{R^2}$의 기저벡터 $e_1 = (1, 0)$과 $e_2 = (0, 1)$을 각 $\\theta$만큼 회전시키면?\n$e_1\u0026rsquo; = (\\cos\\theta, \\sin\\theta)$과 $e_2\u0026rsquo; = (-\\sin\\theta, \\cos\\theta)$가 될 것이다. $(1, 1)$에 위치한 벡터 $\\vec{v}$는 $\\vec{v} = 1 \\cdot e_1 + 1 \\cdot e_2$라고 표현할 수 있다.\n이 벡터를 $\\theta$만큼 회전시키면?\n$\\vec{v}\u0026rsquo; = 1 \\cdot (\\cos\\theta, \\sin\\theta) + 1 \\cdot (-\\sin\\theta, \\cos\\theta)$이며, 따라서 $\\vec{v}\u0026rsquo; = (\\cos\\theta - \\sin\\theta, \\sin\\theta + \\cos\\theta)$가 된다. 이것을 일반화시킨다면, $(x, y)$에 위치한 벡터를 $\\theta$만큼 회전한 $(x\u0026rsquo;, y\u0026rsquo;)$는 다음과 같다. $x\u0026rsquo; = x\\cos\\theta - y\\sin\\theta$ $y\u0026rsquo; = x\\sin\\theta + y\\cos\\theta$ 삼각함수의 역함수 벡터의 좌표를 가지고 대응하는 각도를 알아내는 법. 각 삼각함수의 정의역과 공역의 범위를 제한시키면 전단사함수를 만들 수 있다. 이것은 역함수도 구할 수 있다는 것을 의미한다. $\\sin$함수가 $\\theta$값이 주어졌을 때, 두 변의 비례관계를 구한다면, $\\arcsin$함수는 거꾸로 $\\sin$함수의 값인 두 변의 비례관계가 주어지면, 그것을 통해 $\\theta$ 값을 구할 수 있는 것이다. $\\sin^{-1}(x) = \\arcsin(x)$\n정의역: $[-90^\\circ, 90^\\circ]$ 공역: $[-1, 1]$ $\\cos^{-1}(x) = \\arccos(x)$\n정의역: $[0^\\circ, 180^\\circ]$ 공역: $[-1, 1]$ $\\tan^{-1}(x) = \\arctan(x)$\n정의역: $(-90^\\circ, 90^\\circ)$ 공역: 실수 영역 전체 $\\arctan$ 함수는 벡터의 각도를 구하는 데 유용하게 사용할 수 있다.\n$\\vec{v} = (x, y)$라는 임의의 벡터가 있을 때, $\\tan\\theta$는 $\\frac{y}{x}$이다. 이 값을 이용해서 $\\arctan$함수로 $\\theta$에 해당하는 각도값을 구할 수 있다. 하지만! $\\arctan$함수는 정의역이 $(-90^\\circ, 90^\\circ)$으로 한정되어 있다는 문제가 있다. 따라서 각 축인 $x$와 $y$를 따로 분리해서 전달하는 함수인 $atan2$함수를 사용한다. $atan2(y, x)$\n정의역: $[-180^\\circ, 180^\\circ]$ 공역: 실수 영역 전체 극좌표계 데카르트 좌표계\n앞에서 본 것처럼 회전을 구현하면 회전에 따른 $x$, $y$의 변화를 매번 계산하는 번거로움이 발생한다. 극좌표계(Polar coordinate system)\n$(r, \\theta)$ 원점으로부터의 거리 $r$과, 각 $\\theta$의 두 요소로 구성된다. 극좌표계는 원형공간의 특징을 지닌다. 따라서 스킬 쿨타임 아이콘 등 회전에 관련된 효과를 줄 때 많이 사용된다. 데카르트 좌표계에서 극좌표계로 변환\n$r = \\sqrt{x^2 + y^2}$ $\\theta = atan2(x, y)$ 극좌표계에서 데카르트 좌표계로 변환\n$x = r \\cdot \\cos\\theta$ $y = r \\cdot \\sin\\theta$ ","date":"2022-03-31T18:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-04/","title":"[Game Math] Chapter 4. 삼각함수: 회전을 위한 수학"},{"content":" 데카르트 좌표계 데카르트 좌표계(Cartesian coordinate system) Chapter 2에서 보았던 것처럼, 직선으로 된 수 집합을 수직으로 배치해서 평면을 표기하는 방식. 좌표(Coordinate) 데카르트 좌표계의 한 원소이다. 곱집합과 동일하게 순서쌍으로 표현한다. 벡터 공간과 벡터 스칼라와 벡터 벡터 공간(Vector space) 두 개 이상의 실수를 곱집합으로 묶어서 형성된 집합을 공리적 집합론의 관점에서 규정한 것. 벡터(Vector) 벡터 공간의 원소. $\\vec{v} = (x, y)$ 스칼라(Scalar) 체 구조를 가지는 수 집합의 원소. $x$, $y$ 벡터 공간의 연산 벡터 공간의 두 가지 기본 연산 (선형성이 있어서 선형 연산이라고 한다) (1) 벡터와 벡터의 덧셈(벡터의 합) (2) 스칼라와 벡터의 곱셈(스칼라 곱셈, 스칼라배) 벡터 공간의 8가지 공리 분류 공리 수식 벡터의 합 닫혀 있다 $\\vec{a}$, $\\vec{b}$가 벡터 공간 $V$에 존재하면 $\\vec{a} + \\vec{b}$도 $V$에 존재한다. 결합법칙 $\\vec{u} + (\\vec{v} + \\vec{w}) = (\\vec{u} + \\vec{v}) + \\vec{w}$ 교환법칙 $\\vec{u} + \\vec{v} = \\vec{v} + \\vec{u}$ 항등원 $\\vec{v} + \\vec{0} = \\vec{v}$ 역원 $\\vec{v} + (-\\vec{v}) = \\vec{0}$ 스칼라배 닫혀 있다 $\\vec{v}$가 벡터 공간 $V$에 존재하면 $a\\vec{v}$도 $V$에 존재한다. 결합법칙 $a(b\\vec{v}) = (ab)\\vec{v}$ 항등원 $1 \\cdot \\vec{v} = \\vec{v}$ (좌)분배법칙 $a(\\vec{u} + \\vec{v}) = a\\vec{u} + a\\vec{v}$ (우)분배법칙 $(a + b)\\vec{v} = a\\vec{v} + b\\vec{v}$ 벡터의 크기와 이동 벡터의 크기 피타고라스 정리를 사용해서 측정할 수 있다. $||\\vec{v}|| = \\sqrt{x^2 + y^2}$ 단위 벡터(Unit Vector) 크기가 1인 벡터. $\\hat{v} = \\frac{\\vec{v}}{||\\vec{v}||}$ 정규화(Normalize)한다. 임의의 벡터를 크기가 1인 단위 벡터로 다듬는 작업. 벡터의 결합과 생성 선형 결합(Linear combination) 벡터의 합과 스칼라배는 선형성이 있어서 선형 연산이라고도 한다. 이런 선형연산을 사용해서 $n$개의 스칼라 $a_1, \u0026hellip;, a_n$과 $n$개의 벡터 $\\vec{v_1}, \u0026hellip;, \\vec{v_n}$을 결합해 새로운 벡터 $\\vec{v\u0026rsquo;}$를 생성하는 수식을 선형 결합이라고 한다. $a_1\\vec{v_1} + a_2\\vec{v_2} + \u0026hellip; + a_n\\vec{v_n} = \\vec{v_n}$ 선형 종속 선형 결합에서 모든 $a$가 $0$이 아님에도 영벡터를 만들 수 있는 것. $2 \\cdot (1, 1) + (-1) \\cdot (2, 2) = (0, 0)$ 선형 독립 선형 결합에서 모든 $a$가 $0$이어야만 영벡터를 만들 수 있는 것. $0 \\cdot (1, 2) + 0 \\cdot (2, 1) = (0, 0)$ 선형 독립 관계를 가지는 벡터를 선형 결합하면, 벡터 공간에 속한 모든 벡터를 생성할 수 있다. 평면에서 선형 독립 관계를 유지하려면 2개의 벡터만 사용되어야 한다. 기저(Basis) 벡터 공간 내 모든 벡터를 생성할 수 있는, 선형 독립 관계를 가지는 벡터의 집합. 기저벡터(Basis vector) 기저에 속한 원소. 차원(Dimension) 평면에서 선형 독립 관계를 유지하려면 2개의 벡터만 사용되어야 한다. 기저 집합의 원소 수는 언제나 2개 뿐이다. 따라서 평면에 대응하는 벡터 공간을 2차원으로 정의할 수 있게 된다. 표준기저(Standard basis) 한 축만 사용하는 단위벡터로 구성된 집합. 표준기저벡터(Standard basis vector) 표준기저의 원소. 2차원 실벡터 공간 $\\mathbb{R}^2$ $e_1 = (1, 0)$ $e_2 = (0, 1)$ 3차원 실벡터 공간 $\\mathbb{R}^3$ $e_1 = (1, 0, 0)$ $e_2 = (0, 1, 0)$ $e_3 = (0, 0, 1)$ ","date":"2022-03-29T18:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-03/","title":"[Game Math] Chapter 3. 벡터: 가상 공간의 탄생"},{"content":" Item 3. 낌새만 보이면 const를 들이대 보자! const를 붙여서 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다. 포인터의 경우 1 2 3 4 5 6 7 8 9 10 char greeting[] = \u0026#34;Hello\u0026#34;; char *p = greeting; // 비상수 const char *p = greeting; // 상수 데이터 char const *p = greeting; // (이렇게 쓸 수도 있다) char * const p = greeting; // 상수 포인터 const char * const p = greeting; // 상수 포인터, 상수 데이터 STL 반복자의 경우 1 2 3 4 5 6 7 8 9 std::vector\u0026lt;int\u0026gt; vec; // T* const와 같다. const std::vector\u0026lt;int\u0026gt;::iterator iter = vec.begin(); *iter = 10; // const T*와 같다. std::vector\u0026lt;int\u0026gt;::const_iterator iter = vec.begin(); ++iter; 함수 선언의 경우 1 2 3 4 5 6 7 8 class Rational {}; const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); // 맨앞에 const는 Rational a, b, c; (a * b) = c; // (X) // 이런 말도 안되는 상황을 막는다. 멤버 함수의 경우 멤버 함수에 const를 쓰는 이유 (1) 인터페이스 이 함수에서 객체를 변경할 수 없다는 것을 알린다. (2) 상수 객체를 사용할 수 있게 한다. 보통 상수 객체가 생기는 경우는 포인터 혹은 참조자로 객체가 전달되는 경우이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class TextBlock { private: char* text; public: // 비상수 객체에 대한 operator[] char\u0026amp; operator[](std::size_t position) { return text[position]; } // 상수 객체에 대한 operator[] // 맨뒤의 const로 상수 객체에서 이 함수를 호출할 수 있게된다. // 또한 이 함수 내에서 객체를 변경할 수 없다. // 맨앞의 const로 대입이 불가능하게 된다. // ctb[0] = \u0026#39;x\u0026#39;; 가 안 된다. const char\u0026amp; operator[](std::size_t position) const { return text[position]; } }; void print(const TextBlock\u0026amp; ctb) { cout \u0026lt;\u0026lt; ctb[0]; // 상수 객체이므로, const 버전으로 호출한다. } 멤버 함수가 const라는 의미 (1) 비트 수준 상수성(bitwise constness), 물리적 상수성(physical constness) 그 객체를 구성하는 비트들 중 어떤 것도 바꾸면 안 된다는 것이다. (2) 논리적 상수성(logical constness) 일부 몇 비트 정도는 바꿀 수 있되, 그것을 사용자측에서 알아채지 못하게만 하면 상수 멤버 자격이 있다는 것이다. 하지만, 비트 수준 상수성을 갖추지 않으면 컴파일 되지 않는다. 따라서 mutable이라는 키워드가 등장했다. mutable 키워드로 선언한 데이터 멤버는 const함수에서도 수정이 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class TextBlock { private: char* text; mutable std::size_t textLength; mutable bool lengthIsValid; public: std::size_t length() const { if (!lengthIsValid) { // const 멤버 함수지만 // mutable로 선언된 데이터 멤버들은 수정할 수 있다. textLength = std::strlen(text); lengthIsValid = true; } return textLength; } } 상수 멤버와 비상수 멤버에서 코드 중복 피하기 비상수 버전이 상수 버전을 호출하도록 만든다. const를 붙이는 것은 안전한 타입 변환이므로 static_cast\u0026lt;\u0026gt;로 하고, const를 떼어내는 것은 const_cast\u0026lt;\u0026gt;밖에 없으므로 선택의 여지는 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class TextBlock { private: char* text; public: char\u0026amp; operator[](std::size_t position) { // const 버전을 호출한다. return const_cast\u0026lt;char\u0026amp;\u0026gt;( static_cast\u0026lt;const TextBlock\u0026amp;\u0026gt;(*this)[position] ); } const char\u0026amp; operator[](std::size_t position) const { // 여러가지 잡다한 작업들 // ... return text[position]; } }; const를 사용하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다.\n컴파일러는 비트수준 상수성을 지켜야 하지만, 우리는 논리적인 상수성을 사용해서 프로그래밍해야한다.\n상수 멤버와 비상수 멤버가 기능적으로 서로 똑같게 구현되어 있을 경우에는, 비상수 버전이 상수 버전을 호출하도록 한다.\nItem 4. 객체를 사용하기 전에 반드시 그 객체를 초기화하자 C++은 어떤 규칙들에 의해서 초기화가 되고 안 되고가 달라진다. 이런 규칙을 모두 새겨두기 보다는, 모든 객체를 사용하기 전에 항상 초기화하자. 대입과 초기화를 헷갈리지는 말자. 생성자에서 멤버 초기화 생성자 안에서 대입을 하는 것은 기본 생성자를 호출해서 초기화를 한 후, 또 대입을 하는 것이다. 대신 멤버 초기화 리스트를 사용하면 초기화 리스트에 들어가는 인자를 사용해서 복사 생성자를 한번 호출한다. C++의 규칙에 의하면 데이터 멤버는 생성자의 본문이 실행되기 전에 초기화되어야 한다고 되어 있다. 멤버 초기화 리스트를 사용하면 객체 생성 전에 초기화되는 것이다. 따라서 대부분의 경우 멤버 초기화 리스트가 효율적이다. 물론, 기본 제공 타입의 객체는 그 차이가 없지만, 초기화를 빠트리는 실수를 방지하기 위해서라도 멤버 초기화 리스트를 사용하자. 상수이거나 참조자인 데이터 멤버의 경우에는 반드시 초기화해야 하겠다. 순서는 데이터 멤버가 클래스 내부에서 선언된 순서이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class PhoneNumber {}; class ABEntry { private: // 여기에 선언된 순서로 초기화된다. std::string theName; std::string theAddress; std::list\u0026lt;PhoneNumber\u0026gt; thePhones; int numTimesConsulted; public: ABEntry(const std::string\u0026amp; name, const std::string address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones); }; // 이것은 대입이다. 초기화가 아니다. ABEntry::ABEntry(const std::string\u0026amp; name, const std::string address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones) { theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0; } // 멤버 초기화 리스트를 사용해서 초기화한다. ABEntry::ABEntry(const std::string\u0026amp; name, const std::string address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones) : theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0) { } 비지역 정적 객체의 초기화 정적 객체(static object) (1) 전역 객체 (2) 네임스페이스 유효범위에서 정의된 객체 (3) 클래스 안에서 static으로 선언된 객체 (4) 함수 안에서 static으로 선언된 객체 (5) 파일 유효범위에서 static으로 선언된 객체 지역 정적 객체(local static object) (4) 함수 안에서 static으로 선언된 객체를 지역 정적 객체라고 한다. 비지역 정적 객체(non-local static object) 나머지 번역 단위(translation unit) 컴파일을 통해 하나의 목적 파일을 만드는 바탕이 되는 소스 코드이다. 기본적으로 소스 파일 하나가 되는데, #include하는 파일들까지 합쳐서 하나의 번역 단위가 된다. 별개의 번역 단위에서 정의된 비지역 정적 객체들의 초기화 순서는 정해져 있지 않다. 이 사실 때문에 여러 번역 단위에 비지역 정적 객체들이 있을 때 초기화 문제가 생긴다. 1 2 3 4 5 6 7 8 class FileSystem { public: std::size_t numDisks() const; }; // 사용자가 쓰게 될 객체이다. extern FileSystem tfs; 1 2 3 4 5 6 7 8 9 10 11 class Directory { public: Directory(); }; Directory::Directory() { // tfs 객체를 사용한다. std::size_t disks = tfs.numDisks(); } 1 2 Directory tempDir(); // 만약 tfs가 먼저 초기화되지 않는다면 큰 문제가 발생할 것이다! 해결 방법 비지역 정적 객체를 지역 정적 객체로 바꾼다. 즉, 정적 객체 자체를 직접 사용하지 않고, 그 객체에 대한 참조를 반환하는 함수를 사용하는 것이다. 싱글톤 패턴(Singleton pattern)의 전형적인 구현 양식이다. 1 2 3 4 5 6 7 8 9 10 11 12 class FileSystem { public: std::size_t numDisks() const; }; FileSystem\u0026amp; tfs() // 클래스 안에 정적 멤버로 들어가도 된다. { // 지역 정적 객체를 정의한다. static FileSystem fs; return fs; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Directory { public: Directory(); }; Directory::Directory() { // tfs가 tfs()로 바뀌었다. std::size_t disks = tfs().numDisks(); } Directory\u0026amp; tempDir() { static Directory td; return td; } 다중 스레드 환경에서는\u0026hellip; 비상수 정적 객체는 지역 객체이든 비지역 객체이든 온갖 골치덩이가 된다. 따라서 경쟁 생태(race condition)를 없애주는 방법들을 사용해야 한다. (여기서는 다루지 않는다) 기본 제공 타입의 객체는 직접 손으로 초기화한다.\n생성자에서는 멤버 초기화 리스트를 즐겨 사용하자. 그리고 멤버가 선언된 순서와 똑같이 나열하자.\n여러 번역 단위에 비지역 정적 객체들이 있을 때는, 지역 정적 객체로 바꾸어 주자.\n","date":"2022-03-29T17:00:00+09:00","permalink":"https://sopod.github.io/p/effective-cpp-01-2/","title":"[Effective C++] Chapter 1. C++의 법을 따릅시다 (3, 4)"},{"content":" 수와 집합 수의 체계 기호 분류 정의 $\\mathbb{N}$ 자연수 1, 2, \u0026hellip; $\\mathbb{Z}$ 정수 \u0026hellip;, -2, -1, 0, 1, 2, \u0026hellip; $\\mathbb{Q}$ 유리수 분수로 나타낼 수 있는 수의 집합 $\\mathbb{I}$ 무리수 분수로 나타낼 수 없는 수의 집합 $\\mathbb{R}$ 실수 유리수와 무리수를 포함하는 수의 집합 $\\mathbb{C}$ 복소수 실수와 허수를 포함하는 수의 집합 $\\mathbb{H}$ 사원수 $a + bi + cj + dk$ $(i, j, k는 허수)$ 형태로 표현하는 수의 집합 이항연산의 특징 닫혀 있다(Closure) 같은 집합에 속한 두 수를 투입한 이항연산의 결과가 항상 투입한 집합에 속한다면, 그 이항연산은 해당 집합에 닫혀 있다고 한다. 교환법칙(Commutative law) 결합볍칙(Associative law) 분배법칙(Distributive law) 항등원(Identity) 어떤 수와 항등원과의 연산결과는 늘 그 어떤 수이다. 덧셈의 항등원: $a + 0 = a$ 곱셈의 항등원: $a \\cdot 1 = a$ 역원(Inverse) 어떤 수와 역원과의 연산결과는 늘 그 어떤 수의 항등원이다. 덧셈의 역원: $a + (-a) = 0$ (부호가 반대인 수, 반대수(Opposite number)) 곱셈의 역원: $a \\cdot \\frac{1}{a} = 1$ (역수(Reciprocal)) 공리(Axiom) 명제 중에서 증명할 필요가 없는 기본 명제 체(Field)의 구조를 지닌다. 공리적 집합론에서 두 연산에 대해 다음과 같은 공리를 모두 만족하는 수 집합. 따라서 체는 사칙연산이 자유로이 시행될 수 있는 수의 구조이다. 덧셈 연산에 대해 (1) 닫혀있다. (2) 덧셈 항등원($0$)이 존재한다. (3) 모든 성분에 대해 덧셈 역원이 존재한다. (4) 모든 성분에 대해 결합볍칙이 성립한다. (5) 모든 성분에 대해 교환법칙이 성립한다. 곱셈 연산에 대해 (6) 닫혀있다. (7) 곱셈 항등원이 존재한다. (8) $0$ 이외의 모든 성분에 대해 곱셈 역원이 존재한다. (9) $0$ 이외의 모든 성분에 대해 결합법칙이 성립한다. (10) $0$ 이외의 모든 성분에 대해 교환법칙이 성립한다. 덧셈과 곱셈 연산에 대해 (11) 덧셈에 대한 곱셈 연산의 분배법칙이 성립한다. 뺄셈과 나눗셈의 경우에는\u0026hellip; 뺄셈 대신 덧셈의 역원을 사용하고: $a + (-b) = (-b) + a$ 나눗셈 대신 곱셈의 역원을 사용하면 된다: $a \\cdot \\frac{1}{b} = \\frac{1}{b} \\cdot a$ 체의 구조를 만족하는 수집합은 유리수, 실수가 있다. 이 중에서 완벽한 연속성을 가지는 실수를 가지고 수직선 상에서 수를 표현할 수 있겠다. 방향: 부호 크기: 절대값 (원점으로부터의 거리) 함수 $f: X \\rightarrow Y$\n함수의 조건 (1) 첫 번째 집합의 모든 원소에 대한 대응 관계가 존재해야한다. (2) 첫 번째 집합의 원소는 두 번째 집합의 한 원소에만 대응되어야 한다. 함수 용어 정의역(Domain) 함수에서 왼쪽에 위치한 첫 번째 집합. (X) 공역(Codomain) 함수에서 오른쪽에 위치한 두 번째 집합. (Y) 치역(Range) 정의역에 대응되는 공역의 원소만 따로 모든 부분집합. 함수 종류 전사함수(Surjection) 공역의 모든 요소가 정의역에 대응되는 함수. 단사함수(Injection) 정의역과 공역의 요소가 1대1로 대응되는 함수. 전단사함수(Bijection) 정의역과 공역의 모든 요소가 빠짐없이 1대1로 대응되는 함수. 함수의 합성(Function composition) $f: X \\rightarrow Y$ $g: Y \\rightarrow Z$ 2개의 함수를 연쇄적으로 이어서 하나의 함수로 만드는 연산이다. $g \\circ f$ 혹은 $g(f(x))$로 표시한다. 먼저 실행되는 함수 $f$ 가 기호 $\\circ$ 의 오른쪽에 놓인다는 점에 유의하자. 합성 함수는 결합법칙이 성립한다. 항등함수(Identity function) 정의역과 공역이 동일한 값으로 대응되는 함수로 $id$ 로 나타낸다. 어느 위치에 있던 동일한 대응 관계를 나타낸다. $id \\circ f = f$, $ f \\circ id = f$ 역함수(Inverse function) 역함수와의 합성 함수의 대응 결과는 항등함수가 된다. $f^{-1}$ 로 나타낸다. 공역 $Y$ 에서 정의역 $X$로 대응되는 함수로도 생각할 수 있다. $f^{-1} \\circ f = id$, $f \\circ f^{-1} = id$ 모든 함수가 역함수를 갖지는 않는다. 역함수를 가지려면 반드시 전단사함수의 형태가 되어야 한다. 곱집합(Catesian product) $A \\times B$ 두 집합의 원소를 순서쌍으로 묶은 원소의 집합. 곱집합의 요소는 순서쌍으로 묶어서 표현한다. $(a, b)$ 서로 수직으로 배치하는 곱집합의 성질을 응용하면, 하나의 직선으로 표현한 실수 집합을 확장해서, 두 실수 집합의 곱집합을 평면으로 나타낼 수 있다. ","date":"2022-03-28T18:00:00+09:00","permalink":"https://sopod.github.io/p/game-math-02/","title":"[Game Math] Chapter 2. 수: 가상 세계를 구성하는 가장 작은 단위"},{"content":" Item 1. C++를 언어들의 연합체로 바라보는 안목을 필수 C++은 다중 패러다임 프로그래밍 언어(multiparadigm programming language)라고 불린다. C++을 단일 언어로 바라보는 눈을 넓혀서, 상관 관계가 있는 여러 언어들의 연합체(federation)로 보아야 한다. 특징 설명 C C++은 절차적(procedual) 프로그래밍 언어인 C를 기본으로 하고 있다. 객체 지향(object-oriented) 개념의 C++ 클래스를 쓰는 C라고 볼 수 있다. 클래스, 캡슐화, 상속, 다형성, 가상 함수 등이 포함된다. 템플릿 C++ 일반화(generic) 프로그래밍 부분이다. STL C++의 어떤 부분을 사용하느냐에 따라 효과적인 프로그래밍 규칙이 달라진다.\nItem 2. #define을 쓰려거든 const, enum, inline을 떠올리자 상수를 쓰는 경우 #define ASPECT_RATIO 1.653 #define은 컴파일 이전에 처리된다. 따라서 이미 숫자 상수로 대치된 코드에서 컴파일 에러라도 발생하면, 꽤나 헷갈릴 것이다. 해결법: 상수를 쓴다. const double AspectRatio = 1.653; 하지만 두 가지는 주의하자. (1) 상수 포인터의 경우 const를 두 번 사용하게 되겠다. const char * const authorName = \u0026quot;Scott Meyers\u0026quot;; (2) 클래스 멤버로 상수를 정의하는 경우. 사본 개수를 하나만 하고 싶다면 static 멤버로 만든다. 구식 컴파일러는 클래스 내에서 정적 클래스 상수를 초기화하는 것을 금지하기 때문에 구현 파일에서 정의를 해주어야 하겠다. 배열 크기 등, 컴파일 하는 도중에 클래스 상수의 값이 필요한데 구식 컴파일러라서 초기화가 안 된다면, enum을 사용해보자. 이것을 나열자 둔갑술(enum hack)이라고 한다. 만약 우리가 선언한 정수 상수의 주소를 얻는다던지, 참조를 하는 게 싫으면, 나열자 둔갑술이 좋은 선택이 될 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // 헤더 파일 class CostEstimate { private: // static const 멤버의 선언과 초기화 static const double FudgeFactor = 1.35; }; // 구현 파일 // 구식 컴파일러의 경우 정의에서 초기값을 준다. const double CostEstimate::FudgeFactor = 1.35; 1 2 3 4 5 6 class GamePlayer { private: enum { NumTurns = 5; } // 나열자 둔갑술 int scores[NumTurns]; // (O) }; 매크로 함수의 경우 #define CALL_WITH_MAX(a, b) f((a) \u0026gt; (b) ? (a) : (b)) 매크로 함수는 단점이 한 두개가 아니다. 괄호를 인자마다 쓰는 것은 물론이며, 다음과 같은 괴현상이 발생한다. 1 2 3 4 int a = 5, b = 0; CALL_WITH_MAX(++a, b); // a가 두 번 증가힌다. CALL_WITH_MAX(++a, b + 10); // a가 한 번 증가힌다. 해결법: 인라인 함수에 대한 템플릿을 만든다. 기존 매크로의 효율은 그대로 유지하면서 함수의 동작 방식 및 타입 안정성까지 완벽히 취한다. 1 2 3 4 5 template\u0026lt;typename T\u0026gt; inline void callWithMax(const T\u0026amp; a, const T\u0026amp; b) { f(a \u0026gt; b ? a : b); } 단순한 상수를 쓸 때는, #define보다 const객체 혹은 enum을 우선 생각하자.\n함수처럼 쓰이는 매크로를 만들려면, #define보다 인라인 함수를 우선 생각하자.\n","date":"2022-03-28T17:00:00+09:00","permalink":"https://sopod.github.io/p/effective-cpp-01-1/","title":"[Effective C++] Chapter 1. C++의 법을 따릅시다 (1, 2)"},{"content":" 람다 함수 랜덤한 정수들 중에서 얼마나 많은 수가 3으로, 13으로 나뉘는지 확인하고 싶다. 1. 함수 포인터\n1 2 3 4 5 6 7 8 9 10 11 bool F3(int x) { return (x % 3) == 0; } bool F13(int x) { return (x % 13) == 0; } int main() { vector\u0026lt;int\u0026gt; numbers(1000); generate(numbers.begin(), numbers.end(), rand); int count3 = count_if(numbers.begin(), numbers.end(), F3); int count13 = count_if(numbers.begin(), numbers.end(), F13); } 2. 펑크터\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class FMod { private: int dv; public: FMod(int d = 1) : dv(d) {} bool operator()(int x) { return (x % dv) == 0; } }; int main() { vector\u0026lt;int\u0026gt; numbers(1000); generate(numbers.begin(), numbers.end(), rand); int count3 = count_if(numbers.begin(), numbers.end(), FMod(3)); int count13 = count_if(numbers.begin(), numbers.end(), FMod(13)); } 3. 람다\n함수 이름이 []이 되었다. 반환 타입은 선언되지 않았다. decltype이 반환 값으로부터 추정된 타입이 반환 타입이 된다. 만약, 단일 구문을 반환하는 구조가 아니라서 반환 타입이 자동으로 결정되지 않는다면 반환 값을 추정하는 문법이 필요하다. 1 2 3 4 5 6 7 8 int main() { vector\u0026lt;int\u0026gt; numbers(1000); generate(numbers.begin(), numbers.end(), rand); int count3 = count_if(numbers.begin(), numbers.end(), [](int x){ return (x % 3) == 0; }); int count13 = count_if(numbers.begin(), numbers.end(), [](int x){ return (x % 13) == 0; }); } 1 2 [](int i)-\u0026gt;double { double d = i; return d - i; } // 반환 타입은 double형이다. 왜 람다를 쓰는가? 근접성 사용하는 곳 가까이에 정의하는 것이 유용하다. count_if() 함수 세 번째 매개변수가 호출하는 것이 무엇인지 코드를 스캔하고 싶지 않다. 간결함 람다에 이름을 생성하여 반복해 사용할 수 있다. auto mod3 = [](int x){ return (x % 3) == 0; }; 효율 인라인화가 되어 접근이 빠르다. 능력 범위 내에서 모든 자동화된 변수 이름으로 접근이 가능하다. [변수이름]으로 변수를 값으로 접근한다. [\u0026amp;변수이름]으로 변수를 참조로 접근한다. [\u0026amp;]으로 모든 자동화된 변수를 참조로 접근한다. [=]으로 모든 자동화된 변수를 값으로 접근한다. 혼합하여 사용하는 것도 가능하다. 1 2 int count3 = 0; for_each(numbers.begin(), numbers.end(), [\u0026amp;count3](int x){ count3 += ((x % 3) == 0); }); 1 2 3 int count3 = count13 = 0; for_each(numbers.begin(), numbers.end(), [\u0026amp;](int x){ count3 += ((x % 3) == 0); count13 += ((x % 13) == 0); }); 래퍼(Wrapper) 템플릿의 비효율성 많은 타입이 존재할 수 있는 가능성은 템플릿의 비효율성을 초래할 수 있다. 아래 예제와 같은 경우 F의 시그니처는 double (double)로 동일함에도 불구하고, UseFunction()의 인스턴스가 5개나 생성되었다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 template \u0026lt;typename T, typename F\u0026gt; T UseFunction(T v, F f) { static int count = 0; // static 변수로 얼마나 많은 인스턴스가 생성되는지 체크한다. count++; cout \u0026lt;\u0026lt; \u0026#34;UseFunction count = \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;, \u0026amp;count = \u0026#34; \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; return f(v); } class Fp { private: double z; public: Fp(double zz = 1.0) : z(zz) {} double operator()(double p) { return z * p; } }; class Fq { private: double z; public: Fq(double zz = 1.0) : z(zz) {} double operator()(double q) { return z + q; } }; double Double(double x) { return 2.0 * x; } double Square(double x) { return x * x; } int main() { double y = 1.21; cout \u0026lt;\u0026lt; \u0026#34;함수 포인터 Double:\\n\u0026#34;; // double (*) (double) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, Double) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;함수 포인터 Square:\\n\u0026#34;; // double (*) (double)로 같다. cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, Square) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;펑크터 Fp:\\n\u0026#34;; // Fp의 인스턴스 cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, Fp(5.0)) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;펑크터 Fq:\\n\u0026#34;; // Fq의 인스턴스 cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, Fq(5.0)) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;람다 표현식 1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, [](double u){return u * u; }) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;람다 표현식 2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, [](double u){return u + u / 2.0; }) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 함수 포인터 Double: UseFunction count = 1, \u0026amp;count = 001E03D8 2.42 함수 포인터 Square: UseFunction count = 2, \u0026amp;count = 001E03D8 1.4641 펑크터 Fp: UseFunction count = 1, \u0026amp;count = 001E03DC 6.05 펑크터 Fq: UseFunction count = 1, \u0026amp;count = 001E03E0 6.21 람다 표현식 1: UseFunction count = 1, \u0026amp;count = 001E03E4 1.4641 람다 표현식 2: UseFunction count = 1, \u0026amp;count = 001E03E8 1.815 함수 래퍼로 문제 해결 function\u0026lt;\u0026gt;템플릿은 같은 함수 시그내처를 갖는 함수 포인터, 펑크터, 람다 표현식을 포장하는데 사용한다. 아래 코드와 같은 경우, function\u0026lt;double(double)\u0026gt;을 사용하여 여섯 개의 래퍼를 생성한다. 이것은 F를 모두 같은 타입으로 만든다. 따라서 최종적으로 1개의 UseFunction()인스턴스만 만들어진다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 double y = 1.21; // 6개의 래퍼를 생성한다. function\u0026lt;double(double)\u0026gt; ef1 = Double; function\u0026lt;double(double)\u0026gt; ef2 = Square; function\u0026lt;double(double)\u0026gt; ef3 = Fq(5.0); function\u0026lt;double(double)\u0026gt; ef4 = Fp(5.0); function\u0026lt;double(double)\u0026gt; ef5 = [](double u){ return u * u; }; function\u0026lt;double(double)\u0026gt; ef6 = [](double u){ return u + u / 2.0; }; cout \u0026lt;\u0026lt; \u0026#34;함수 포인터 Double:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef1) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;함수 포인터 Square:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef2) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;펑크터 Fp:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef3) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;펑크터 Fq:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef4) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;람다 표현식 1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef5) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;람다 표현식 2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef6) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 함수 포인터 Double: UseFunction count = 1, \u0026amp;count = 00945660 2.42 함수 포인터 Square: UseFunction count = 2, \u0026amp;count = 00945660 1.4641 펑크터 Fp: UseFunction count = 3, \u0026amp;count = 00945660 6.21 펑크터 Fq: UseFunction count = 4, \u0026amp;count = 00945660 6.05 람다 표현식 1: UseFunction count = 5, \u0026amp;count = 00945660 1.4641 람다 표현식 2: UseFunction count = 6, \u0026amp;count = 00945660 1.815 typedef로 간소화한 표현이 가능하다. 1 2 3 4 5 6 7 double y = 1.21; typedef function\u0026lt;double(double)\u0026gt; fdd; //... cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, fdd(Double)) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; 템플릿 자체를 바꾸어 볼 수도 있다. 1 2 3 4 5 6 7 8 template \u0026lt;typename T\u0026gt; T UseFunction(T v, function\u0026lt;T(T)\u0026gt; f) { static int count = 0; count++; cout \u0026lt;\u0026lt; \u0026#34;UseFunction count = \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;, \u0026amp;count = \u0026#34; \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; return f(v); } 가변인자 템플릿 임의의 개수의 인자를 받는 함수를 만들 수는 없을까? 템플릿 매개변수 팩(Template parameter packs), 함수 매개변수 팩(Function parameter packs) 1 2 3 4 5 6 7 8 9 10 11 12 13 // ...는 0개 이상의 인자들을 나타낸다. template\u0026lt;typename... Args\u0026gt; // 템플릿 매개변수 팩 void Show(Args... args) // 함수 매개변수 팩 { } int main() { Show(); Show(\u0026#34;hello\u0026#34;); Show(4.5, 1, string(\u0026#34;str\u0026#34;), \u0026#39;c\u0026#39;); } 언패킹 팩(Unpacking a pack) 어떻게 팩의 내용을 언패킹할 수 있을까? 즉, Show()함수 내에서 어떻게 팩의 내용인 4.5, 1, string(\u0026quot;str\u0026quot;), c들을 접근할 수 있을까? 재귀(Recursion) 재귀를 적절하게 사용하면 팩의 아이템들에 접근할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template \u0026lt;typename T\u0026gt; void Show(T arg) // 마지막 매개변수에 대한 처리. { cout \u0026lt;\u0026lt; arg \u0026lt;\u0026lt; endl; } template \u0026lt;typename T, typename... Args\u0026gt; void Show(T arg, Args... args) { cout \u0026lt;\u0026lt; arg \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; Show(args...); // 첫번째 매개변수를 제외한 매개변수로 재귀적으로 호출한다. } int main() { int n = 14; double x = 2.71828; string mr = \u0026#34;Mr. String objects!\u0026#34;; Show(n, x); Show(x * x, \u0026#39;!\u0026#39;, 7, mr); } 1 2 14, 2.71828 7.38905, !, 7, Mr. String objects! ","date":"2022-03-27T13:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-18-2/","title":"[C++ Primer Plus] Chapter 18. (2) 람다 함수, 래퍼, 가변인자 템플릿"},{"content":" Move Semantics의 필요성 Move Semantics는 객체의 리소스(동적 할당된 메모리 같은 것)를 또 다른 객체로 이동하는 것을 의미한다. 만약 1,000자의 문자 string을 20,000개 가지고 있는 vector가 있다고 하자. 이것을 복사하면? vector 복사 생성자가 new를 이용해서 20,000개의 string 객체를 넣을 메모리를 만들어서 대입하고, string 복사 생성자가 또 new를 이용해서 1,000개의 문자를 넣을 메모리를 만들어서 대입한다. 그러면 총 20,000,000개의 문자가 복사된다. 하지만 굳이 이런 복사를 하지 않아도 되는 경우가 있다. 아래 예시 (2)의 경우가 그렇다. AllCaps()에서 임시 객체 temp를 생성하고 그리고 함수 종료 시 임시 객체를 삭제한다. 20,000,000개의 문자가 새로운 곳(copy2)에 저장되고 이전 저장소(temp)가 삭제되는 대신 문자가 남아 있는 자리에 이름만 copy2로 바꿔주면 어떨까? 이런 접근법을 Move Semantics라고 한다. Move Semantics을 위해서는\u0026hellip; rvalue 참조를 사용하는 이동 생성자를 만들어야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector\u0026lt;string\u0026gt; AllCaps(const vector\u0026lt;string\u0026gt;\u0026amp; vs) { vector\u0026lt;string\u0026gt; temp; // 매개변수로 전달된 vs를 모두 대문자로 만들어서 temp에 저장한다. return temp; } int main() { vector\u0026lt;string\u0026gt; strs; // strs가 1,000자의 문자 string을 20,000개 가지고 있다고 가정하자. vector\u0026lt;string\u0026gt; copy1(strs); // (1) vector\u0026lt;string\u0026gt; copy2(AllCaps(strs)); // (2) } 이동 생성자 및 이동 대입 연산자 예시 이동 생성자 Useless::Useless(Useless \u0026amp;\u0026amp; f) 매개변수로 전달된 f의 주소룰 가로채고, nullptr로 설정해준다. 이것은 소멸자가 같은 주소에 대해 두 번 delete []하는 것을 막는다. 이것을 pilfering(필퍼링, 좀도둑질)이라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 #include \u0026lt;iostream\u0026gt; using namespace std; class Useless { private: int n; // 매개변수 수 char* pc; // 데이터를 가리키는 포인터 static int ct; // 전체 객체 수 카운트 void ShowObject() const; public: Useless(); explicit Useless(int k); Useless(int k, char ch); Useless(const Useless\u0026amp; f); // 일반적인 복사 생성자 Useless(Useless\u0026amp;\u0026amp; f); // 이동 생성자 ~Useless(); Useless operator+(const Useless\u0026amp; f)const; Useless\u0026amp; operator=(const Useless\u0026amp; f); // 일반적인 복사 대입 연산자 Useless\u0026amp; operator=(Useless\u0026amp;\u0026amp; f); // 이동 대입 연산자 void ShowData() const; }; int Useless::ct = 0; Useless::Useless() { ++ct; n = 0; pc = nullptr; cout \u0026lt;\u0026lt; \u0026#34;기본 생성자 호출됨; 총 객체 수: \u0026#34; \u0026lt;\u0026lt; ct \u0026lt;\u0026lt; endl; ShowObject(); } Useless::Useless(int k) : n(k) { ++ct; cout \u0026lt;\u0026lt; \u0026#34;int 생성자 호출됨; 총 객체 수: \u0026#34; \u0026lt;\u0026lt; ct \u0026lt;\u0026lt; endl; pc = new char[n]; ShowObject(); } Useless::Useless(int k, char ch) : n(k) { ++ct; cout \u0026lt;\u0026lt; \u0026#34;int, char 생성자 호출됨; 총 객체 수: \u0026#34; \u0026lt;\u0026lt; ct \u0026lt;\u0026lt; endl; pc = new char[n]; for (int i = 0; i \u0026lt; n; i++) pc[i] = ch; ShowObject(); } Useless::Useless(const Useless\u0026amp; f) : n(f.n) // 일반적인 복사 생성자 { ++ct; cout \u0026lt;\u0026lt; \u0026#34;복사 생성자 호출됨; 총 객체 수: \u0026#34; \u0026lt;\u0026lt; ct \u0026lt;\u0026lt; endl; pc = new char[n]; for (int i = 0; i \u0026lt; n; i++) pc[i] = f.pc[i]; ShowObject(); } Useless::Useless(Useless\u0026amp;\u0026amp; f) : n(f.n) // 이동 생성자 { ++ct; cout \u0026lt;\u0026lt; \u0026#34;이동 생성자 호출됨; 총 객체 수: \u0026#34; \u0026lt;\u0026lt; ct \u0026lt;\u0026lt; endl; pc = f.pc; // 주소 가로채기 f.pc = nullptr; // 이전 객체가 아무것도 반환하지 않도록 함 f.n = 0; ShowObject(); } Useless::~Useless() { cout \u0026lt;\u0026lt; \u0026#34;소멸자 호출됨; 남은 객체 수: \u0026#34; \u0026lt;\u0026lt; --ct \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;삭제된 객체 정보: \u0026#34;; ShowObject(); delete[] pc; } Useless Useless::operator+(const Useless\u0026amp; f)const { cout \u0026lt;\u0026lt; \u0026#34;연산자 +() 진입\\n\u0026#34;; Useless temp = Useless(n + f.n); for (int i = 0; i \u0026lt; n; i++) temp.pc[i] = pc[i]; for (int i = n; i \u0026lt; temp.n; i++) temp.pc[i] = f.pc[i - n]; cout \u0026lt;\u0026lt; \u0026#34;연산자 +() 나옴\\n\u0026#34;; return temp; } Useless\u0026amp; Useless::operator=(const Useless\u0026amp; f) // 일반적인 복사 대입 연산자 { if (this == \u0026amp;f) return *this; delete[] pc; n = f.n; pc = new char[n]; for (int i = 0; i \u0026lt; n; i++) pc[i] = f.pc[i]; return *this; } Useless\u0026amp; Useless::operator=(Useless\u0026amp;\u0026amp; f) // 이동 대입 연산자 { if (this == \u0026amp;f) return *this; delete[] pc; n = f.n; pc = f.pc; // 주소 가로채기 f.pc = nullptr; // 이전 객체가 아무것도 반환하지 않도록 함 f.n = 0; return *this; } void Useless::ShowObject() const { cout \u0026lt;\u0026lt; \u0026#34;매개변수 수: \u0026#34; \u0026lt;\u0026lt; n; cout \u0026lt;\u0026lt; \u0026#34; 데이터 주소: \u0026#34; \u0026lt;\u0026lt; (void*)pc \u0026lt;\u0026lt; endl; } void Useless::ShowData() const { if (n == 0) cout \u0026lt;\u0026lt; \u0026#34;(객체 없음)\u0026#34;; else for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; pc[i]; cout \u0026lt;\u0026lt; endl; } int main() { { Useless one(10, \u0026#39;x\u0026#39;); cout \u0026lt;\u0026lt; endl; Useless two = one; // 복사 생성자 호출 cout \u0026lt;\u0026lt; endl; Useless three(20, \u0026#39;o\u0026#39;); cout \u0026lt;\u0026lt; endl; Useless four(one + three); // +()연산자와 이동 생성자 호출 cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;모든 객체 정보 표시해보기 \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;one: \u0026#34;; one.ShowData(); cout \u0026lt;\u0026lt; \u0026#34;two: \u0026#34;; two.ShowData(); cout \u0026lt;\u0026lt; \u0026#34;three: \u0026#34;; three.ShowData(); cout \u0026lt;\u0026lt; \u0026#34;four: \u0026#34;; four.ShowData(); cout \u0026lt;\u0026lt; endl; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int, char 생성자 호출됨; 총 객체 수: 1 매개변수 수: 10 데이터 주소: 01526730 복사 생성자 호출됨; 총 객체 수: 2 매개변수 수: 10 데이터 주소: 01526180 int, char 생성자 호출됨; 총 객체 수: 3 매개변수 수: 20 데이터 주소: 01529F50 연산자 +() 진입 int 생성자 호출됨; 총 객체 수: 4 매개변수 수: 30 데이터 주소: 01529F90 연산자 +() 나옴 이동 생성자 호출됨; 총 객체 수: 5 매개변수 수: 30 데이터 주소: 01529F90 소멸자 호출됨; 남은 객체 수: 4 삭제된 객체 정보: 매개변수 수: 0 데이터 주소: 00000000 모든 객체 정보 표시해보기 one: xxxxxxxxxx two: xxxxxxxxxx three: oooooooooooooooooooo four: xxxxxxxxxxoooooooooooooooooooo 소멸자 호출됨; 남은 객체 수: 3 삭제된 객체 정보: 매개변수 수: 30 데이터 주소: 01529F90 소멸자 호출됨; 남은 객체 수: 2 삭제된 객체 정보: 매개변수 수: 20 데이터 주소: 01529F50 소멸자 호출됨; 남은 객체 수: 1 삭제된 객체 정보: 매개변수 수: 10 데이터 주소: 01526180 소멸자 호출됨; 남은 객체 수: 0 삭제된 객체 정보: 매개변수 수: 10 데이터 주소: 01526730 강제 이동 이동 생성자와 이동 대입 연산자는 rvalue와 함께 동작한다. 하지만 lvalue와 함께 사용하고 싶을 때가 있다. 1 2 3 4 5 6 7 8 Useless choices[10]; Useless best; int pick; // 한 객체를 선택하고 pick 번째를 색인 하기 위한 설정... best = choices[pick]; // 이렇게 하나를 선택하고 이전 배열을 버린다면... // choices[pick]은 lvalue이지만 rvalue로 사용해서 이동 대입 연산자를 사용할 수 있다면 편리할 것이다. static_cast\u0026lt;\u0026gt;연산자를 이용해서 객체를 Useless\u0026amp;\u0026amp;타입으로 변환하면 가능하다. C++11에서는 이와 비슷한 방법을 제공한다. utility 헤더파일에 선언된 move()함수를 이용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Useless one(10, \u0026#39;x\u0026#39;); cout \u0026lt;\u0026lt; endl; Useless two; cout \u0026lt;\u0026lt; endl; two = one; // 복사 대입 cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;모든 객체 정보 표시해보기 \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;one: \u0026#34;; one.ShowData(); cout \u0026lt;\u0026lt; \u0026#34;two: \u0026#34;; two.ShowData(); cout \u0026lt;\u0026lt; endl; two = move(one); // 강제 이동 대입 cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;모든 객체 정보 표시해보기 \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;one: \u0026#34;; one.ShowData(); cout \u0026lt;\u0026lt; \u0026#34;two: \u0026#34;; two.ShowData(); cout \u0026lt;\u0026lt; endl; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //... 복사 대입 연산자 호출 모든 객체 정보 표시해보기 one: xxxxxxxxxx two: xxxxxxxxxx 이동 대입 연산자 호출 모든 객체 정보 표시해보기 one: (객체 없음) two: xxxxxxxxxx //... move()는 이동 대입 연산자를 호출한다. 만약 이동 대입 연산자를 정의하지 않았다면, 복사 대입 연산자를 사용한다. 그것도 정의하지 않았다면, 대입은 절대 허용되지 않는다. 새로운 클래스 형태 복사 생성자, 복사 대입 연산자를 제공한다면,\n컴파일러는 이동 연산자나 이동 대입 연산자를 자동으로 제공하지 않는다. 반대로, 이동 연산자나 이동 대입 연산자를 제공한다면,\n컴파일러는 복사 생성자나 복사 대입 연산자를 제공하지 않는다. 기본 함수, 삭제 함수 default 키워드 컴파일러가 생성하는 기본 함수를 사용하고자하는 경우 delete 키워드 컴파일러가 특정 함수를 사용하는 것을 방지하고자 하는 경우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Someclass { public: // 컴파일러가 생성한 기본 생성자를 사용한다. Someclass() = default; // 복사 생성자와 복사 대입 연산자를 사용할 수 없다. Someclass(const Someclass\u0026amp;) = delete; Someclass\u0026amp; operator=(const Someclass\u0026amp;) = delete; // 컴파일러가 생성한 이동 생성자와 이동 대입 연산자를 사용한다. Someclass(Someclass\u0026amp;\u0026amp;) = default; Someclass\u0026amp; operator=(Someclass\u0026amp;\u0026amp;) = default; Someclass\u0026amp; operator+(const Someclass\u0026amp;) const; }; int main() { Someclass one; Someclass two; Someclass three(one); // (X) lvalue는 허용하지 않는다. Someclass four(one + two); // (O) rvalue는 허용한다. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Someclass { public: // delete키워드로 특정 변환을 막을 수 있다. void DoSomething(int) = delete; void DoSomething(double); }; int main() { Someclass one; one.DoSomething(1); // (X) 컴파일 에러 one.DoSomething(1.1); // (O) } 위임 생성자 다른 생성자의 정의의 일부를 생성자로 사용할 수 있도록 한 것이다. 한 생성자가 임시로 다른 생성자가 생성한 객체에 책임을 전가하기 때문에 위임(delegation)이라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Notes { private: int i; double d; string st; public: Notes(); Notes(int); Notes(int, double); Notes(int, double, string); }; Notes::Notes(int ii, double dd, string stt) : i(ii), d(dd), st(stt) { } Notes::Notes() : Notes(0, 0.0, \u0026#34;\u0026#34;) { } Notes::Notes(int ii) : Notes(ii, 0.0, \u0026#34;\u0026#34;) { } Notes::Notes(int ii, double dd) : Notes(ii, dd, \u0026#34;\u0026#34;) { } 상속 생성자 파생 클래스에서 기본 클래스의 모든 생성자를 사용할 수 있다. 상속된 기본 클래스 생성자는 오직 기본 클래스 멤버만을 초기화한다는 것을 명심하라. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Base { private: int i; double d; public: Base() : i(0), d(0.0) {} Base(int ii) : i(ii), d(0.0) {} Base(double dd) : i(0), d(dd) {} Base(int ii, double dd) : i(ii), d(dd) {} }; class Derived : public Base { private: short s; public: using Base::Base; // Base 클래스의 생성자를 사용할 수 있다. Derived() : s(0) {} Derived(double dd) : Base(dd), s(0) {} Derived(int ii) : Base(ii), s(0) {} }; int main() { Derived derived(10, 1.8); // Derived에 (int, double) 생성자가 없으므로 // Base(int, double)을 사용한다. // 당연히 Derived의 멤버는 초기화되지 않는다. } 가상 함수 관리 가상 지정자 override를 사용함으로써 가상 함수를 오버라이드 하겠다는 것을 명시할 수 있다. 선언이 기본 함수와 일치하지 않았을 때, override를 사용하지 않으면 단순히 기본 함수를 숨기기만 한다. 하지만 override를 사용하면 컴파일 에러가 난다. 지정자 final은 파생 클래스에서 재정의할 수 없는 가상 함수를 지정한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Base { public: virtual void Function(int ch) const // int형 매개변수 { cout \u0026lt;\u0026lt; \u0026#34;Base\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: virtual void Function(int* ch) const // int*형 매개변수 (다르다) { cout \u0026lt;\u0026lt; \u0026#34;Derived\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { int num = 1; Derived d; d.Function(\u0026amp;num); // (O) Derived의 Function이 Base의 Function를 숨긴다. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Base { public: virtual void Function(int ch) const // int형 매개변수 { cout \u0026lt;\u0026lt; \u0026#34;Base\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: // (X) override 지정자를 사용했다. 매개변수가 기본 함수와 달라서 컴파일 에러가 난다. virtual void Function(int* ch) const override { cout \u0026lt;\u0026lt; \u0026#34;Derived\u0026#34; \u0026lt;\u0026lt; endl; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Base { public: virtual void Function(int ch) const final // final 지정자 { cout \u0026lt;\u0026lt; \u0026#34;Base\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: virtual void Function(int ch) const // (X) final인 함수를 오버라이드할 수 없다. { cout \u0026lt;\u0026lt; \u0026#34;Derived\u0026#34; \u0026lt;\u0026lt; endl; } }; ","date":"2022-03-27T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-18-1/","title":"[C++ Primer Plus] Chapter 18. (1) Move Semantics와 rvalue참조, 새로운 클래스 형태"},{"content":" 알고리즘(algorithm) 알고리즘 컨테이너와 함께 사용할 수 있는 멤버가 아닌 함수들이다. 알고리즘 함수를 설계하는 주요 두 가지 일반화 성분들이 있다. 일반형을 제공하기 위해 템플릿을 사용한다. 컨테이너에 들어 있는 데이터에 접근하기 위한 일반화 표현을 제공하기 위해 이터레이터를 사용한다. STL은 알고리즘 라이브러리를 네 그룹으로 나눈다. 처음 세 그룹은 algorithm 헤더 파일, 네 번째 그룹은 numeric 헤더 파일에 정의되어 있다. (1) 변경 불가 시퀀스 연산 어떤 범위에 들어 있는 각 원소에 작용한다. 이 연산은 컨테이너를 변경하지 않는다. find(), for_each() (2) 변경 가능 시퀀스 연산 어떤 범위에 들어 있는 각 원소에 작용한다. 이 연산은 컨테이너를 변경한다. transform(), random_shuffle(), copy() (3) 정렬 및 그와 관련된 연산 sort() (4) 일반화한 수치 연산 어떤 범위에 있는 내용들을 더하고, 두 컨테이너의 내적, 부분합, 인접차를 계산하는 등의 함수들이 있다. 일반적으로 이 연산들은 배열의 특성을 가지므로 vector 컨테이너가 가장 잘 어울린다. 이터레이터와 이터레이터 범위를 사용한다. 템플릿 매개변수와 이름을 통해 그 매개변수가 모델링하는 개념을 나타낸다. 따라서 아래 선언에 따르면, 범위 매개변수들이 입력 이터레이터 또는 그 이상이 되어야 하며, 결과를 넣을 위치를 나타내는 이터레이터가 출력 이터레이터 그 이상이 되어야 한다는 사실을 알 수 있다. 1 2 template\u0026lt;class InputIterator, class OutputIterator\u0026gt; OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result); 알고리즘을 분류하는 또 다른 방법은, 알고리즘의 결과가 제자리에 놓이는지, 아니면 새로운 곳에 놓이는지에 따라 분류하는 것이다. (1) 제자리 알고리즘(in-place algorithm) (2) 복사 알고리즘(copying algorithm) 예를 들어, sort()함수는 결과가 오리지널 데이터가 있던 곳에 그대로 위치하기 때문에 제자리 알고리즘(in-place algorithm)이다. 그러나 copy()함수는 결과가 다른 위치에 저장되므로, 복사 알고리즘(copying algorithm)이다. transform()함수는 둘 다 가능하다. 어떤 함수는 두 가지 버전을 갖고 있다. 복사 버전은 이름에 _copy를 붙이는 것이 관행이다. 예를 들어, replace()함수가 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 template\u0026lt;class ForwardIterator, class T\u0026gt; void replace(ForwardIterator first, ForwardIterator last, const T\u0026amp; old_value, const T\u0026amp; new_value); // 제자리 알고리즘. // old_value의 각 인스턴스를 new_value로 바꾼다. template\u0026lt;class InputIterator, class OutputIterator, class T\u0026gt; OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T\u0026amp; old_value, const T\u0026amp; new_value); // 복사 알고리즘. // 복사 알고리즘의 관행은, // 마지막으로 복사된 값 바로 다음 위치를 지시하는 이터레이터를 리턴하는 것이다. 일부 함수들은 조건부에 따라 동작을 수행하는 버전을 가진다. 함수 이름에 if를 붙이는 것이 관행이다. 1 2 3 4 5 template\u0026lt;class ForwardIterator, class Predicate, class T\u0026gt; void replace(ForwardIterator first, ForwardIterator last, Predicate pred, const T\u0026amp; new_value); // 조건(predicate)은 bool값을 리턴하는 단항 함수이다. STL과 string 클래스 string 클래스는 STL을 염두해 두고 설계되어 있다. 그래서 STL 인터페이스를 사용할 수 있다. 예를 들어, next_permutation() 함수를 사용해서 글자들이 형성하는 순열을 만들 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 string letters; cout \u0026lt;\u0026lt; \u0026#34;글자를 입력하세요. (quit to quit): \u0026#34;; while (cin \u0026gt;\u0026gt; letters \u0026amp;\u0026amp; letters != \u0026#34;quit\u0026#34;) { cout \u0026lt;\u0026lt; letters \u0026lt;\u0026lt; \u0026#34;의 모든 치환들: \u0026#34; \u0026lt;\u0026lt; endl; sort(letters.begin(), letters.end()); cout \u0026lt;\u0026lt; letters \u0026lt;\u0026lt; endl; // next_permutation은 더 큰 순열로 재배열을 할 수 있으면 반복하여 구해내는 구조이므로 // 앞에 이미 큰 원소들이 배치되어 있으면 반복하지 않게 된다. // 따라서 오름차순으로 정렬을 해준다. while (next_permutation(letters.begin(), letters.end())) cout \u0026lt;\u0026lt; letters \u0026lt;\u0026lt; endl; // next_permutation은 범위에 있는 내용의 고유한 그 다음 순열을 제공한다. cout \u0026lt;\u0026lt; \u0026#34;다음 글자를 입력하세요. (quit to quit): \u0026#34;; } STL 메서드와 STL 함수 중에서 어느 것을 사용해야 할까? 일반적으로 메서드가 더 낫다. 그 이유는\u0026hellip; 특별한 컨테이너를 위해 최적화되어있기 때문이다. 멤버 함수이기 때문에 템플릿 클래스의 메모리 관리 기능을 이용할 수 있고, 필요한 경우 컨테이너 크기를 조절할 수 있다. 예를 들어, remove() 메서드와 함수를 비교해 볼 수 있겠다. remove 함수는 멤버가 아니라서 크기를 조절할 수 없다. 대신에 남아 있는 원소들을 리스트의 앞쪽에다 놓는다. 그리고 남아 있는 원소들의 새로운 past-the-end을 지시하는 이터레이터를 리턴한다. 이 이터레이터를 사용해서 리스트의 크기를 조절할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // remove 메서드 사용 list\u0026lt;int\u0026gt; li = {1, 4, 1, 4, 4, 4}; li.remove(4); cout \u0026lt;\u0026lt; li.size() \u0026lt;\u0026lt; endl; // 크기가 자동으로 줄어들어서 2 // remove 함수 사용 list\u0026lt;int\u0026gt; li2 = {1, 4, 1, 4, 4, 4}; list\u0026lt;int\u0026gt;::iterator last; last = remove(li2.begin(), li2.end(), 4); cout \u0026lt;\u0026lt; li2.size() \u0026lt;\u0026lt; endl; // 크기가 그대로 6 li2.erase(last, li2.end()); // 뒤를 지운다. cout \u0026lt;\u0026lt; li2.size() \u0026lt;\u0026lt; endl; // 크기가 2 STL 사용하기 예시 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 char toLower(char ch) { return tolower(ch); } string\u0026amp; ToLower(string\u0026amp; st) { transform(st.begin(), st.end(), st.begin(), toLower); return st; } void display(const string\u0026amp; s) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } int main() { // vector 컨테이너: 입력을 저장한다. vector\u0026lt;string\u0026gt; words; cout \u0026lt;\u0026lt; \u0026#34;단어 입력 (enter quit to quit) :\\n\u0026#34;; string input; while (cin \u0026gt;\u0026gt; input \u0026amp;\u0026amp; input != \u0026#34;quit\u0026#34;) words.push_back(input); cout \u0026lt;\u0026lt; \u0026#34;다음과 같은 단어들을 입력하셨습니다. :\\n\u0026#34;; for_each(words.begin(), words.end(), display); cout \u0026lt;\u0026lt; endl; // set 컨테이너: 유일하며, 순서대로 저장되는 단어들. set\u0026lt;string\u0026gt; wordset; transform(words.begin(), words.end(), insert_iterator\u0026lt;set\u0026lt;string\u0026gt;\u0026gt;(wordset, wordset.begin()), ToLower); cout \u0026lt;\u0026lt; \u0026#34;\\n단어들의 알파벳순 리스트 :\\n\u0026#34;; for_each(wordset.begin(), wordset.end(), display); cout \u0026lt;\u0026lt; endl; // map 컨테이너: 키를 단어로 하고, 값을 단어의 빈도로 한다. map\u0026lt;string, int\u0026gt; wordmap; set\u0026lt;string\u0026gt;::iterator si; for (si = wordset.begin(); si != wordset.end(); si++) wordmap[*si] = count(words.begin(), words.end(), *si); cout \u0026lt;\u0026lt; \u0026#34;\\n단어별 빈도 :\\n\u0026#34;; for (si = wordset.begin(); si != wordset.end(); si++) cout \u0026lt;\u0026lt; *si \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; wordmap[*si] \u0026lt;\u0026lt; endl; } 기타 라이브러리 vector와 valarray 그리고 array valarray STL의 일부가 아니다. 자동 크기 조절이 안 된다. 그리고 삽입, 정렬, 검색 등과 같은 것들을 하기 위한 메서드가 없다. 하지만 수학 연산에 대한 명쾌한 표기상의 이점을 가지고 있다. array 기존 배열형을 대체하기 위해 설계되었다. 다양한 STL 메서드들을 지원한다. 따라서 알고리즘을 쉽게 적용할 수 있다. vector 컨테이너 클래스와 알고리즘으로 구성되었다. 정렬, 삽입, 재배치, 검색, 다른 컨테이너로의 데이터 전송 등과같은 컨테이너 지향적인 액티비티를 지원한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 vector\u0026lt;int\u0026gt; vec = { 1, 2, 5, 4, 3 }; int temp; int size = vec.size(); valarray\u0026lt;int\u0026gt; valArr(size); for (int i = 0; i \u0026lt; size; i++) // vector의 내용을 valarray로 옮긴다. valArr[i] = vec[i]; // vector는 정렬 알고리즘 sort()를 사용할 수 있다. sort(vec.begin(), vec.end()); // C++11에서는 이렇게 valarray에 sort()를 사용할 수 있다. sort(begin(valArr), end(valArr)); // valarray는 간단하게 한 문장으로 배열을 연산할 수 있다. valarray\u0026lt;int\u0026gt; sq_rts(size); sq_rts = sqrt(valArr); valarray\u0026lt;int\u0026gt; results(size); results = valArr + 2 * sq_rts; // vector는 이런 방식으로 해야된다. vector\u0026lt;int\u0026gt; result(size); transform(vec.begin(), vec.end(), result.begin(), bind1st(plus\u0026lt;int\u0026gt;(), 2)); slice() 객체는 배열 인덱스로 사용할 수 있다. 일반적으로 하나의 값이 아니라, 값들로 이루어진 부분 집합을 나타낸다. 세 개의 정수 start, number, stride 값으로 초기화된다. 첫 인덱스인 start부터 시작해서 stride 값을 더하면서 총 number 개의 원소를 뽑아낸다. 이것은 1차원 valarray 객체를 사용해서 2차원 데이터를 나타내는 것을 허용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // valarray를 출력한다. // cols는 열의 개수이다. 이 개수에 따라 띄어쓴다. void show(const valarray\u0026lt;int\u0026gt;\u0026amp; v, int cols) { int lim = v.size(); for (int i = 0; i \u0026lt; lim; ++i) { cout.width(3); cout \u0026lt;\u0026lt; v[i]; if (i % cols == cols - 1) cout \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } if (lim % cols != 0) cout \u0026lt;\u0026lt; endl; } int main() { valarray\u0026lt;int\u0026gt; valint = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; // 4행 3열로 생각한다. cout \u0026lt;\u0026lt; \u0026#34;원래의 배열 :\\n\u0026#34;; show(valint, 3); // 3열로 출력한다. valarray\u0026lt;int\u0026gt; vcol(valint[slice(1, 4, 3)]); // 1, 4, 7, 10이며 이것은 두 번째 열이다. cout \u0026lt;\u0026lt; \u0026#34;2열을 출력한다. :\\n\u0026#34;; show(vcol, 1); // 1열로 출력한다. valarray\u0026lt;int\u0026gt; vrow(valint[slice(3, 3, 1)]); // 3, 4, 5이며 이것은 두 번째 행이다. cout \u0026lt;\u0026lt; \u0026#34;2행을 출력한다. :\\n\u0026#34;; show(vrow, 3); valint[slice(2, 4, 3)] = 10; // 2, 5, 8, 11이며 이것은 세 번째 열이다. cout \u0026lt;\u0026lt; \u0026#34;3열을 10으로 설정한다. :\\n\u0026#34;; show(valint, 3); cout \u0026lt;\u0026lt; \u0026#34;1열의 2열과 3열의 합으로 만든다. :\\n\u0026#34;; valint[slice(0, 4, 3)] // 0, 3, 6, 9 즉 1열을 2열과 3열의 합으로 만든다. = valarray\u0026lt;int\u0026gt;(valint[slice(1, 4, 3)]) + valarray\u0026lt;int\u0026gt;(valint[slice(2, 4, 3)]); show(valint, 3); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 원래의 배열 : 0 1 2 3 4 5 6 7 8 9 10 11 2열을 출력한다. : 1 4 7 10 2행을 출력한다. : 3 4 5 3열을 10으로 설정한다. : 0 1 10 3 4 10 6 7 10 9 10 10 1열의 2열과 3열의 합으로 만든다. : 11 1 10 14 4 10 17 7 10 20 10 10 initializer_list 템플릿 (C++11) 컨테이너 클래스가 initializer_list\u0026lt;T\u0026gt; 매개변수를 취하는 생성자를 지녔기 때문에 다음과 같은 초기화가 가능해진다. 만약 클래스가 다양한 크기의 리스트를 처리하지 못할 경우에는 initializer_list 생성자를 제공하는 것은 부적합하다. 1 2 3 4 5 6 7 8 9 10 vector\u0026lt;double\u0026gt; vec1 {1.2, 3.2, 4.4}; // (O) // 위의 코드는 다음과 같이 동작하는 것이다. vector\u0026lt;double\u0026gt; vec1 ({1.2, 3.2, 4.4}); vector\u0026lt;int\u0026gt; vec2(10) // 원소 10개를 가진 벡터를 생성한다. vector\u0026lt;int\u0026gt; vec3{10} // 10이라는 원소 1개를 가진 벡터를 생성한다. vector\u0026lt;int\u0026gt; vec4{ 1.2 }; // (X) narrowing. 컴파일링 시간 에러 발생. vector\u0026lt;double\u0026gt; vec5{ 1 }; // (O) 1은 double인 1.0으로 전환된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Position { private: int x, y, z; public: Position(int nx, int ny, int nz) : x(nx), y(ny), z(nz) {} // 고정된 크기이므로 initializer_list 생성자가 없다. }; int main() { Position p{ 1, 2, 3 }; // (O) Position(int, int, int) 생성자를 호출한다. } initializer_list 사용 예제 begin(), end(), size()를 갖고 있다. 이터레이터형은 상수형이므로 목록 안의 값을 바꿀 수 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 double Sum(initializer_list\u0026lt;double\u0026gt; il) { double tot = 0; for (auto p = il.begin(); p != il.end(); p++) tot += *p; return tot; } double Average(const initializer_list\u0026lt;double\u0026gt;\u0026amp; ril) { double tot = 0; int n = ril.size(); double ave = 0.0; if (n \u0026gt; 0) { for (auto p = ril.begin(); p != ril.end(); p++) tot += *p; ave = tot / n; } return ave; } int main() { cout \u0026lt;\u0026lt; \u0026#34;목록 1: Sum = \u0026#34; \u0026lt;\u0026lt; Sum({ 2,3,4 }) \u0026lt;\u0026lt; \u0026#34;, Ave = \u0026#34; \u0026lt;\u0026lt; Average({ 2,3,4 }) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; initializer_list\u0026lt;double\u0026gt; dl = { 1.1, 2.2, 3.3, 4.4, 5.5 }; cout \u0026lt;\u0026lt; \u0026#34;목록 2: Sum = \u0026#34; \u0026lt;\u0026lt; Sum(dl) \u0026lt;\u0026lt; \u0026#34;, Ave = \u0026#34; \u0026lt;\u0026lt; Average(dl) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; dl = { 16.0, 25.0, 36.0, 40.0, 64.0 }; // 대입 가능 cout \u0026lt;\u0026lt; \u0026#34;목록 3: Sum = \u0026#34; \u0026lt;\u0026lt; Sum(dl) \u0026lt;\u0026lt; \u0026#34;, Ave = \u0026#34; \u0026lt;\u0026lt; Average(dl) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":"2022-03-25T13:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-16-5/","title":"[C++ Primer Plus] Chapter 16. (5) STL - 알고리즘, 기타 라이브러리"},{"content":" 함수 객체(functor) 펑크터 함수처럼 ()와 함께 사용할 수 있는 객체이다. 일반 함수, 함수를 지시하는 포인터, ()가 오버로딩된 클래스 객체가 모두 펑크터가 될 수 있다. 펑크터 개념 제너레이터(generator) 매개변수 없이 호출하는 함수 단항 함수(unary function) 하나의 매개변수로 호출하는 함수 이항 함수(binary function) 두 개의 매개변수로 호출하는 함수 펑크터 개념의 개량 조건(predicate) bool값을 리턴하는 단항 함수 이항 조건(binary predicate) bool값을 리턴하는 이항 함수 list는 하나의 조건을 매개변수로 받아들이는 remove_if() 멤버를 가진다. 이것은 각 멤버에 조건을 적용해서 조건이 true를 리턴하는 모든 원소들을 삭제한다. 기준과, 원소의 값 두 가지 매개변수를 전달하지 못한다. 하지만 클래스 펑크터를 사용하면 기준이 되는 매개변수를 생성자로 미리 전달할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 template\u0026lt;class T\u0026gt; // 펑크터 클래스가 operator()()를 정의한다. class TooBig { private: T cutoff; public: TooBig(const T\u0026amp; t) : cutoff(t) {} bool operator()(const T\u0026amp; v) { return cutoff \u0026lt; v; // cutoff보다 크면 true } }; void OutInt(int n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } int main() { TooBig\u0026lt;int\u0026gt; f100(100); // 100초과의 것들은 true list\u0026lt;int\u0026gt; yadayada = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201}; list\u0026lt;int\u0026gt; etcetera = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201}; cout \u0026lt;\u0026lt; \u0026#34;원래의 리스트:\\n\u0026#34;; for_each(yadayada.begin(), yadayada.end(), OutInt); cout \u0026lt;\u0026lt; endl; for_each(etcetera.begin(), etcetera.end(), OutInt); cout \u0026lt;\u0026lt; endl; yadayada.remove_if(f100); // 선언된 함수 객체 etcetera.remove_if(TooBig\u0026lt;int\u0026gt;(200)); // 익명의 함수 객체 // 200초과의 것들은 true. 다 지운다. cout \u0026lt;\u0026lt; \u0026#34;정비된 리스트:\\n\u0026#34;; for_each(yadayada.begin(), yadayada.end(), OutInt); cout \u0026lt;\u0026lt; endl; for_each(etcetera.begin(), etcetera.end(), OutInt); cout \u0026lt;\u0026lt; endl; } 1 2 3 4 5 6 원래의 리스트: 50 100 90 180 60 210 415 88 188 201 50 100 90 180 60 210 415 88 188 201 정비된 리스트: 50 100 90 60 88 50 100 90 180 60 88 188 두 개의 매개변수를 사용하는 템플릿 함수를 이미 가지고 있다면, 클래스를 사용해서 이것을 하나의 매개변수를 사용하는 함수 객체로 변환할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template\u0026lt;class T\u0026gt; bool tooBig(const T\u0026amp; val, const T\u0026amp; lim) { return val \u0026gt; lim; } template\u0026lt;class T\u0026gt; class TooBig2 // 함수 어댑터이다. tooBig함수를 다른 인터페이스에 맞게 개조시킨다. { private: T cutoff; public: TooBig2(const T\u0026amp; t) : cutoff(t) {} bool operator()(const T\u0026amp; v) { return tooBig\u0026lt;T\u0026gt;(v, cutoff); // tooBig 함수를 사용한다. } }; 미리 정의된 펑크터 STL은 몇 가지 기본적인 펑크터들을 정의한다. 그것들은 함수를 매개변수로 취하는 STL 함수들을 지원하기 위해 제공된다. 예를 들어, transform()함수를 생각해 보자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;functional\u0026gt; //... plus\u0026lt;int\u0026gt; add; // plus\u0026lt;int\u0026gt; 객체를 생성한다. int result = add(1, 4); // plus\u0026lt;int\u0026gt;::operator()()를 사용한다. vector\u0026lt;double\u0026gt; vec = { 36, 39, 42, 45, 48 }; vector\u0026lt;double\u0026gt; vec2 = { 1, 2, 3, 4, 5 }; ostream_iterator\u0026lt;double, char\u0026gt; out(cout, \u0026#34; \u0026#34;); transform(vec.begin(), vec.end(), vec2.begin(), out, plus\u0026lt;double\u0026gt;()); // 익명의 plus\u0026lt;double\u0026gt; 함수 객체를 만들어서 사용했다. // vec의 0~4와 vec2의 0~4의 원소를 각각 더해서 화면에 출력한다. 내장 연산자들과 동등한 펑크터들 이것은 모두 순응성(adaptable)이다. 연산자 동등한 펑크터 + plus - minus * multiplies / divides % modulus - negate == equal_to != not_equal_to \u0026gt; grater \u0026lt; less \u0026gt;= grater_equal \u0026lt;= less_equal \u0026amp;\u0026amp; logical_and ` ! logical_not 순응성(adaptable) 매개변수형과 리턴형을 식별하는 typedef멤버를 가지는 것이다. 그 멤버들은 result_type, first_argument_type, second_argument_type 등이 있다. 예를 들어, plus\u0026lt;int\u0026gt; 객체의 리턴형은 plus\u0026lt;int\u0026gt;::result_type이다. 펑크터가 순응성이면, 함수 어댑터 객체가 펑크터를 사용할 수 있다. 예를 들어, multiplies는 이항 함수이다. 따라서 하나의 매개변수만 제공하는 아래와 같은 코드는 동작하지 않는다. 그래서 두 개의 매개변수를 사용하는 펑크터를 하나의 매개변수를 사용하는 펑크터로 변환하는, 함수 어댑터가 필요하다. STL은 순응성 이항 함수를 순응성 단항 함수로 변환하는 binder1st와 binder2nd 클래스를 제공한다. 그리고 이것을 간소화한 bind1st, bind2nd 함수를 제공한다. bind1st는 제 1 매개변수를 제공한다. bind2nd는 제 2 매개변수를 제공한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector\u0026lt;double\u0026gt; vec = { 36, 39, 42, 45, 48 }; ostream_iterator\u0026lt;double, char\u0026gt; out(cout, \u0026#34; \u0026#34;); transform(vec.begin(), vec.end(), out, multiplies\u0026lt;double\u0026gt;()); // (X) // vec만 가지고는 곱셈을 할 수 없다. binder1st\u0026lt;multiplies\u0026lt;double\u0026gt;\u0026gt; b1 = binder1st\u0026lt;multiplies\u0026lt;double\u0026gt;\u0026gt;(multiplies\u0026lt;double\u0026gt;(), 2.5); transform(vec.begin(), vec.end(), vec.begin(), b1); // (O) // binder1st 함수 어댑터 객체를 만들어서 // 이항 함수 multiplies를 단항 함수로 만들었다. transform(vec.begin(), vec.end(), out, bind1st(multiplies\u0026lt;double\u0026gt;(), 2.5)); // (O) // bind1st 함수는 좀 더 간편하게 사용할 수 있다. // vec은 제 2 매개변수이다. // bind1st( 2항 함수, 제 1 매개변수 ) // vec의 원소들과 bind1st에 제공된 제 1 매개변수를 곱한값을 출력한다. ","date":"2022-03-25T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-16-4/","title":"[C++ Primer Plus] Chapter 16. (4) STL - 함수 객체"},{"content":" 컨테이너(container) 컨테이너 개념\n모든 STL 컨테이너 클래스들이 충족시켜야 하는 요구 사항의 집합 기본 컨테이너의 특성\nX vector\u0026lt;int\u0026gt; T int a, b vector\u0026lt;int\u0026gt;의 값 r vector\u0026lt;int\u0026gt;\u0026amp;의 값 u vector\u0026lt;int\u0026gt;의 객체 vec 비례 시간 원소 수에 비례한다는 것을 의미한다. 표현 리턴형 설명 복잡성 X::iterator T를 지시하는 이러레이터형 출력 이터레이터를 제외한 모든 이터레이터들 컴파일 시간 X::value_type T T에 해당하는 데이터형 컴파일 시간 X u; 크기가 0인 u라는 컨테이너 생성 고정 시간 X(); 크기가 0인 익명의 컨테이너 생성 고정 시간 X u(a); 복사 생성자 수행이 후 u == a 비례 시간 X u = a; X u(a);와 같다 비례 시간 r = a; X\u0026amp; 복사 대입 수행 이후, r == a 비례 시간 (\u0026amp;a)-\u0026gt;~X(); void 컨테이너의 모든 원소에 파괴자를 적용한다. 비례 시간 a.begin() 이터레이터 컨테이너의 첫 번째 원소를 지시하는 이터레이터를 리턴한다. 고정 시간 a.end() 이터레이터 past-the-end값인 이터레이터를 리턴한다. 고정 시간 a.size() unsigned 정수형 a.end() - a.begin()과 같은 원소 수 고정 시간 a.swap(b) a와 b의 내용을 맞바꾼다. 고정 시간 a == b bool로 변환할 수 있는\n데이터형 a와 b의 크기가 같고, a에 있는 각 원소가 b에 있는 대응하는 원소와 등가이면\n(==가 true이면) true 비례 시간 a != b bool로 변환할 수 있는\n데이터형 !(a -- b)와 같다. 비례 시간 C++11에서 추가 요구 사항 rv 상수가 아닌 vector\u0026lt;int\u0026gt;\u0026amp;의 값 표현 리턴형 설명 복잡성 X u(rv); 생성자 포스트 조건을 이동시킨다. u는 생성전에 rv가 지녔던 값을 지닌다. 선형 X u = rv; X u(rv)와 동일한 효과 선형 a = rv; X\u0026amp; 대입 포스트 조건을 이동시킨다. a는 대입 이전에 rv가 지녔던 값을 지닌다. 선형 a.cbegin() const_iterator 컨테이너의 첫 번째 요소를 지칭하는 const 이터레이터를 리턴한다. 상수 a.cend() const_iterator 최종값인 const이터레이터를 리턴한다. 상수 컨테이너의 종류 1. 시퀀스 컨테이너 데이터를 선형으로 저장한다. 2. 결합 컨테이너 데이터를 키와 값으로 저장한다. 3. 컨테이너 어댑터 앞의 두 컨테이너를 변형하여 인터페이스를 제한한다. 이터레이션을 허용하지 않는다. 시퀀스 컨테이너(sequence container) STL의 컨테이너 형 중에서 다음은 컨테이너들은 시퀀스이다. vector, deque, list, forward_list (C++11), queue, priority_queue, stack 시퀀스는 최소한의 이터레이터가 늘 전방 이터레이터이다. 따라서 이터레이션이 이루어질 때마다 변하지 않는 명확한 순서로 원소들이 배치되는 것을 보장한다. 또한, 원소들이 직선 순서로 배치된다. 시퀀스 요구 사항 t T형의 값. int의 값. n 정수 p, q, i, j 이터레이터 표현 리턴형 설명 X a(n, t) n개의 값 t로 이루어진 시퀀스 a를 선언한다. X(n, t) n개의 값 t로 이루어진 익명 시퀀스를 선언한다. X a(i, j) [i, j) 범위의 내용으로 초기화된 시퀀스 a를 선언한다. X(i, j) [i, j) 범위의 내용으로 초기화된 익명 시퀀스를 선언한다. a.insert(p, t) 이터레이터 p앞에 t의 복사본을 삽입한다. a.insert(p, n, t) void p앞에 t의 복사본을 n개 삽입한다. a.insert(p, i, j) void p앞에 [i, j) 범위에 있는 원소들의 복사본을 삽입한다. a.erase(p) 이터레이터 p가 지시하는 원소를 삭제한다. a.erase(p, q) 이터레이터 [p, q) 범위에 있는 원소들을 삭제한다. a.clear() void erase(begin(), end())와 같다. 선택적 시퀀스 요구 사항 모두 고정 시간 복잡도를 가진다. 표현 리턴형 의미 컨테이너 a.front() T\u0026amp; *a.begin() vector, list, deque a.back() T\u0026amp; *--a.end() vector, list, deque a.push_front(t) void a.insert(a.begin(), t) list, deque a.push_back(t) void a.insert(a.end(), t) vector, list, deque a.pop_front(t) void a.erase(a.begin()) list, deque a.pop_back(t) void a.erase(--a.end()) vector, list, deque a[n] T\u0026amp; *(a.begin() + n) vector, deque a.at(n) T\u0026amp; *(a.begin() + n) (n이 경계를 벗어나면, out_of_range예외 발생) vector, deque vector 컨테이너 이것은 시퀀스이기도 하지만 가역성 컨테이너(reversible container)이기도 하다. 따라서 rbegin(), rend() 두 개의 메서드가 더 추가된다. 말미에서는 고정 시간 연산으로 삽입과 삭제가 가능하지만, 다른 위치에서는 비례 시간 연산으로 가능하다. 임의 접근을 통한 빠른 접근을 강조한다. deque 컨테이너 double-ended queue의 줄임말이며, 양쪽에 끝이 있는 큐이다. 덱이라고 발음한다. 양쪽 끝에서 고정 시간 연산으로 삽입과 삭제를 할 수 있도록 한다. list 컨테이너 이중 링크드 리스트이다. 어느 위치든지 고정 시간 연산으로 삽입과 삭제가 가능하다. 따라서 신속한 삽입과 삭제를 강조한다. 이 또한 가역성 컨테이너(reversible container)이다. 하지만 vector와는 다르게 배열 표기와 임의 접근을 지원하지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 list\u0026lt;int\u0026gt; fives(3, 5); // {5, 5, 5} int stuff[7] = {1, 2, 3, 4, 5, 5, 3}; list\u0026lt;int\u0026gt; result; result.insert(result.begin(), stuff, stuff + 7); // stuff의 0~6를 result에 삽입 for_each(result.begin(), result.end(), output); cout \u0026lt;\u0026lt; endl; result.remove(5); // {1, 2, 3, 4, 3} 모든 5를 없앤다. result.splice(result.begin(), fives); // {5, 5, 5, 1, 2, 3, 4, 3} // fives의 모든 내용이 result.begin() 앞에 삽입된다. // 결과로, fives는 비게 된다. result.unique(); // {5, 1, 2, 3, 4, 3} 연속된 중복을 제거한다. result.sort(); // {1, 2, 3, 3, 4 5} 정렬한다. sort(result.begin(), result.end()); // (X) // 멤버가 아닌 sort()도 있다. // 하지만 이것은 임의 접근 이터레이터를 요구한다. 따라서 리스트와 사용할 수 없다. list\u0026lt;int\u0026gt; fours(3, 4); // {4, 4, 4} result.merge(fours); // {1, 2, 3, 4, 4, 4, 4, 5} 정렬되어 있는 두 리스트를 합친다. forward_list 컨테이너 (C++11) 단순 링크드 리스트이다. 전방 이터레이터만 필요하다. 양방향은 필요하지 않다. queue 컨테이너 어댑터 클래스. 임의 접근이 안 되며, 큐를 훑는 이터레이션을 허용하지 않는다. priority_queue 컨테이너 어댑터 클래스. 큐와 같지만, 가장 큰 항목이 큐의 선두로 나간다. 내부적으로 다른 점은, 기초가 되는 디폴트 클레스가 vector이라는 점이다. 선택적 매개변수를 제공한다. 이것으로 어떤 것을 선두로 내보낼지 결정할 수 있다. 1 2 priority_queue\u0026lt;int\u0026gt; pq1; priority_queue\u0026lt;int\u0026gt; pq2(greater\u0026lt;int\u0026gt;); // greater\u0026lt;int\u0026gt;를 우선 배치한다. stack 컨테이너 어댑터 클래스. 기초가 되는 디폴트 클래스가 vector이다. 임의 접근이 안 되며, 스택을 훑는 이터레이션을 허용하지 않는다. array 템플릿 클래스 고정된 크기를 지니기 때문에 STL 컨테이너는 될 수 없다. copy(), for_each()와 같은 표준 STL 알고리즘을 사용할 수 있다. 결합 컨테이너(associative container) set, multiset, map, multimap 컨테이너 개념의 또 다른 개량이다. 값에 키(key)를 결합하고, 그 키를 사용해서 값을 찾는다. X::key_type 키로 사용되는 데이터형 특정 위치에 삽입할 수 없다. 왜냐하면, 정보를 신속하게 검색할 수 있도록 데이터의 배치를 결정하는 특별한 알고리즘을 사용하기 때문이다. 전형적으로 트리 구조를 이용하여 구현된다. 따라서 list와 비교했을 때, 검색이 월등히 빠르다. set 컨테이너 키와 값의 데이터형이 같다. 키당 하나의 값만 가지므로 키는 고유하다. 즉, 키가 곧 값이다. 가역성이며 정렬된다. 키를 배치하는 데 사용되는 비교함수나 객체를 추가적인 매개변수로 제공할 수 있다. 디폴트는 less\u0026lt;\u0026gt; 템플릿이 사용된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 void output(const string\u0026amp; s) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } //... set\u0026lt;string\u0026gt; s1; et\u0026lt;string, less\u0026lt;string\u0026gt;\u0026gt; s2; string stra[5] = {\u0026#34;B\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;C\u0026#34; }; set\u0026lt;string\u0026gt; a(stra, stra + 5); // strs 0~4범위로 a를 초기화한다. // 정렬된다. 그리고 키와 값은 고유하다. // 따라서 결과는 {\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;} 이다. string strb[5] = {\u0026#34;E\u0026#34;, \u0026#34;G\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;F\u0026#34; }; set\u0026lt;string\u0026gt; b(strb, strb + 5); set\u0026lt;string\u0026gt; uni; set_union(a.begin(), a.end(), b.begin(), b.end(), insert_iterator\u0026lt;set\u0026lt;string\u0026gt;\u0026gt;(uni, uni.begin())); // a와 b의 합집함을 uni에 저장한다. // insert_iterator가 이것을 가능하게 한다. // c.begin()만 넣으면, 안된다. // 이유1. 키는 상수이다. 따라서 c.begin()은 상수 이터레이터이다. // 그래서 출력 이터레이터로 사용할 수 없다. (쓸 수 없다.) // 이유2. c는 비어 있다. 데이터를 넣을 충분한 공간이 없다. // {\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;G\u0026#34; }; set\u0026lt;string\u0026gt; inter; set_intersection(a.begin(), a.end(),b.begin(), b.end(), insert_iterator\u0026lt;set\u0026lt;string\u0026gt;\u0026gt;(inter, inter.begin())); // a와 b의 교집합 // {\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;} set\u0026lt;string\u0026gt; dif; set_difference(a.begin(), a.end(),b.begin(), b.end(), insert_iterator\u0026lt;set\u0026lt;string\u0026gt;\u0026gt;(dif, dif.begin())); // a와 b의 차집합 // {\u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;} string stuff = \u0026#34;Apple\u0026#34;; a.insert(stuff); // {\u0026#34;A\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;} 원소를 삽입한다. for_each(a.lower_bound(\u0026#34;Apple\u0026#34;), a.upper_bound(\u0026#34;C\u0026#34;), output); // {\u0026#34;Apple\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;} 출력 // lower_bound는 매개변수 이상의 것 중 가장 작은 멤버를 지시하는 이터레이터를 리턴한다. // upper_bound는 매개변수 초과의 것 중 가장 큰 멤버를 지시하는 이터레이터를 리턴한다. multiset 컨테이너 set과 비슷하다. 다른 점은, 하나의 키가 다양한 값과 결합될 수 있다. map 컨테이너 키와 값의 데이터형이 다르다. 키당 하나의 값만 가지므로 키는 고유하다. multimap 컨테이너 map과 비슷하다. 다른 점은, 하나의 키가 다양한 값과 결합될 수 있다. 가역성이며 정렬된다. 키를 배치하는 데 사용되는 비교함수나 객체를 추가적인 매개변수로 제공할 수 있다. 디폴트는 less\u0026lt;\u0026gt; 템플릿이 사용된다. 키와 값을 하나의 쌍으로 결합하기 위해서 pair\u0026lt;class T, class U\u0026gt; 템플릿 클래스를 사용한다. `pair\u0026lt;class keytype, class datatype\u0026gt;이 되겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 multimap\u0026lt;int, string\u0026gt; codes; codes.insert({415, \u0026#34;샌프란시스코\u0026#34;}); codes.insert({510, \u0026#34;오클랜드\u0026#34;}); codes.insert({718, \u0026#34;브루클린\u0026#34;}); codes.insert({718, \u0026#34;스태튼 섬\u0026#34;}); cout \u0026lt;\u0026lt; codes.count(718) \u0026lt;\u0026lt; endl; // count는 키가 718인 값의 개수를 출력한다: 2 multimap\u0026lt;int, string\u0026gt;::iterator it; for (it = codes.begin(); it != codes.end(); ++it) cout \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; // first, second로 키, 값에 접근할 수 있다. typedef multimap\u0026lt;int, string\u0026gt;::iterator mapIter; pair\u0026lt;mapIter, mapIter\u0026gt; range = codes.equal_range(718); // equal_range은 키가 718인 범위를 나타내는 이터레이터 쌍을 리턴한다. for (it = range.first; it != range.second; ++it) cout \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; // range에 있는 데이터를 출력한다. 순서가 부여되지 않은 결합 컨테이너(unordered associative container) (C++11) 결합 컨테이너처럼 키와 값을 결합하고 키를 사용해 값을 찾는다. 다른 점은, 결합 컨테이너는 트리 구조에 기반을 두지만, 이것은 hash table에 기반을 둔다. unordered_set, unordered_multiset, unordered_map, unordered_multimap ","date":"2022-03-24T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-16-3/","title":"[C++ Primer Plus] Chapter 16. (3) STL - 컨테이너"},{"content":" 표준 템플릿 라이브러리 표준 템플릿 라이브러리(STL; Standard Template Library) 객체 지향이 아니다. 일반화 프로그래밍(generic programming)이라는 패러다임을 나타낸다. 1. 컨테이너(container) 배열 같이, 여러 개의 값을 저장할 수 있는 구성 단위. 2. 알고리즘(algorithm) 배열을 정렬하거나, 리스트에서 특정 값을 검색하는 것과 같이, 특별한 작업들을 수행하기 위한 방법. 3. 이터레이터(iterator) 배열 안에서 포인터를 사용해서 위치를 옮기듯이, 컨테이너 안에서 위치를 옮길 수 있도록 도와주는 객체. 즉, 포인터의 일반화이다. 4. 함수 객체(function object) 함수와 비슷한 역할을 하는 객체. 클래스 일수도 있고, 함수 포인터일 수도 있다. vector 컨테이너 클래스 vector 컨테이너 클래스 vector 헤더파일에 정의되어 있다. 1 2 3 4 5 6 7 // 메모리 관리에 사용할 allocator 객체를 선택적으로 지정할 수 있다. // allocator 클래스는 new와 delete를 표준방식으로 사용한다. template\u0026lt;class T, class Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; class vector { //... }; 생성\n동적 메모리 대입을 사용한다. 원소 개수를 지정하기 위해 초기화 매개변수를 사용할 수 있다. 접근\n[] 연산자로 개별 원소에 접근할 수 있다. 할 수 있는 것\nsize() 원소 개수 리턴 swap() 두 컨테이너 내용을 교환 begin() 컨테이너에 있는 첫 번째 원소를 참조하는 이터레이터를 리턴 end() 컨테이너에 있는 마지막 원소 바로 다음(past-the-end)을 참조하는 이터레이터를 리턴 push_back() 벡터의 끝에 원소를 하나 추가 erase() 매개변수로 2개의 이터레이터를 받는다. 첫 번째 이터레이터가 가리키는 곳부터 두 번째 이터레이터 전까지를 삭제한다. (두 번째 이터레이터 포함 안 함) insert() 매개변수로 3개의 이터레이터를 받는다. 첫 번째 이터레이터 앞에 원소들이 삽입된다. 두 번째 이터레이터가 가리키는 곳부터 세 번째 이터레이터 전까지 추가된다. (세 번째 이터레이터 포함 안 함) 이터레이터 단순 포인터를 가지고는 동작시킬 수 없는 클래스를 포함하여, 다양한 컨테이너 클래스들에 일관된 인터페이스를 제공할 수 있다. 각 컨테이너 클래스는 하나의 적절한 이터레이터를 정의한다. 데이터형 이름은 iterator이며, 클래스 사용범위를 가지는 typedef이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt; scores {0, 2, 3, 4, 5}; vector\u0026lt;int\u0026gt;::iterator vi; // vector\u0026lt;int\u0026gt;를 위한 이터레이터 vi = scores.begin(); // 이터레이터가 첫번째 원소를 가리키게 한다. auto va = scores.begin(); // C++11의 자동 타입 추론을 사용할 수도 있다. *vi = 1; // 이터레이터 내용을 참조하여 값을 변경한다. ++vi; // 이터레이터가 다음 원소를 가리키게 한다. // end()에 도달하면 그만두는 방식으로 모두 출력할 수 있다. for (vi = scores.begin(); vi != scores.end(); vi++) cout \u0026lt;\u0026lt; *vi \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 할 수 있는 그 밖의 것 검색하고, 정렬하고, 순서를 무작위화하는 등의 작업을 vector 템플릿 클래스에서 메서드로 가지고 있을까? 아니다. STL은 좀 더 넓은 시각으로, 이러한 연산들을 멤버가 아닌 함수로 정의한다. 예를 들면, 모든 컨테이너 클래스에서 사용할 수 있는 멤버가 아닌 하나의 find()함수를 정의하는 것이다. 대표적인 STL 함수인 세 가지를 살펴보자. for_each() random_shuffle() sort() for_each() 함수 3개의 매개변수를 받는다. 첫 번째와 두 번째 매개변수는 범위를 정한다. 세 번째 매개변수는 함수 객체이다. 지시된 함수를 그 범위 안에 있는 각 컨테이너 원소에 적용한다. 지시된 함수는 컨테이너 원소들의 값을 변경하면 안 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 struct Review { string title; int rating; }; void ShowReview(const Review\u0026amp; r) { cout \u0026lt;\u0026lt; r.title \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r.rating \u0026lt;\u0026lt; endl; } int main() { vector\u0026lt;Review\u0026gt; books = { {\u0026#34;Harry Potter\u0026#34;, 10}, {\u0026#34;Hole\u0026#34;, 9}, }; // for문을 사용한다. for (auto pr = books.begin(); pr != books.end(); pr++) ShowReview(*pr); // for_each를 사용해서 이렇게 바꿀 수 있다. for_each(books.begin(), books.end(), ShowReview); // 함수는 값을 변경하지 않는다. } random_shuffle() 2개의 이터레이터 매개변수를 받는다. 그 이터레이터 범위 안에 있는 원소들을 무작위 순서로 재배치한다. 1 random_shuffle(books.begin(), books.end()); sort() 두 가지 버전이 있다. (1) 2개의 이터레이터 매개변수를 받는다. 컨테이너의 데이터형에 맞게 정의된 \u0026lt;연산자를 사용하여 그 범위를 정렬한다. 만약 데이터형이 사용자 정의 객체라면 operator\u0026lt;()함수가 있어야한다. (2) 3번째 매개변수를 받는다. 값을 비교하기 위한 operator\u0026lt;() 대신에 사용할 함수 객체이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool operator\u0026lt;(const Review\u0026amp; r1, const Review\u0026amp; r2) { return r1.rating \u0026lt; r2.rating; // 오름차순 } bool WorseThan(const Review\u0026amp; r1, const Review\u0026amp; r2) { return r1.rating \u0026gt; r2.rating; // 내림차순 } int main() { vector\u0026lt;int\u0026gt; coolstuff; sort(coolstuff.begin(), coolstuff.end()); // 내장된 \u0026lt; 연산자 사용 sort(books.begin(), books.end()); // 데이터형에 맞게 정의된 operator\u0026lt;() 사용 (1) sort(books.begin(), books.end(), WorseThan); // WorseThan함수 사용 (2) } Range에 기초한 루프 (C+11) 1 2 3 4 for_each(books.begin(), books.end(), ShowReview); // ShowReivew는 값변경 안 된다. for (auto r : books) ShowReview(r); // 값 변경 할 수 있다. 이터레이터(iterator) 템플릿이 알고리즘을 저장할 데이터형과 무관하게 만드는 것처럼, 이터레이터는 알고리즘을 사용할 컨테이너형과 무관하게 만든다. double 배열과 링크드 리스트에서 원하는 값을 찾는 Find()함수를 만들면서 이터레이터에 대해 알아보자. 특정한 구조에 매여 있지 않으면 좋겠다. 따라서 다음과 같이 만들어보았다. 여기서 두 Find()함수의 유일한 다른점은 검색을 멈추는 마지막 지점이다. past-the-end원소를 링크드 리스트도 갖게 한다면, 두 Find()함수는 똑같아진다. 따라서 각 클래스를 위한 적절한 이터레이터를 정의하고 클래스들을 일관된 방식으로 설계하면, STL을 사용하여서 동일한 코드를 작성할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 // 배열의 경우 // 포인터로 정의한다. typedef double* iterator; iterator FindAr(iterator begin, iterator end, const double\u0026amp; target) { // 배열의 끝 바로 다음 포인터인 end가 아닐 때까지 진행한다. for (iterator it = begin; it != end; it++) if (*it = target) return it; return end; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // 링크드 리스트의 경우 struct Node { double item; Node* next; }; // 객체로 정의한다. class iterator { Node* pt; public: iterator() : pt(nullptr) {} iterator(Node* pn) : pt(pn) {} double operator*() { return pt-\u0026gt;item; } // ++iterator iterator\u0026amp; operator++() { pt = pt-\u0026gt;next; return *this; } // iterator++ (매개변수 int는 사용되지 않기때문에 이름을 부여할 필요가 없다) iterator operator++(int) { iterator temp = *this; pt = pt-\u0026gt;next; return temp; } // ... }; iterator FindLl(iterator begin, const double\u0026amp; target) { // 마지막인 널 포인터가 아닐 때까지 진행한다. for (iterator it = begin; it != 0; it++) if (*it = target) return it; return 0; } 이터레이터의 종류 1. 입력 이터레이터(input iterator) 2. 출력 이터레이터(output iterator) 3. 전방 이터레이터(forward iterator) 4. 전후방 이터레이터(bidirectional iterator) 5. 임의 접근 이터레이터(random access iterator) 알고리즘이 다르면 이터레이터의 종류가 다르다. 예를 들어, 검색의 경우 쓰기는 금지하고 읽기 접근만 허용해야 하며, 원소 교환의 경우 임의 접근을 허용해야 한다. 요구 사항이 가장 적은 이터레이터를 사용하여 알고리즘을 작성함으로써, 가장 넒은 범위의 컨터에너들에 사용할 수 있도록 하기 위해 여러 가지 종류의 이터레이터가 존재한다. 따라서 find()의 경우, 읽을 수 있는 값이 들어 있는 어떠한 컨테이너들에도 사용할 수 있겠다. vector\u0026lt;int\u0026gt;클래스는 임의 접근 이터레이터를 사용하며, list\u0026lt;int\u0026gt;클래스는 전후방 이터레이터를 사용한다. 1 2 3 4 5 6 7 // 입력 이터레이터를 요구하는 함수 find() template\u0026lt;class InputIerator, class T\u0026gt; InputIerator find(InputIerator first, InputIerator last, const T\u0026amp; value); // 임의 접근 이터레이터를 요구하는 함수 sort() template\u0026lt;class RandomAccessIterator\u0026gt; void sort(RandomAccessIterator first, RandomAccessIterator last); 1. 입력 이터레이터\n컨테이너로부터 값을 읽는 것을 허용한다. 하지만 변경하는 것은 허용하지 않는다. 입력 이터레이터가 이미 증가된 후에, 증가되지 전 값을 내용 참조할 수 있다는 보장이 없다. 이렇게 입력 이터레이터에 기초를 둔 알고리즘은 일회성이며, 일방향적이다. 즉, 증가시킬 수는 있지만 되돌릴 수는 없다. 2. 출력 이터레이터\n값을 변경하는 것을 허용하지만, 읽는 것은 허용하지 않는다. 이것은 cout을 생각해보면 된다. cout은 디스플레이로 보내지는 문자들의 스트림을 변경할 수 있지만, 화면에 표시된 것을 읽지는 못한다. 쓰기 전용 일회성 알고리즘에 사용할 수 있다. 3. 전방 이터레이터\n입/출력 이터레이터와 마찬가지로 전방 이터레이터도 컨테이너 속을 훑고 지나가기 위해 ++연산자만 사용한다. 다른 점 전방 이터레이터는 사용할 때마다 연속된 값들을 반드시 같은 순서로 훑고 지나간다. 증가된 후에도 (저장해 두었다면) 그 이전 이터레이터 값을 내용 참조하여 항상 같은 값을 얻을 수 있다. 따라서 다중 패스 알고리즘이 가능해진다. 4. 전후방 이터레이터\n전방 이터레이터가 가지고 있는 모든 기능에 감소 연산자(전방, 후방)에 대한 기능을 추가한다. 예를 들어, 뒤집기(reverse) 함수는 첫 번째 원소와 마지막 원소를 맞바꾸고, 첫 번째 원소를 지시하는 포인터는 증가시키고, 마지막 원소를 지시하는 포인터는 감소시킨다. 5. 임의 접근 이터레이터\n전후방 이터레이터가 가지고 있는 모든 기능에 임의 접근을 지원하는(포인터 덧셈 등) 연산과, 원소들의 순서를 매기는 데 사용할 관계 연산자들을 추가한다.\n예를 들어, 이진 탐색(binary search)의 경우 임의 원소로 직접 점프가 가능해야 한다.\n임의 접근 이터레이터 연산\na, b는 이터레이터이다. n은 정수이며 r는 임의 접근 이터레이터 변수/참조이다. a + n과 같은 식은 a와 a + n이 둘 다 컨테이너의 범위 안에 있을 때만 유효하다. 식 설명 a + n, n + a a가 지시하는 원소로부터 n번째 뒤의 원소를 지시한다. a - n a가 지시하는 원소로부터 n번째 앞의 원소를 지시한다. r += n r = r + n과 같다. r -= n r = r - n과 같다. a[n] *(a + n)과 같다. b - a b = a + n과 같은 경우에 n의 값 a \u0026lt; b b - a \u0026gt; 0이면 true a \u0026gt; b b \u0026lt; a이면 true a \u0026gt;= b !(a \u0026lt; b)이면 true a \u0026lt;= b !(a \u0026gt; b)이면 true 이터레이터 계층 이터레이터 기능 입력 출력 전방 전후방 임의 접근 내용 참조하여 읽기 O X O O O 내용 참조하여 쓰기 X O O O O 고정 반복 가능한 순서 X X O O O ++i, i++ O O O O O --i, i-- X X X O O i[n] X X X X O i + n X X X X O i - n X X X X O i += n X X X X O i -= n X X X X O 개념(concept) 요구 사항의 집합 개량(refinement) 개념적인 상속 예를 들어, 전후방 이터레이터는 전방 이터레이터의 기능을 상속한다. 하지만 C++의 일반적인 상속과는 다르다. 이것들은 내장 데이터형이기 때문에 클래스로부터 파생시킬 수가 없다. 따라서 이런 것을 개념적인 상속인 개량이라고 부른다. 모델(model) 어떤 개념의 특별한 한 구현 예를 들어, int를 지시하는 단순 포인터는 임의 접근 이터레이터 개념의 한 모델이다. 또한 전방 이터레이터 개념의 모델이기도 하다. 이터레이터 자격의 포인터 이터레이터는 포인터를 일반화한 것이다. 따라서 STL알고리즘은 포인터에 기초를 두고 있는 STL이 아닌 컨테이너들에 적용할 수 있다. 1 2 3 4 const int SIZE = 10; double arr[SIZE]; sort(arr, arr + SIZE); // (O) copy() 하나의 컨테이너에서 다른 컨테이너로 데이터를 복사하는 알고리즘. 첫 번째와 두 번째 매개변수로 범위를 지정하고, 세 번째 매개변수로 복사할 위치를 지정한다. 이것은 목적지의 크기를 자동으로 조절하지 않는다. (뒤에 볼 insert_iterator 등을 사용하면 가능하다. ) 1 2 3 4 int arr[5] = {1, 2, 3, 4, 5}; vector\u0026lt;int\u0026gt; vec[5]; // 빈 벡터에는 복사할 수 없다. copy(arr, arr + 5, vec.begin()); // arr의 인덱스 0~4를 vec의 인덱스 0지점에 복사한다. 디스플레이에 복사하려면? 출력 스트림을 나타내는 이터레이터가 있으면 가능하겠다. STL은 ostream_iterator을 제공한다. 이것은 출력 이터레이터 개념의 모델이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iterator\u0026gt; ostream_iterator\u0026lt;int, char\u0026gt; outIterator(cout, \u0026#34; \u0026#34;); // int는 출력 스트림으로 보내는 데이터형이다. // char는 출력 스트림이 사용하는 데이터형이다. // cout은 cout이 관리하는 출력 스트림을 사용한다는 뜻이다. // \u0026#34; \u0026#34;은 출력 스트림에 보내진 각 항목 뒤에 표시되는 분리자이다. *outIterator++ = 15; // cout \u0026lt;\u0026lt; 15 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 와 같다. copy(vec.begin(), vec.end(), outIterator); // 벡터를 출력 스트림에 복사한다. // 혹은 익명 이터레이터를 만들 수도 있다. copy(vec.begin(), vec.end(), ostream_iterator\u0026lt;int, char\u0026gt;(cout, \u0026#34; \u0026#34;)); istream_iterator 같은 논리로, 입력을 위한 istream_iterator가 입력 이터레이터 개념의 모델이다. 1 2 3 4 5 6 7 copy(istream_iterator\u0026lt;int, char\u0026gt;(cin), istream_iterator\u0026lt;int, char\u0026gt;(), vec.begin()) // 입력 // int는 읽을 데이터형이다. // char는 입력 스트림이 사용하는 데이터형이다. // cin은 cin이 관리하는 입력 스트림을 사용한다는 뜻이다. // 매개변수를 생략하는 것은 입력 실패를 나타낸다. // 따라서 파일 끝, 데이터형 불일치 등의 입력 실패가 일어날 때까지 데이터를 읽는다는 뜻이다. reverse_iterator 이것을 증가시키면, 실제 내용은 감소한다. rbegin()은 past-the-end를 지시하며, rend()는 첫 번째 원소를 지시한다. 특이한 점은 역방향 포인터들은 먼저 감소시킨 후에 내용 참조를 한다는 점이다. 따라서 다음 코드와 같이 하면, 벡터를 뒤에서 부터 거꾸로 출력한다. 1 2 3 4 5 6 7 // 암시적 사용 copy(vec.rbegin(), vec.rend(), outIterator); // 마지막 원소 ~ 처음 원소 출력 // 명시적 사용 vector\u0026lt;int\u0026gt;::reverse_iterator ri; for (ri = vec.rbegin(); ri != vec.rend(); ++ri) cout \u0026lt;\u0026lt; *ri \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 추가적인 출력 이터레이터 개념의 모델들\u0026hellip;\nfront_insert_iterator\n컨테이너 선두에 원소들을 삽입한다. 선두에 삽입하는데 고정 시간이 걸리는 컨테이너형에만 사용할 수 있다. end_insert_iterator\n컨테이너 말미에 원소들을 삽입한다. 멀미에 삽입하는데 고정 시간이 걸리는 컨테이너형에만 사용할 수 있다. insert_iterator\n매개변수로 지정된 위치 앞에 원소들을 삽입한다. 시간 제한은 없다. 대신 다른 것들에 비해 좀 느리다. 이와 같은 모델들은 생성자 매개변수로 실제 컨테이너 식별자를 사용한다. copy()는 컨테이너 크기를 조절하는 권한이 없다. 하지만 이 모델들은 아래와 같이 컨테이너형을 선언하여서 vector\u0026lt;int\u0026gt;::push_back()에 접근이 가능하며, 따라서 컨테이너 크기를 조절할 수 있다. 1 2 3 4 back_insert_iterator\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; backIterator(vec); insert_iterator\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; insertIterator(vec, vec.begin()); // vec.begin()은 삽입될 위치이다. 1 2 3 4 5 6 string strs[5] = { \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34; }; vector\u0026lt;string\u0026gt; words = { \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34; }; copy(strs, strs + 2, back_insert_iterator\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;(words)); // str의 0 ~ 1인덱스에 있는 \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;를 words벡터 뒤에 삽입한다. // a b c d e A B 1 2 3 copy(strs, strs + 2, insert_iterator\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;(words, words.begin() + 2)); // str의 0 ~ 1인덱스에 있는 \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;를 words의 인덱스 2 위치 부터 삽입한다. // a b A B c d e ","date":"2022-03-23T13:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-16-2/","title":"[C++ Primer Plus] Chapter 16. (2) STL - 이터레이터"},{"content":" string 클래스 string 헤더파일을 통해 지원된다. C 스타일은 string.h와 cstring이다. string은 실제로는 템플릿 특수화 basic_string\u0026lt;char\u0026gt;에 대한 typedef이다. 1 2 3 4 5 6 7 8 9 10 11 12 // string 클래스는 템플릿 클래스에 기초한다. template\u0026lt;class charT, class traits = char_traits\u0026lt;charT\u0026gt;, class Allocator = allocator\u0026lt;charT\u0026gt;\u0026gt; class basic_string { // char 뿐만 아니라 다른형에 기초하는 문자열도 사용할 수 있게 허용한다. typedef basic_string\u0026lt;char\u0026gt; string; typedef basic_string\u0026lt;wchar_t\u0026gt; wstring; typedef basic_string\u0026lt;char16_t\u0026gt; u16string; // C++11 typedef basic_string\u0026lt;char32_t\u0026gt; u32string; // C++11 // ... }; string 생성자들\n메모리와 관련된 선택적 매개변수를 생략했다. (1) string(const char* s)\nstring객체를 s가 지시하는 NBTS로 초기화한다. (2) string(size_type n, char c)\n문자 c로 모두 초기화된 원소 n개의 string객체를 생성한다. (3) string(const string\u0026amp; str)\nstring객체를 string객체 str(복사 생성자)로 초기화한다. (4) string()\n크기가 0인 디폴트 string객체를 생성한다 (디폴트 생성자) (5) string(const char* s, size_type n)\nstring객체를 s가 자시하는 NBTS로 초기화하되, NBTS의 크기를 초과하더라도 n개의 문자까지 진행한다. (6) template\u0026lt;class Iter\u0026gt; string(Iter begin, Iter end)\nstring객체를 begin과 end - 1 범위에 있는 [begin, end) 값들로 초기화한다. begin과 end는 포인터와 비슷한 역할을 하여 위치를 지정한다. 그 범위는 begin을 포함하고 end는 포함하지 않는 end 바로 앞까지를 의미한다. (7) string(const string\u0026amp; std, size_type pos, size_type n = npos)\nstring 객체를 string객체 str로 초기화한다. str에 있는 pos위치에서 시작해서 str의 끝까지 가거나 n문자를 사용하되, str의 끝을 넘어갈 수 없다. (8) string(string\u0026amp;\u0026amp; str) noexcept\n(C++11) string객체를 string객체 str로 초기화한다. str은 const가 아니므로 바뀔 수 있다. (move 생성자) 컴파일러는 경우에 따라 성과를 최적화하기 위해서 복사 생성자 대신 이동 생성자를 사용한다. (9) string(initilaizer_list\u0026lt;char\u0026gt; il)\n(C++11) string 객체를 초기자 목록 il에 있는 문자로 초기화한다. 따라서 리스트 초기화를 가능하게 한다.\nNBTS\nnull byte terminated string; 널 바이트 종료 문자열 type_size\nstring헤더파일에 정의되어 있는, 시스템마다 다른 정수형이다. string::npos를 문자열의 최대길이로 정의한다. 일반적으로 unsigned char의 최대값과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string one(\u0026#34;Lottery Winner!\u0026#34;); cout \u0026lt;\u0026lt; one \u0026lt;\u0026lt; endl; string two(20, \u0026#39;$\u0026#39;); cout \u0026lt;\u0026lt; two \u0026lt;\u0026lt; endl; string three(one); cout \u0026lt;\u0026lt; three \u0026lt;\u0026lt; endl; one += \u0026#34; Oops!\u0026#34;; // 오버로딩 += cout \u0026lt;\u0026lt; one \u0026lt;\u0026lt; endl; two = \u0026#34;Sorry! That was \u0026#34;; // 오버로딩 = three[0] = \u0026#39;P\u0026#39;; // 오버로딩 [] string four; four = two + three; // 오버로딩 =, + cout \u0026lt;\u0026lt; four \u0026lt;\u0026lt; endl; char alls[] = \u0026#34;All\u0026#39;s well that ends well\u0026#34;; string five(alls, 20); cout \u0026lt;\u0026lt; five \u0026lt;\u0026lt; \u0026#34;!\\n\u0026#34;; // 배열의 이름은 주소이다. // 따라서 alls + 6은 char*형이다. 따라서 Iter가 char*형이 된다. string six(alls + 6, alls + 10); // 인덱스 6부터 9까지 cout \u0026lt;\u0026lt; six \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; // \u0026amp;five[6] 또한 char*형이다. string six2(\u0026amp;five[6], \u0026amp;five[10]); cout \u0026lt;\u0026lt; six2 \u0026lt;\u0026lt; \u0026#34;...\\n\u0026#34;; string seven(four, 7, 16); // 인덱스 7부터 16개 문자 cout \u0026lt;\u0026lt; seven \u0026lt;\u0026lt; \u0026#34; in motion!\u0026#34; \u0026lt;\u0026lt; endl; string nine = { \u0026#39;L\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39; }; } 입력 1 2 3 4 5 6 7 8 9 10 // C 스타일 문자열 char info[100]; cin \u0026gt;\u0026gt; info; // 한 단어를 읽는다. cin.getline(info, 100); // 한 행을 읽되, \\n은 내버린다. cin.get(info, 100); // 한 행을 읽되, \\n은 큐에 남겨 둔다. // string 객체 string stuff; cin \u0026gt;\u0026gt; stuff; // 한 단어를 읽는다. getline(cin, stuff); // 한 행을 읽되, \\n은 내버린다. getline()은 입력을 구분하기 위한 선택적 매개변수를 허용한다. 차이점은 string의 경우에는 객체의 크기를 자동으로 조절한다는 것이다. 1 2 3 4 5 // C 스타일 문자열 cin.getline(info, 100, \u0026#39;:\u0026#39;); // :까지 읽고, :는 내버린다. // string 객체 getline(cin, stuff, \u0026#39;:\u0026#39;); // :까지 읽고, :는 내버린다. getline()은 다음 중 하나가 일어나면 종료된다. (1) 파일의 끝을 만났을 때. 입력 스트림의 eofbit가 설정된다. (2) 구분문자(디폴트는 \\n이다. 만약 구분문자가 다른 것이되면 \\n은 그냥 일반 문자가 된다)에 도달했을 때. 구분문자를 저장되지 않는다. (3) 가능한 최대 문자 수(string::npos와 대입에 사용할 수 있는 메모리 바이트 수 중 더 적은 것)를 읽었을 때. 입력 스트림의 failbit가 설정된다. string 문자열의 크기 length() 오래된 버전부터 사용해온 것 size() STL 호환성을 위해 추가된 것 find() 메서드의 네 가지 변형 (1) size_type find(const string\u0026amp; str, size_type pos = 0) const\npos위치에서 시작해서 처음 나오는 str문자열을 찾는다. (2) size_type find(const char* s, size_type pos = 0) const\npos위치에서 시작해서 처음 나오는 s문자열을 찾는다. (3) size_type find(const char* s, size_type pos = 0, size_type n) const\npos위치에서 시작해서 s문자열의 처음 n개에 해당하는 부분 문자열을 찾는다. (4) size_type find(char ch, size_type pos = 0) const\npos위치에서 시작해서 처음 나오는 문자 ch를 찾는다. 찾으면, 첫 문자의 인덱스를 반환한다.\n찾지 못하면, string::npos를 리턴한다.\nfind() 관련 메서드 rfind() 가장 마지막으로 발생하는 부분 문자열이나 문자를 찾는다. find_first_of() 매개변수 문자열에서 처음 나오는 문자를 찾는다. find_last_of() 매개변수 문자열에 없는, 처음 나오는 문자를 찾는다. 1 2 3 4 string findHere(\u0026#34;ACAB\u0026#34;); int where = findHere.find_first_of(\u0026#34;BC\u0026#34;); // \u0026#39;C\u0026#39; 인덱스 1 where = findHere.find_last_of(\u0026#34;BC\u0026#34;); // \u0026#39;B\u0026#39; 인덱스 3 자동 크기 조절 매번 크기가 늘어날 때마다 새로운 블록을 대입하고 복사하는 것은 비효율적이다. 따라서 애초에 실제 문자열보다 훨씬 큰 메모리 블록을 대입한다. 그리고, 그 크기를 넘으면 그것의 두 배가 되는 블록을 새로 대입한다. capacity() 현재 블록의 크기를 리턴한다. reserve(size_t n) 블록의 최소한의 크기를 설정한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 string empty; string small = \u0026#34;bit\u0026#34;; string larger = \u0026#34;Elephants are a girl\u0026#39;s best friend\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Sizes:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\tempty: \u0026#34; \u0026lt;\u0026lt; empty.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\tsmall: \u0026#34; \u0026lt;\u0026lt; small.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\tlarger: \u0026#34; \u0026lt;\u0026lt; larger.size() \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Capacities:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\tempty: \u0026#34; \u0026lt;\u0026lt; empty.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\tsmall: \u0026#34; \u0026lt;\u0026lt; small.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\tlarger: \u0026#34; \u0026lt;\u0026lt; larger.capacity() \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; empty.reserve(50); cout \u0026lt;\u0026lt; \u0026#34;Capacity after empty.reserve(50): \u0026#34; \u0026lt;\u0026lt; empty.capacity() \u0026lt;\u0026lt; endl; 1 2 3 4 5 6 7 8 9 10 11 Sizes: empty: 0 small: 3 larger: 34 Capacities: empty: 15 // 이 시스템은 15문자의 최소용량을 사용한다. small: 15 larger: 47 Capacity after empty.reserve(50): 63 c_str() C 스타일로 바꾸기 1 2 3 4 5 6 7 8 // string에 들어있는 파일명이 필요할 경우. // open()은 C 스타일 매개변수를 요구한다. string filename; cin \u0026gt;\u0026gt; filename; ofstream fout; fout.open(filename.c_str()); 스마트 포인터 템플릿 클래스 스마트 포인터가 필요한 이유 동적 메모리 할당 후 해제하는 것을 잊어서 메모리 누수가 발생할 수 있다. 아래 예제와 같은 상황에서는 해제하는 코드를 작성하려면 try catch문을 또 작성해야할 것이다. 이러한 문제를 해결할 수 있는 더 멋진 해결책이 없을까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Remodel(string\u0026amp; str) { string* ps = new string(str); //... if (weirdThing()) throw exception(); // 지역 변수인 ps가 차지하는 메모리는 블록을 나가면서 해제되지만 // delete ps 하지 않았기 때문에 ps가 가리키는 메모리는 해제되지 않는다! str = *ps; delete ps; return; } 스마트 포인터 (smart pointer) 포인터처럼 행동하는 클래스 객체이다. new를 통해 얻어지는 주소를 대입할 포인터를 정의한다. 그리고 이 객체의 수명이 다 하면, 파괴자는 delete를 사용해서 메모리를 자동으로 해제한다. (p.1230 그림 16.2 참고) auto_ptr, unique_ptr, shared_ptr, weak_ptr memory 헤더파일에 정의되어있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // auto_ptr는 클래스 템플릿을 사용해서 포인터의 종류를 구체화한다. template\u0026lt;class X\u0026gt; class auto_ptr { public: explicit auto_ptr(X* p = 0) throw(); // 생성자 }; int main() { auto_ptr\u0026lt;int\u0026gt; ptr(new int); // int형을 가리키는 auto_ptr이다. auto_ptr\u0026lt;string\u0026gt; ptr(new string); // string형을 가리키는 auto_ptr이다. } auto_ptr로 이전 예제의 문제점을 수정해보자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;memory\u0026gt; void Remodel(string\u0026amp; str) { //string* ps = new string(str); auto_ptr\u0026lt;string\u0026gt; ps(new string(str)); // auto_ptr을 사용한다. //... if (weirdThing()) throw exception(); // auto_ptr이 동적 메모리도 알아서 해제해준다. str = *ps; //delete ps; 이것은 이제 필요없다. return; } 스마트 포인터 생성자에 explicit이 있으므로 명시적 변환만 허용된다. 1 2 3 4 5 shared_ptr\u0026lt;double\u0026gt; ds; double* d = new double; ds = d; // (X) 암시적 변환은 안 된다. ds = shared_ptr\u0026lt;double\u0026gt;(d); // (O) 명시적 변환은 된다. 스마트 포인터를 사용하면 안 되는 경우 delete하려는 메모리가 힙에 없는 경우 1 2 string str(\u0026#34;I want to study.\u0026#34;); shared_ptr\u0026lt;string\u0026gt; pstr(\u0026amp;str); // (X) 문제 상황 아래 예제는 한 번 해제한 메모리를 두 번 해제하게 된다. 각각의 스마트 포인터는 이 상황을 어떻게 해결할까? 1 2 3 4 5 6 7 auto_ptr\u0026lt;string\u0026gt; ps(new string(\u0026#34;I\u0026#39;m happy.\u0026#34;)); auto_ptr\u0026lt;string\u0026gt; pps; pps = ps; // 이렇게 하면 ps와 pps 모두 하나의 똑같은 메모리를 가리키게 된다. // 일반 포인터면 괜찮겠지만, 스마트 포인터는 delete 자동으로 호출하니까, // 그럼 delete도 두 번 될텐데.. 각각의 스마트 포인터는 이 상황을 어떻게 해결했을까? 해결 방안 (1) 깊은 복사를 하는 대입연산자를 정의한다. (2) 소유권 개념을 도입한다. auto_ptr과 shared_ptr의 전략이다. 스마트 포인터가 그 객체를 소유하는 경우에만 파괴자가 그 객체를 삭제한다. 그러고 나서, 대입을 통해 소유권을 이전시킨다. (3) 참조 카운팅(reference counting) shared_ptr의 전략이다. 특정 객체를 참조하는 스마트 포인터들이 몇 개인지 추적한다. 대입할 때마다 참조 카운팅이 1씩 증가한다. 스마트 포인터의 수명이 다하면 1씩 감소한다. 그리고 마지막으로 스마트 포인터의 수명이 다했을 때 delete가 호출된다. 해결 방안 비교 1 2 3 4 5 6 7 8 // auto_ptr auto_ptr\u0026lt;string\u0026gt; ps(new string(\u0026#34;I\u0026#39;m happy.\u0026#34;)); auto_ptr\u0026lt;string\u0026gt; pps; pps = ps; // ps의 소유권이 pss에게 넘어가서 ps는 더 이상 그 문자열을 참조하지 않는다. cout \u0026lt;\u0026lt; *ps \u0026lt;\u0026lt; endl; // (X) 실행 후 프로그램 크래시가 발생한다. 1 2 3 4 5 6 7 8 9 10 // shared_ptr shared_ptr\u0026lt;string\u0026gt; ps(new string(\u0026#34;I\u0026#39;m happy.\u0026#34;)); shared_ptr\u0026lt;string\u0026gt; pps; pps = ps; // 참조가 2번이 된다. cout \u0026lt;\u0026lt; *ps \u0026lt;\u0026lt; endl; // (O) // 참조카운트를 2에서 1로(pps), 1에서 0으로 줄이고(ps), 0이 되었을 때 힌 번 메모리를 해제한다. 1 2 3 4 5 6 7 8 // unique_ptr unique_ptr\u0026lt;string\u0026gt; ps(new string(\u0026#34;I\u0026#39;m happy.\u0026#34;)); unique_ptr\u0026lt;string\u0026gt; pps; pps = ps; // (X) 애초에 컴파일이 되지 않아서 실행도 안 된다. cout \u0026lt;\u0026lt; *ps \u0026lt;\u0026lt; endl; unique_ptr이 auto_ptr보다 좋은 점 프로그램 크래시 보다 컴파일 에러가 더 안정적이다. 대입 시 원본 객체가 임시 rvalue라면 그것을 허용한다. 배열을 가리킬 수 있다. auto_ptr은 new와 delete는 사용할 수 있지만 new [], delete []은 안 된다. 반면, unique_ptr은 둘 다 가능하다. 1 2 3 4 5 6 7 unique_ptr\u0026lt;string\u0026gt; p1(new string(\u0026#34;Uniquely special\u0026#34;)); unique_ptr\u0026lt;string\u0026gt; p2; p2 = p1; // (X) 컴파일 에러 p2 = unique_ptr\u0026lt;string\u0026gt;(new string(\u0026#34;Uniquely special\u0026#34;)); // (O) 임시 rvalue이므로, 임시 객체는 삭제된다. 따라서 p2가 유일하기 때문에 이것은 허용 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // unique_ptr을 위한 대입 방법을 이렇게 제안한다. unique_ptr\u0026lt;string\u0026gt; Demo(const char* s) { unique_ptr\u0026lt;string\u0026gt; temp(new string(s)); return temp; } int main() { unique_ptr\u0026lt;string\u0026gt; ps; ps = Demo(\u0026#34;Uniquely Special\u0026#34;); // (O) } 1 2 3 4 string strs[3]{ \u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;}; auto_ptr\u0026lt;string[]\u0026gt; psa(strs); // (X) unique_ptr\u0026lt;string[]\u0026gt; psu(strs); // (O) 배열을 가리킬 수 있다. unique_ptr의 대입을 가능하게 해주는 move() 표준 라이브러리 함수 1 2 3 unique_ptr\u0026lt;string\u0026gt; p1(new string(\u0026#34;One\u0026#34;)); unique_ptr\u0026lt;string\u0026gt; p2 = move(p1); p1 = unique_ptr\u0026lt;string\u0026gt;(new string(\u0026#34;And more\u0026#34;)); 스마트 포인터를 선택하는 방법 하나의 객체를 여러개의 포인터가 가리켜야 한다 shared_ptr 다중 포인터가 필요 없다. unique_ptr new로 대입된 메모리를 리턴하는 함수의 리턴 타입? unique_ptr 만약 하나의 unique_ptr에서 다른 unique_ptr로 대입이 가능한 경우라면 shared_ptr에 unique_ptr을 대입할 수 있다. 1 2 3 shared_ptr\u0026lt;string\u0026gt; ps; ps = unique_ptr\u0026lt;string\u0026gt;(new string(\u0026#34;Uniquely special\u0026#34;)); // (O) ps = Demo(\u0026#34;Uniquely Special\u0026#34;); // (O) ","date":"2022-03-23T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-16-1/","title":"[C++ Primer Plus] Chapter 16. (1) string 클래스, 스마트 포인터 템플릿 클래스"},{"content":" RTTI (runtime type identification) 실행 시간 데이터형 정보 실행 도중에 객체의 데이터형을 결정하는 표준 방법을 제공하는 것이 목적이다. RTTI의 동작 방식 C++은 RTTI를 지원하는 세 가지 요소를 가지고 있다. (1) dynamic_cast 연산자 (2) type_id 연산자 (3) type_info 클래스 RTTI는 가상함수들을 가지고 있는 클래스들에 대해서만 사용할 수 있다. 그 이유는, 그들이 파생 객체들의 주소를 기초 클래스 포인터들에 대입하는 유일한 클래스 계층이기 때문이다. RTTI는 가상함수들을 가지고 있는 클래스들에 대해서만 사용할 수 있다.\ndynamic_cast 연산자 기초 클래스형을 지시하는 포인터로부터 파생 클래스형을 지시하는 포인터를 생성한다. 포인터가 지시하는 객체형이 무엇인지 알려주지 않는다. 대신에, 그 객체의 주소를 특정형의 포인터에 안전하게 대입할 수 있는지 알려준다. 가능하지 않다면, 널 포인터인 0을 리턴한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A {}; class B : public A {}; class C : public B {}; int main() { A* a = new A; A* b = new B; A* c = new C; C* cc = (C*)c; // 안전하다 B* bc = (B*)c; // 안전하다 C* ca = (C*)a; // 안전하지 않다. 런타임에 이러한 데이터형 변환이 안전한지 물어볼 수는 없을까? } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; class Grand { private: int hold; public: Grand(int h = 0) : hold(h) {} // Say() 함수가 없다. virtual void Speak() const { cout \u0026lt;\u0026lt; \u0026#34;Grand 클래스입니다. \\n\u0026#34;; } virtual int Value() const { return hold; } }; class Superb : public Grand { public: Superb(int h = 0) : Grand(h) {} void Speak() const { cout \u0026lt;\u0026lt; \u0026#34;Superb 클래스입니다.\\n\u0026#34;; } virtual void Say() const { cout \u0026lt;\u0026lt; \u0026#34;내가 가지고 있는 값은 \u0026#34; \u0026lt;\u0026lt; Value() \u0026lt;\u0026lt; \u0026#34;!\\n\u0026#34;; } }; class Magnificent : public Superb { private: char ch; public: Magnificent(int h = 0, char c = \u0026#39;A\u0026#39;) : Superb(h), ch(c) {} void Speak() const { cout \u0026lt;\u0026lt; \u0026#34;Magnificent 클래스입니다.\\n\u0026#34;; } void Say() const { cout \u0026lt;\u0026lt; \u0026#34;내가 가지고 있는 문자는 \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34;이고, 정수는 \u0026#34; \u0026lt;\u0026lt; Value() \u0026lt;\u0026lt; \u0026#34;!\\n\u0026#34;; } }; Grand* GetOne() // 세 종류의 객체 중에 하나를 임의로 생성한다. { Grand* p = new Grand(); switch (rand() % 3) { case 0: p = new Grand(rand() % 100); break; case 1: p = new Superb(rand() % 100); break; case 2: p = new Magnificent(rand() % 100, \u0026#39;A\u0026#39; + rand() % 26); break; } return p; } int main() { srand(time(0)); Grand* pg; Superb* ps; for (int i = 0; i \u0026lt; 5; i++) { pg = GetOne(); pg-\u0026gt;Speak(); // Grand 클래스에는 Say()가 없다. // 하지만 dynamic_cast연산자를 사용해서 Superb* 형으로 변환시킬 수 있는지 알아볼 수 있다. // 그러면 Superb형이나 Magnificent형 둘 중 하나일 때 참이 된다. if (ps = dynamic_cast\u0026lt;Superb*\u0026gt;(pg)) ps-\u0026gt;Say(); } } dynamic_cast를 참조와 함께 사용할 수도 있다. 널 포인터형에 해당하는 참조값은 존재하지 않는다. 따라서 실패를 나타내기 위해 bad_cast형의 예외를 발생시킨다. 이것은 exception클래스로부터 파생된 것이다. typeinfo 헤더파일에 정의되어 있다. 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;typeinfo\u0026gt; //... try { Superb\u0026amp; rs = dynamic_cast\u0026lt;Superb\u0026amp;\u0026gt;(rg); } catch (bad_cast\u0026amp;) { //... } typeid 연산자와 type_info 클래스 typeid연산자를 사용하여 두 객체의 데이터형이 같은지 결정할 수 있다. 어떤 객체의 정확한 데이터형을 식별하는 하나의 값을 리턴한다. 매개변수 종류 (1) 클래스의 이름 (2) 객체로 평가되는 식 만약에 매개변수로 주어진 것이 nullptr이면, bad_typeid 예외를 발생시킨다. type_info 객체에 대한 참조를 리턴한다. 어떤 특별한 데이터형에 대한 정보를 저장한다. 이 클래스는 ==과 !=연산자를 오버로딩한다. 안에는 name()멤버가 포함되어 있어서, 가리키는 객체의 클래스 이름을 출력한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int main() { srand(time(0)); Grand* pg; Superb* ps; for (int i = 0; i \u0026lt; 5; i++) { pg = GetOne(); // typeid 클래스에는 가리키는 객체의 클래스의 이름을 리턴하는 name()멤버가 있다. cout \u0026lt;\u0026lt; \u0026#34;지금 처리중인 데이터형: \u0026#34; \u0026lt;\u0026lt; typeid(*pg).name() \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; pg-\u0026gt;Speak(); if (ps = dynamic_cast\u0026lt;Superb*\u0026gt;(pg)) ps-\u0026gt;Say(); // typeid연산자는 매개변수로 클래스 이름이나 객체로 평가되는 식을 받아들인다. // 만약에 pg가 널 포인터이면 bad_typeid 예외를 발생시킨다. if (typeid(Magnificent) == typeid(*pg)) cout \u0026lt;\u0026lt; \u0026#34;그래, 너는 Magnificent형이구나! \\n\u0026#34;; } } 데이터형 변환 연산자 C의 데이터형 변환 연산자는 너무 느슨하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct Data { double data[200]; }; struct Junk { int junk[100]; }; int main() { Data d = { 2.5, 3.5, 20.2 }; // 그 어떤 것도 이치에 맞지 않는다. // 하지만 허용된다. char* pc = (char*)\u0026amp;d; char ch = (char)\u0026amp;d; Junk* pj = (Junk*)\u0026amp;d; } 그래서 데이터형 변환을 더움 엄격하게 규정하는 4개의 데이터형 변환 연산자를 추가하였다. dynamic_cast 앞서 보았듯, 어떤 클래스 계층 내에서(is-a 관계시) 업캐스트를 허용하고, 다른 데이터형 변화는 허용하지 않는 것이다. const_cast static_cast reinterpret_cast const_cast 어떤 값을 const나 volatile로 또는 그 반대로 변경하려는 데이터형 변환을 위한 것이다. 비교하는 두 데이터형은 const나 volatile가 있느냐 없느냐가 다른 것 빼고는, 데이터형이 동일해야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 class High {}; class Low {}; int main() { High h; const High* phc = \u0026amp;h; High* ph = const_cast\u0026lt;High*\u0026gt;(phc); // const High* 를 High*로 (O) const Low* pl = const_cast\u0026lt;const Low*\u0026gt;(phc); // const High* 를 const Low*로 (X) } 포인터의 접근을 변경할 수 있지만, const로 선언된 양을 변경하려는 시도를 그 결과가 정의되지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void change(const int* pt, int n) { int* pc; pc = const_cast\u0026lt;int*\u0026gt;(pt); // const int*형을 int*형으로 변경한다. *pc += n; // 하지만 원래 형이 const 인경우 값을 증가시키지 않는다. } int main() { int pop1 = 20; const int pop2 = 20; cout \u0026lt;\u0026lt; \u0026#34;pop1, pop2: \u0026#34; \u0026lt;\u0026lt; pop1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; pop2 \u0026lt;\u0026lt; endl; // 20, 20 change(\u0026amp;pop1, -5); change(\u0026amp;pop2, -5); // 원래 const 이므로 제대로 동작하지 않는다. cout \u0026lt;\u0026lt; \u0026#34;pop1, pop2: \u0026#34; \u0026lt;\u0026lt; pop1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; pop2 \u0026lt;\u0026lt; endl; // 15, 20 } static_cast 암시적으로 데이터형 변환이 된다면 유효하다. 예를 들어, 열거값은 암시적으로 정수값으로 변환할 수 있기 때문에 static_cast를 사용해서 열거값을 정수값으로 변환할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Base {}; class Derived : public Base {}; class Other {}; int main() { Base base; Derived derived; // 유효한 업캐스트. 명시적으로 이루어질 수 있으므로 유효하다. Base* pb = static_cast\u0026lt;Base*\u0026gt; (\u0026amp;derived); // 유효한 다운캐스트. 반대 방향의 변환이 암시적으로 이루어질 수 있으므로 유효하다. Derived* pd = static_cast\u0026lt;Derived*\u0026gt; (\u0026amp;base); // 유효하지 않다. Other* po = static_cast\u0026lt;Other*\u0026gt; (\u0026amp;derived); } reinterpret_cast 이것은 본래부터 위험한 데이터형 변환을 위한 것이다. 일반적으로 시스템 의존적인 저수준 프로그래밍에서 사용한다. 그러나 이식성이 없다. 예를 들면, 멀티바이트 값을 서로 다른 바이트 순서를 사용하여 저장하는 두 개의 다른 시스템이 있을 수 있다. 모든 것을 허용하지는 않는다. 예를 들면, 포인터형을 포인터형을 충분히 저장할 수 있는 큰 정수형으로 캐스트할 수는 있지만, 포인터형보다 작은 정수형 또는 부동소수점형으로 캐스트할 수는 없다. 또한 함수 포인터를 데이터 포인터로 또는 그 반대로 캐스트할 수 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct Dat { // 2바이트 short a; short b; }; int main() { // lval의 처음 2바이트를 출력한다. long lval = 0xA224B118; Dat* pd = reinterpret_cast\u0026lt;Dat*\u0026gt; (\u0026amp;lval); cout \u0026lt;\u0026lt; pd-\u0026gt;a; } ","date":"2022-03-22T14:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-15-3/","title":"[C++ Primer Plus] Chapter 15. (3) RTTI"},{"content":" 예외 두 수의 조화 평균(harmonic mean)을 계산하는 함수를 만들어보자. 주어진 수들의 역수의 산술 평균을 구한다. 그리고 그것의 역수를 취한다. 구하는 수식은 아래와 같다. 여기서 x가 y의 부정이면 이 공식은 0으로 나누는, 정의할 수 없는 연산이 된다. $$ {2.0 \\times x \\times y \\over ( x + y )} $$\n해결하는 방법 중 하나는, 정의할 수 없는 연산일 때 abort()를 호출하는 것이다. abort()는 cstdlib 헤더 파일에 들어 있다. abort()가 호출되면 표준 에러 스트림(cerr가 사용하는 스트림)에 \u0026ldquo;abnormal program temination\u0026rdquo; (비정상적인 프로그램 종료)과 같은 메시지를 보내고 프로그램이 종료된다. 부모 프로세스나 운영체제의 컴파일러에 종속적인 어떤 값을 리턴한다. 이 때, 파일 버퍼를 비우는지 여부는 C++ 컴파일러 마다 다르다. 원한다면, exit()을 사용해서 메시지를 출력하지 않고, 파일 버퍼를 비울 수 있다. 호출하면, main()으로 다시 돌아가는 일 없이, 그 프로그램을 직접 종료한다. 1 2 3 4 5 6 7 8 9 double HMean(double x, double y) { if (x == -y) // x가 y의 부정이면 0으로 나누게 되므로, abort()를 호출한다. { cout \u0026lt;\u0026lt; \u0026#34;매개변수들을 HMean()에 전달할 수 없습니다. \u0026#34; \u0026lt;\u0026lt; endl; abort(); } return 2.0 * x * y / (x + y); } 비정상 종료보다 더 융통성 있는 방법은, 함수의 리턴값을 사용해서 문제가 무엇인지 알리는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 bool HMean(double x, double y, double* ans) { if (x == -y) { *ans = DBL_MAX; return false; // false를 리턴한다. } else { *ans = 2.0 * x * y / (x + y); return true; } } 이제, 예외 매커니즘을 사용해서 문제를 풀어보자. 예시로 보는 게 빠르겠다. 만약, 데이터형이 일치하는 예외 핸들러(catch 구문)가 없다면 프로그램은 기본적으로 abort()를 호출한다. 이 행동을 사용자가 수정할 수도 있다. (잘못된 예외 파트) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 double HMean(double x, double y) { // 2. throw 키워드로 예외를 발생 시킨다. if (x == -y) throw \u0026#34;x = -y 는 허용되지 않습니다.\u0026#34;; return 2.0 * x * y / (x + y); } int main() { double x, y, z; cout \u0026lt;\u0026lt; \u0026#34;두 수를 입력하세요: \u0026#34;; while (cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { // 1. try 블록에서 예외가 있는지 체크해본다. try { z = HMean(x, y); } // 3. catch 블록에서 예외를 처리한다. catch (const char* s) // 이 핸들러는 문자열로 발생된 예외를 처리한다. { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;두 수를 새로 입력하세요: \u0026#34;; continue; } // 예외가 발생하지 않았다면 이곳으로 바로 넘어온다. cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;의 조화평균은 \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#34;입니다. \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;다른 두 수를 입력하세요(끝내려면 q): \u0026#34;; } } 객체를 예외로 사용하기 기하 평균(geometric mean) 두 수의 곱의 제곱근이다. 수가 음수이면 안 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // 예외를 클래스로 만든다. class BadHMean { private: double v1; double v2; public: BadHMean(double a = 0, double b = 0) : v1(a), v2(b) {} void Mesg() { // 문자열을 출력한다. cout \u0026lt;\u0026lt; \u0026#34;HMean()에 x = -y 는 허용되지 않습니다. \\n\u0026#34;; } }; class BadGMean { public: // 데이터가 public 이다. double v1; double v2; BadGMean(double a = 0, double b = 0) : v1(a), v2(b) {} const char* Mesg() { // 문자열을 리턴한다. return \u0026#34;GMean()에 음수는 허용되지 않습니다. \\n\u0026#34;; } }; double HMean(double x, double y) { if (x == -y) throw BadHMean(x, y); return 2.0 * x * y / (x + y); } double GMean(double x, double y) { if (x \u0026lt; 0 || y \u0026lt; 0) throw BadGMean(x, y); return sqrt(x * y); } int main() { double x, y, z; cout \u0026lt;\u0026lt; \u0026#34;두 수를 입력하세요: \u0026#34;; while (cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { try { z = HMean(x, y); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;의 조화평균은 \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#34;입니다. \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;의 기하평균은 \u0026#34; \u0026lt;\u0026lt; GMean(x, y) \u0026lt;\u0026lt; \u0026#34;입니다. \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;다른 두 수를 입력하세요(끝내려면 q): \u0026#34;; } catch (BadHMean\u0026amp; bg) { bg.Mesg(); cout \u0026lt;\u0026lt; \u0026#34;두 수를 새로 입력하세요: \u0026#34;; continue; // 계속할 수 있다. } catch (BadGMean\u0026amp; hg) { cout \u0026lt;\u0026lt; hg.Mesg(); // public 멤버에 접근한다. cout \u0026lt;\u0026lt; \u0026#34;사용된 값: \u0026#34; \u0026lt;\u0026lt; hg.v1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; hg.v2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;죄송합니다. 더 이상 진행할 수 없습니다. 프로그램을 종료합니다.\u0026#34; \u0026lt;\u0026lt; endl; break; // 종료한다. } } } 스택 풀기(unwinding the stack)\n예외가 발생하면, 호출한 함수를 타고 계속 되돌아가서 try와 catch가 있는 곳으로 되돌아간다. 마치 함수 리턴과 마찬가지다. 가장 중요한건, 스택에 올라와 있는 모든 자동 클래스 객체들에 대해 파괴자가 호출된다는 것이다.\nreturn구문은 해당 함수가 스택에 올려 놓은 객체들만 처리한다. 하지만 throw구문은 try구문과 throw구문 사이에 개입된 모든 함수들이 스택에 올려 놓은 객체를 모두 처리한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 // 생략 class BadHMean {}; class BadGMean {}; double HMean(double x, double y) {} double GMean(double x, double y) {} // 객체의 파괴를 보기 위한 클래스 class Demo { private: string word; public: Demo(const string\u0026amp; str) { word = str; cout \u0026lt;\u0026lt; \u0026#34;Demo가 생성되었다 : \u0026#34; \u0026lt;\u0026lt; word \u0026lt;\u0026lt; endl; } ~Demo() { cout \u0026lt;\u0026lt; \u0026#34;Demo가 파괴되었다 : \u0026#34; \u0026lt;\u0026lt; word \u0026lt;\u0026lt; endl; } void Show() const { cout \u0026lt;\u0026lt; \u0026#34;Demo가 생존하고 있다 : \u0026#34; \u0026lt;\u0026lt; word \u0026lt;\u0026lt; endl; } }; double Means(double a, double b) { double am, hm, gm; Demo d2(\u0026#34;Means()\u0026#34;); // Demo 2 am = (a + b) / 2.0; // 산술 평균 try { hm = HMean(a, b); gm = GMean(a, b); } catch (BadHMean\u0026amp; bg) // HMean만 catch한다. { cout \u0026lt;\u0026lt; \u0026#34;Means()에서 잡힘\u0026#34; \u0026lt;\u0026lt; endl; bg.Mesg(); throw; // main()에 예외를 보낸다. } d2.Show(); return (am + hm + gm) / 3.0; } int main() { double x, y, z; { Demo d1(\u0026#34;main()\u0026#34;); // Demo 1 cout \u0026lt;\u0026lt; \u0026#34;두 수를 입력하세요: \u0026#34;; while (cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { try { z = Means(x, y); // Means() 호출 cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;의 조화평균은 \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#34;입니다. \u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;다른 두 수를 입력하세요(끝내려면 q): \u0026#34;; } catch (BadHMean\u0026amp; bg) { bg.Mesg(); cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;두 수를 새로 입력하세요: \u0026#34;; continue; } catch (BadGMean\u0026amp; hg) // GMean은 여기서 catch한다. { cout \u0026lt;\u0026lt; hg.Mesg(); cout \u0026lt;\u0026lt; \u0026#34;사용된 값: \u0026#34; \u0026lt;\u0026lt; hg.v1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; hg.v2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;죄송합니다. 더 이상 진행할 수 없습니다. 프로그램을 종료합니다.\u0026#34; \u0026lt;\u0026lt; endl; break; } } d1.Show(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Demo가 생성되었다 : main() 두 수를 입력하세요: 6 12 Demo가 생성되었다 : Means() Demo가 생존하고 있다 : Means() Demo가 파괴되었다 : Means() // Means()함수 종료로 파괴되었다. 6, 12의 조화평균은 8.49509입니다. 다른 두 수를 입력하세요(끝내려면 q): 6 -6 Demo가 생성되었다 : Means() Means()에서 잡힘 HMean()에 x = -y 는 허용되지 않습니다. Demo가 파괴되었다 : Means() // throw 구문으로 Means()함수가 종료되었다. 파괴자도 호출된다. HMean()에 x = -y 는 허용되지 않습니다. 두 수를 새로 입력하세요: 6 -8 Demo가 생성되었다 : Means() Demo가 파괴되었다 : Means() // throw 구문으로 Means()함수가 종료되었다. 파괴자도 호출된다. GMean()에 음수는 허용되지 않습니다. 사용된 값: 6, -8 죄송합니다. 더 이상 진행할 수 없습니다. 프로그램을 종료합니다. Demo가 생존하고 있다 : main() Demo가 파괴되었다 : main() // 프로그램 종료로 파괴되었다. catch 블록이 참조를 지정할지라도 컴파일러는 언제나 예외가 발생하면 임시 복사본을 만든다. 왜냐하면, 예외가 발생한 함수 블록이 끝나면 객체는 존재하지 않기 때문이다. 추가적으로, 기초 클래스 참조로 파생 클래스를 참조할 수 있기 때문이겠다. 파생 순서의 역순으로 catch블록들을 배치해야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class A {}; class B : public A {}; class C : public B {}; void Test() { //... if (aa) throw A(); if (bb) throw B(); if (cc) throw C(); } int main() { //... try { Test(); } catch(C\u0026amp; c) { } // C가 먼저 와야 한다. catch(B\u0026amp; b) { } catch(A\u0026amp; a) { } // A가 먼저오면 모든 예외를 A가 catch한다. } 어떤 예외라도 포착하는 방법 1 catch(...) {} exception 클래스 예외 클래스의 기초 클래스로 exception 클래스를 사용할 수 있다. exception 헤더파일에 포함되어 있다. what()이라는 하나의 가상 멤버 함수가 주어진다. 이것을 재정의할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;exception\u0026gt; class BadHMean : public exception { public: // what() 가상함수를 재정의한다. virtual const char * what() { return \u0026#34;HMean()에 x = -y 는 허용되지 않습니다. \\n\u0026#34;; } }; int main() { //... try { } catch (exception\u0026amp; e) // exception 형식으로 포착한다. { cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } } logic_error 클래스와 runtime_error 클래스 stdexcept 헤더파일에 포함되어 있다. exception으로 부터 public으로 파생된다. 다음과 같이, string 매개변수를 받는 생성자를 가지고 있다. 이것은 what()함수의 리턴값으로 사용한다. 1 2 3 4 5 class logic_error : public exception { public: explicit logic_error(const string\u0026amp; what_arg); }; logic_error 클래스 일반적인 논리 에러들을 서술한다. domain_error 예를들어, 아크사인의 정의역은 -1에서 +1까지이다. 이것을 벗어날 때 이 예외를 발생시킬 수 있다. 정의역 (Domain): f: X → Y에서 X를 함수 f의 정의역이라고 한다. 치역 (Range): f(x)가 치역이다. invalid_argument 기대하지 않는 값이 함수에 전달되었을 때. length_error 원하는 액션을 취할 만큼 충분한 공간을 사용할 수 없을 때. out_of_range 인덱싱 에러. runtime_error 클래스 실행하는 동안에 나타날 수 있는 에러를 서술한다. range_error 언더플로나 오버플로 없이 계산 결과가 함수의 절절한 치역을 벗어날 때. overflow_error 정수형이나, 부동소수점형 계산에서 나타낼 수 있는 최대 크기보다 더 큰 값을 산출하는 계산을 할 때. underflow_error 예를 들어, 부동소수점 계산에서 나타낼 수 있는 최소 크기보다 더 작은 값을 산출하는 계산을 할 때. C++이 new를 사용할 때 일어나는 메모리 대입 문제를 해결하는 두 가지 방법 (1) new가 널 포인터를 리턴한다. (2) new가 bad_alloc 예외를 발생시킨다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct Big { double stuff[20000]; }; int main() { Big* pb; try { cout \u0026lt;\u0026lt; \u0026#34;큰 메모리 블록 대입을 요청합니다. \u0026#34; \u0026lt;\u0026lt; endl; pb = new Big[10900]; // 큰 메모리를 대입한다. cout \u0026lt;\u0026lt; \u0026#34;요청을 통과하였습니다. \u0026#34; \u0026lt;\u0026lt; endl; } catch (bad_alloc\u0026amp; ba) // new가 bad_alloc 예외를 발생시킨다. (2) { cout \u0026lt;\u0026lt; \u0026#34;예외가 감지되었습니다!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ba.what() \u0026lt;\u0026lt; endl; exit(EXIT_FAILURE); } cout \u0026lt;\u0026lt; \u0026#34;메모리 블록이 성공적으로 대입되었습니다. \u0026#34; \u0026lt;\u0026lt; endl; pb[0].stuff[0] = 4; cout \u0026lt;\u0026lt; pb[0].stuff[0] \u0026lt;\u0026lt; endl; delete[] pb; } 1 2 3 큰 메모리 블록 대입을 요청합니다. 예외가 감지되었습니다! bad allocation // ba.what()를 출력한 결과 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main() { Big* pb; cout \u0026lt;\u0026lt; \u0026#34;큰 메모리 블록 대입을 요청합니다. \u0026#34; \u0026lt;\u0026lt; endl; pb = new (nothrow) Big[10900]; // new가 널 포인터를 리턴한다. (1) if (pb == nullptr) { cout \u0026lt;\u0026lt; \u0026#34;메모리 블록 대입에 실패하였습니다. \u0026#34; \u0026lt;\u0026lt; endl; exit(EXIT_FAILURE); } cout \u0026lt;\u0026lt; \u0026#34;메모리 블록이 성공적으로 대입되었습니다. \u0026#34; \u0026lt;\u0026lt; endl; pb[0].stuff[0] = 4; cout \u0026lt;\u0026lt; pb[0].stuff[0] \u0026lt;\u0026lt; endl; delete[] pb; } 1 2 큰 메모리 블록 대입을 요청합니다. 메모리 블록 대입에 실패하였습니다. 예외, 클래스, 상속 예외, 클래스, 상속은 서로 상호작용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // Sales.h #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Sales { public: enum { MONTHS = 12 }; // 클래스 정의 안에 내포된 예외 클래스. class bad_index : public logic_error { private: int bi; public: explicit bad_index(int ix, const string\u0026amp; s = \u0026#34;Sales 객체에서 인덱스 에러 발생! \\n\u0026#34;); int bi_val() const { return bi; } virtual ~bad_index() throw() {} }; explicit Sales(int yy = 0); Sales(int yy, const double* gr, int n); virtual ~Sales() { } int Year() const { return year; } virtual double operator[](int i) const; virtual double\u0026amp; operator[](int i); private: double gross[MONTHS]; int year; }; class LabeledSales : public Sales { public: class nbad_index : public Sales::bad_index // 예외 클래스를 파생시킨다. { private: string lbl; public: nbad_index(const string\u0026amp; lb, int ix, const string\u0026amp; s = \u0026#34;LabeledSales 객체에서 인덱스 에러 발생! \\n\u0026#34;); const string\u0026amp; label_val() const { return lbl; } virtual ~nbad_index() throw() {} }; explicit LabeledSales(const string\u0026amp; lb = \u0026#34;none\u0026#34;, int yy = 0); LabeledSales(const string\u0026amp; lb, int yy, const double* gr, int n); virtual ~LabeledSales() { } const string\u0026amp; Label() const { return label; } virtual double operator[](int i) const; virtual double\u0026amp; operator[](int i); private: string label; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Sales.cpp // ... // 배열에서 벗어나는 인덱스에 접근하면 예외가 발생한다. double Sales::operator[](int i) const { if (i \u0026lt; 0 || i \u0026gt;= MONTHS) throw bad_index(i); return gross[i]; } double\u0026amp; Sales::operator[](int i) { if (i \u0026lt; 0 || i \u0026gt;= MONTHS) throw bad_index(i); return gross[i]; } double LabeledSales::operator[](int i) const { if (i \u0026lt; 0 || i \u0026gt;= MONTHS) throw nbad_index(Label(), i); return Sales::operator[](i); } double\u0026amp; LabeledSales::operator[](int i) { if (i \u0026lt; 0 || i \u0026gt;= MONTHS) throw nbad_index(Label(), i); return Sales::operator[](i); } // ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 int main() { double vals1[12] = { 1220, 1100, 1122, 2212, 1232, 2334, 2884, 2393, 3302, 2922, 3002, 3544 }; double vals2[12] = { 12, 11, 22, 21, 32, 34, 28, 29, 33, 29, 32, 35 }; Sales sales1(2011, vals1, 12); LabeledSales sales2(\u0026#34;Blogstar\u0026#34;, 2012, vals2, 12); cout \u0026lt;\u0026lt; \u0026#34;첫번째 try 블록\\n\u0026#34;; try { cout \u0026lt;\u0026lt; sales2[12] \u0026lt;\u0026lt; endl; // 배열을 넘어가는 인덱스에 접근한다. (LabeledSales) } catch (LabeledSales::nbad_index\u0026amp; bad) { cout \u0026lt;\u0026lt; bad.what(); cout \u0026lt;\u0026lt; \u0026#34;Company: \u0026#34; \u0026lt;\u0026lt; bad.label_val() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;bad index: \u0026#34; \u0026lt;\u0026lt; bad.bi_val() \u0026lt;\u0026lt; endl; } catch (Sales::bad_index\u0026amp; bad) { cout \u0026lt;\u0026lt; bad.what(); cout \u0026lt;\u0026lt; \u0026#34;bad index: \u0026#34; \u0026lt;\u0026lt; bad.bi_val() \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;\\n두번째 try 블록\\n\u0026#34;; try { sales1[20] = 23345; // 배열을 넘어가는 인덱스에 접근한다. (Sales) } catch (LabeledSales::nbad_index\u0026amp; bad) { cout \u0026lt;\u0026lt; bad.what(); cout \u0026lt;\u0026lt; \u0026#34;Company: \u0026#34; \u0026lt;\u0026lt; bad.label_val() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;bad index: \u0026#34; \u0026lt;\u0026lt; bad.bi_val() \u0026lt;\u0026lt; endl; } catch (Sales::bad_index\u0026amp; bad) { cout \u0026lt;\u0026lt; bad.what(); cout \u0026lt;\u0026lt; \u0026#34;bad index: \u0026#34; \u0026lt;\u0026lt; bad.bi_val() \u0026lt;\u0026lt; endl; } } 잘못된 예외 예외가 발생한 후에도 문제를 일으킬 수 있는 두 가지 가능성이 있다.\n1. 기대하지 않는 예외(unexpected exception) 발생한 예외는 예외 지정자 리스트에 있는 데이터형들 중의 어느 하나와 일치해야한다. 만약 일치하지 않으면, 기본적으로 프로그램이 중지된다. 2. 포착되지 않는 예외(uncaught exception) 예외는 반드시 포착되어야 한다. 만약 포착되지 않으면, (try나 catch 구문이 없을 때) 기본적으로 프로그램이 중지된다. 이 두 가지 예외가 발생했을 때, 프로그램이 중지가 아닌 다른 응답을 하도록 사용자가 바꿀 수 있다.\n2. 포착되지 않는 예외\n이 예외가 발생하면 terminate()함수가 호출되고, 이 함수가 abort()를 호출한다. terminate()함수가 abort()말고 다른 함수를 호출하도록 바꿀 수 있겠다. terminate()함수의 행동을 바꾸는 set_terminate()함수를 사용하면 된다. terminate()함수와 set_terminate()함수는 exception 헤더 파일에 선언되어 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;exception\u0026gt; using namespace std; // 포착되지 않는 예외 발생 시 이렇게 행동하라. void myQuit() // 형식은 매개변수와 리턴형이 void여야한다. { cout \u0026lt;\u0026lt; \u0026#34;포착되지 않는 예외가 발생하여 프로그램을 중지시킵니다. \u0026#34; \u0026lt;\u0026lt; endl; exit(5); // 종료 상태값 5를 가지고 exit() 함수를 호출한다. } int main() { set_terminate(myQuit); // 함수를 설정한다. throw; // 포착되지 않는 예외. } 1. 기대하지 않는 예외\n이 예외가 발생하면 unexpected()함수가 호출되고, 이 함수가 terminate()를 호출한다. 그리고 terminate()가 abort()를 호출한다.\nunexpected()함수의 행동을 바꾸는 set_unexpected()함수를 사용하면 된다.\n이 함수들도 exception 헤더 파일에 선언되어 있다.\nset_unexpected()함수의 선택지\n(1) terminate() 또는 abort() 또는 exit()을 사용해서 프로그램을 종료시킬 수 있다. (2) 새로운 예외를 발생시킬 수 있다. 예외가 이전과 일치하면, 새로 발생된 예외와 일치하면 catch 블록을 찾는다. 예외가 이전과 불일치하고, 이전 예외 지정에 bad_exception형이 없으면 terminate()를 호출한다. 예외가 이전과 불일치하고, 이전 예외 지정에 bad_exception형이 있으면 bad_exception형의 예외로 대체된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // **** 예상대로 작동하지 않아서 확인이 필요합니다. *** void myUnexpected() { throw; // 새로운 예외를 발생시킨다. } double Argh(double, double) throw(out_of_range, bad_exception) // out_of_range, bad_exception의 예외를 발생시킨다. { throw length_error(\u0026#34;length_error\u0026#34;); } int main() { set_unexpected(myUnexpected); try { int x = Argh(1.0, 2.0); } catch (out_of_range\u0026amp; ex) { cout \u0026lt;\u0026lt; \u0026#34;out_of_range\u0026#34; \u0026lt;\u0026lt; endl; } catch (bad_exception\u0026amp; ex) { cout \u0026lt;\u0026lt; \u0026#34;bad_exception\u0026#34; \u0026lt;\u0026lt; endl; // 예외 지정에 bad_exception이 있으므로 이것이 실행된다. } } 예외 주의사항 예외를 사용하면 프로그램의 크기가 커지고, 실행 속도가 떨어진다. 예외 지정들은 템플릿과는 잘 어울리지 않는다. 왜냐하면, 템플릿은 특수화에 따라 서로 다른 종류의 예외를 발생시킬 수 있기 때문이다. 예외와 동적 메모리 대입도 항상 잘 어울리는 것은 아니다. 1 2 3 4 5 6 7 8 9 void Test() { int* ar = new int[10]; throw; // 예외 발생! delete[] ar; // 실행되지 않는다! return; } 위와 같은 코드에서 메모리 누수를 다음 코드와 같이 해결할 수 있다. 하지만, 실수로 무언가를 빠트리거나 다른 에러를 저지를 가능성을 높인다. 또 다른 해결책은 auto_ptr을 사용하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void Test() { int* ar = new int[10]; try { throw exception(); } catch (exception\u0026amp; ex) { delete[] ar; // 메모리를 해제하고 throw; // 한번 더 예외를 발생시킨다. } delete[] ar; return; } 예외 지정(expection specification) 함수에서 발생 가능한 예외의 종류를 명확하게 지정할 수 있다. 하지만 예외지정이 의도대로 지정되지 않는 문제가 있어서 C++11표준은 예외 지정을 사용하지 말 것을 권고한다. 그러나 예외를 발생하지 않는 함수에 대해서 명시할 필요가 있다고 판단하였고, noexcept키워드를 추가하였다. 1 2 void Function1() throw(bad_dog) // bad_dog 타입 예외를 발생시킨다. void Function2() throw() // 예외를 발생시키지 않는다. 1 void Function3() noexcept // 예외를 발생시키지 않는다. ","date":"2022-03-22T13:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-15-2/","title":"[C++ Primer Plus] Chapter 15. (2) 예외"},{"content":" 클래스 프렌드 지금까지는 프렌드 함수를 살펴봤는데, 클래스도 프렌드가 될 수 있다.\nTV 클래스와 리모콘 클래스를 생각해보자.\n둘은 is-a 관계도 아니며 has-a 관계도 아니다. 하지만 리모콘은 TV의 상태를 변경할 수 있다. 이것은 리모콘 클래스를 TV 클래스의 프렌드로 만들어야 한다는 것을 암시한다. 프렌드 선언은 private, protected, public 부분 어디에 두던 상관 없다.\n컴파일러가 Remote 클래스를 처리하기 전에 Tv 클래스에 대해 알아야 한다.\n방법 (1) Tv 클래스를 먼저 정의한다. (아래 예제) (2) 사전 선언(forward declaration) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Tv // Tv를 먼저 선언해서 Remote가 Tv를 알도록 한다. (1) { private: int state; // on 또는 off int volume; // 디지털 볼륨이라고 가정한다 int maxchannel; // 최대 채널 수 int channel; // 현재 설정된 채널 int mode; // 지상파 방송 또는 케이블 방송 int input; // TV 입력 또는 DVD 입력 public: // friend 선언은 어디에 있어도 상관 없다. friend class Remote; // Tv의 private 부분에 Remote의 모든 메서드들이 접근할 수 있다. enum { Off, On }; enum { MinVal, MaxVal = 20 }; enum { Antenna, Cable }; enum { TV, DVD }; Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {} void OnOff() { state = (state == On) ? Off : On; } // state = state ^ 1; 혹은 state ^= 1; 와 같다. (XOR) bool IsOn() const { return state == On; } bool VolUp(); bool VolDown(); void ChanUp(); void ChanDown(); void SetMode() { mode = (mode == Antenna) ? Cable : Antenna; } void SetInput() { input = (input == TV) ? DVD : TV; } void Settings() const; }; class Remote { private: int mode; // TV 컨트롤 또는 or DVD 컨트롤 public: Remote(int m = Tv::TV) : mode(m) {} void OnOff(Tv\u0026amp; t) { t.OnOff(); } bool VolUp(Tv\u0026amp; t) { return t.VolUp(); } bool VolDown(Tv\u0026amp; t) { return t.VolDown(); } void ChanUp(Tv\u0026amp; t) { t.ChanUp(); } void ChanDown(Tv\u0026amp; t) { t.ChanDown(); } void SetChan(Tv\u0026amp; t, int c) { t.channel = c; } // Tv의 private 멤버인 channel에 접근할 수 있다. void SetMode(Tv\u0026amp; t) { t.SetMode(); } void SetInput(Tv\u0026amp; t) { t.SetInput(); } }; 만약에 프렌드가 아니었다면? Tv 클래스의 private 부분을 public으로 만들어야 한다. 혹은 Tv와 Remote가 함께 들어간 클래스를 만들어야 한다. 이렇게 하면 하나의 Remote로 여러대의 Tv를 제어하는 것을 반영하지 못할 것이다. 프렌드 멤버 함수 위의 예시에서 유일하게 프렌드 자격이 필요한 부분은 Remote::SetChan() 뿐이다.\n클래스 전체를 프렌드로 하지 않고 필요한 메서드들만 프렌드로 만들면 어떨까?\nTv 클래스 안에 프렌드 자격을 부여할 Remote::SetChan()를 선언할 수 있다.\n하지만, 이렇게 하려면 컴파일러가 Remote 클래스 선언을 먼저 알아서, 그 안에 SetChan() 메서드가 있다는 걸 알아야 한다. 그렇다고 Remote 정의를 Tv 정의 앞에 두기에는, Remote::SetChan()이 Tv를 사용하기 때문에 Remote도 Tv를 먼저 알아야 한다. 1 2 3 4 5 class Tv { // Remote 클래스 선언을 먼저 알아야 한다. friend void Remote::SetChan(Tv\u0026amp; t, int c); // Tv의 private 부분에 Remote의 특정 메서드만 접근할 수 있다. }; 이러한 순환 종속을 피하는 방법은, 사전 선언을 사용하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 class Tv; // Remote가 Tv를 알도록 한다. (2) class Remote { void Remote::SetChan(Tv\u0026amp; t, int c); // 사전 선언을 했으므로, Remote는 Tv를 알고 있다. }; class Tv { friend void Remote::SetChan(Tv\u0026amp; t, int c); // Tv는 Remote의 선언을 알고 있다. }; 순서를 반대로 하는 것은 안 된다. 왜냐하면, Tv는 Remote 안에 SetChan() 메서드가 있는 걸 먼저 알아야하기 때문이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // (X) class Remote; class Tv { friend void Remote::SetChan(Tv\u0026amp; t, int c); // Tv는 Remote 안에 SetChan() 메서드가 있는 걸 알아야한다. } class Remote { void Remote::SetChan(Tv\u0026amp; t, int c); } 또 다른 문제가 있다. Remote::OnOff()에서 Tv::OnOff()를 호출한다. 이것은 Remote가 Tv의 클래스 선언을 미리 알아야 하며, 그래서 Tv가 어떤 메서드들을 가지고 있는지 알아야 한다는 것을 의미한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Tv; class Remote { void OnOff(Tv\u0026amp; t) { t.OnOff(); // Tv의 클래스 선언을 먼저 알아서 그 안에 OnOff() 메서드가 있다는 걸 알아야 한다. } }; class Tv { void OnOff(); }; 해결책 인라인 함수로 만들고 싶다면, -Remote 클래스 선언 안에는 메서드를 선언만 하고, 정의는 Tv 클래스 뒤에 둔다. 혹은 인라인 함수로 만들지 않고, 정의를 .cpp 파일에 넣는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Tv; class Remote { void OnOff(Tv\u0026amp; t); // 선언만 한다. }; class Tv { void OnOff(); }; // Tv 뒤에 (Tv 클래스 선언을 알고 나서) 정의를 한다. (인라인) inline void Remote::OnOff(Tv\u0026amp; t) { t.OnOff(); } 상호 프렌드와 공유 프렌드 상호 프렌드(mutual friend) 각 클래스가 서로에 대해 프렌드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Tv { friend class Remote; // Remote의 모든 메서드는 Tv의 private 부분에 접근 가능하다. public: void Buzz(Remote\u0026amp; r); // Remote의 메서드를 사용하려면 Remote 클래스 선언 뒤에 나와야 하므로 일단 선언만한다. void VolUp() { } }; class Remote { friend class Tv; // Tv의 모든 메서드는 Remote의 private 부분에 접근 가능하다. public: void VolUp(Tv \u0026amp; t) { t.VolUp(); } }; // Remote 뒤에 정의를 둔다. inline void Tv::Buzz(Remote \u0026amp; r) { // ... } 공유 프렌드 하나의 함수가 서로 다른 두 클래스의 private 데이터 모두에 접근해야 할 때 사용한다. 한 클래스의 멤버로 그 함수를 두고, 다른 클래스에서 friend로 선언할수도 있겠다. 하지만 때로는, 두 클래스 모두에 대해 프렌드로 만드는 것이 합리적인 경우가 있다. 예를 들어, 측정하는 장치인 Probe 클래스와 분석하는 장치인 Analyzer 클래스가 있다고 하자. 각 클래스는 내부에 시계를 하나씩 가지고 있는데, 그 두 시계를 서로 일치시키고 싶다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Analyzer; class Probe { // Sync 함수들은 Probe의 private 부분에 접근 가능하다. friend void Sync(Analyzer\u0026amp; a, const Probe\u0026amp; p); // a를 p에 맞춘다. friend void Sync(Probe\u0026amp; p, const Analyzer\u0026amp; a); // p를 a에 맞춘다. }; class Analyzer { // Sync 함수들은 Analyzer private 부분에 접근 가능하다. friend void Sync(Analyzer\u0026amp; a, const Probe\u0026amp; p); friend void Sync(Probe\u0026amp; p, const Analyzer\u0026amp; a); }; // 프렌드 함수들을 정의한다. inline void Sync(Analyzer\u0026amp; a, const Probe\u0026amp; p) {} inline void Sync(Probe\u0026amp; p, const Analyzer\u0026amp; a) {} 내포 클래스 다른 클래스 안에 선언된 클래스를 내포 클래스라 한다. 한 클래스 안에서만 지역적으로 알려진다. 일반적으로, 다른 클래스 구현을 지원하거나, 이름 충돌을 막기 위해 사용된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Queue { private: class Node // Queue 클래스 안에 Node 클래스가 내포되었다. { public: int item; Node * next; Node(const Item\u0026amp; i) : item(i), next(nullptr) {} }; public: void Enqueue(const Item \u0026amp; item) { // ... Node * add = new Node(item); // 좀 더 간단해졌다. //... } }; 1 2 3 // 만약에 Node 클래스의 생성자를 .cpp 파일에 넣고 싶다면 이렇게 하면 된다. // 사용 범위 결정 연산자를 두 번 쓴다. Queue::Node::Node(const Item\u0026amp; i) : item(i), next(nullptr) {} 내포 클래스, 내포 구조체, 내포 열거체의 사용 범위 특성 내포하는 클래스에 선언된 장소 내포하는 클래스에서 사용 여부 내포하는 클래스에서 파생된 클래스에서 사용 여부 바깥 세계에서 사용 여부 private 부분 O X X protected 부분 O O X public 부분 O O O (클래스 제한자 사용) 1 2 3 4 5 6 7 8 9 10 class Team { public: // public 부분에 선언됨 class Coach {}; }; int main() { Team::Coach c; // 바깥에서 클래스 제한자 사용해서 접근 가능 } 접근 제어 어떤 특정 클래스가 사용 범위 안에 들어오면, 일반적인 접근 제어 규칙(public, protected, private)이 접근 가능 여부를 결정한다. Queue 예제에서 Node의 모든 데이터가 public으로 선언되었다. 이것은 일반적인 관행에 위배된다. 하지만 Queue 클래스의 private 부분에 Node가 선언되었으므로, 바깥 세계에서는 보이지 않는다. 템플릿에 내포된 클래스 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 // QueueTP.h template \u0026lt;class Item\u0026gt; class QueueTP { private: enum { Q_SIZE = 10 }; class Node // 내포된 클래스 Node { public: Item item; // 포괄적 데이터형 Item을 사용한다. Node* next; Node(const Item\u0026amp; i) :item(i), next(0) { } }; Node* front; Node* rear; int items; const int qsize; QueueTP(const QueueTP\u0026amp; q) : qsize(0) {} QueueTP\u0026amp; operator=(const QueueTP\u0026amp; q) { return *this; } public: QueueTP(int qs = Q_SIZE); ~QueueTP(); bool IsEmpty() const { return items == 0; } bool IsFull() const { return items == qsize; } int QueueCount() const { return items; } bool Enqueue(const Item\u0026amp; item); bool Dequeue(Item\u0026amp; item); }; template \u0026lt;class Item\u0026gt; QueueTP\u0026lt;Item\u0026gt;::QueueTP(int qs) : qsize(qs) { front = rear = 0; items = 0; } template \u0026lt;class Item\u0026gt; QueueTP\u0026lt;Item\u0026gt;::~QueueTP() { Node* temp; while (front != 0) { temp = front; front = front-\u0026gt;next; delete temp; } } template \u0026lt;class Item\u0026gt; bool QueueTP\u0026lt;Item\u0026gt;::Enqueue(const Item\u0026amp; item) { if (IsFull()) return false; Node* add = new Node(item); items++; if (front == 0) front = add; else rear-\u0026gt;next = add; rear = add; return true; } template \u0026lt;class Item\u0026gt; bool QueueTP\u0026lt;Item\u0026gt;::Dequeue(Item\u0026amp; item) { if (front == 0) return false; item = front-\u0026gt;item; items--; Node* temp = front; front = front-\u0026gt;next; delete temp; if (items == 0) rear = 0; return true; } ","date":"2022-03-22T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-15-1/","title":"[C++ Primer Plus] Chapter 15. (1) 클래스 프렌드와 프렌드 멤버 함수, 내포 클래스"},{"content":" 코드의 재활용성을 높이는 방법 public 상속 컨테인먼트(containment) = 컴포지션(composition) = 레이어링(layering) private 상속 protected 상속 클래스 템플릿 (이것에 대해 알아보겠다.) 클래스 템플릿 Stack과 Queue를 구현한 클래스를 떠올려보자. 저장되는 객체형이 double일 수도 있고, string일 수도 있다. 그렇다면 바뀔 때마다 코드를 새로 작성할 것인가? 포괄적인(데이터형과 무관한) 방식으로 정의하면 좋지 않을까? 클래스 템플릿의 정의 템플릿들은 함수가 아니다. 그래서 개별적으로 컴파일할 수 없다. 따라서 모든 템플릿 관련 정보를 헤더 파일에 집어 넣는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // Stack.h template \u0026lt;class Type\u0026gt; // 템플릿 클래스이다. class Stack { private: enum { MAX = 10 }; Type items[MAX]; int top; public: Stack(); bool IsEmpty(); bool IsFull(); bool Push(const Type\u0026amp; item); bool Pop(Type\u0026amp; item); }; template \u0026lt;class Type\u0026gt; // 템플릿 멤버 함수이다. Stack\u0026lt;Type\u0026gt;::Stack() // 클래스 제한자가 Stack\u0026lt;Type\u0026gt; 이다. 인라인이면 생략가능하다. { top = 0; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::IsEmpty() { return top == 0; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::IsFull() { return top == MAX; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::Push(const Type\u0026amp; item) { if (top \u0026lt; MAX) { items[top++] = item; return true; } return false; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::Pop(Type\u0026amp; item) { if (top \u0026gt; 0) { item = items[--top]; return true; } return false; } 템플릿 클래스의 사용 구체화를 요청해야 템플릿 클래스가 생성된다. 아래 예제에서는 두 개의 서로 다른 클래스 선언과 메서드들의 집합이 생성될 것이다. 1 2 Stack\u0026lt;int\u0026gt; iStack; // int 값들의 스택을 생성한다. Stack\u0026lt;double\u0026gt; dStack; // double 값들의 스택을 생성한다. 일반적인 함수 템플릿과 다르게, 사용하려는 데이터형을 명시적으로 제공해야 한다. Type과 같은 포괄적인 데이터형 식별자를 데이터형 매개변수라고 한다. 1 2 3 4 5 6 7 // 일반적인 함수 템플릿 template \u0026lt;class T\u0026gt; void Simple(T t) { cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } Simple(2); // 컴파일러가 데이터형을 판단해서 결정한다. Simple(\u0026#34;two\u0026#34;); 포인터들의 Stack을 만드면 어떨까?\nstring 데이터형을 사용하는 원본 코드\n1 2 3 4 Stack\u0026lt;string\u0026gt; ss; string po; cin \u0026gt;\u0026gt; po; [시도 1] po를 char * 로 바꿔본다. 입력이 안 된다. 1 2 3 4 Stack\u0026lt;char *\u0026gt; sc; char* po; cin \u0026gt;\u0026gt; po; // (X) 저장 공간도 없는 곳에 저장할 수 없다. [시도 2] po를 char 배열형으로 바꿔본다. 입력이 된다. 하지만 Pop()에서 불화를 일으킨다. 1 2 3 4 5 6 7 8 Stack\u0026lt;char *\u0026gt; sc; char po[40]; cin \u0026gt;\u0026gt; po; // (O) //... sc.Pop(po); 1 2 3 4 5 6 7 8 9 10 11 template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::Pop(Type\u0026amp; item) // 배열이름을 참조한다. { if (top \u0026gt; 0) { item = items[--top]; // 배열이름에 대입할 수는 없다. return true; } return false; } [시도 3] po를 char * 로 바꾸고 저장 공간을 대입한다. 입력이 되고, 괜찮지만, 근본적인 문제가 발생한다. po가 늘 같은 메모리 위치를 지시하므로, 푸시를 여러번 해도 동일한 주소를 스택에 넣는다. 1 2 3 4 5 6 7 8 9 10 Stack\u0026lt;char *\u0026gt; sc; char* po = new char[40]; cin \u0026gt;\u0026gt; po; // (O) sc.Push(po); cin \u0026gt;\u0026gt; po; sc.Push(po); // 매번 같은 주소가 들어간다. sc.Pop(po); // 매번 같은 주소가 나온다. 포인터들의 스택을 바르게 만드는 방법 char* po 대신 포인터들의 배열을 제공한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 template \u0026lt;class Type\u0026gt; class Stack { private: enum { SIZE = 10 }; int stacksize; Type* items; // 스택 항목들을 저장한다. int top; public: explicit Stack(int ss = SIZE); Stack(const Stack\u0026amp; st); // 복사 생성자를 제공한다. ~Stack() { delete[] items; } // 파괴자를 제공한다. bool IsEmpty() { return top == 0; } bool IsFull() { return top == stacksize; } bool Push(const Type\u0026amp; item); bool Pop(Type\u0026amp; item); // 클래스 사용 범위 안에서는 Stack\u0026lt;Type\u0026gt;을 Stack으로 표현할 수 있다. Stack\u0026amp; operator=(const Stack\u0026amp; st); // 대입 연산자를 제공한다. }; template \u0026lt;class Type\u0026gt; Stack\u0026lt;Type\u0026gt;::Stack(int ss) : stacksize(ss), top(0) { items = new Type[stacksize]; } template \u0026lt;class Type\u0026gt; Stack\u0026lt;Type\u0026gt;::Stack(const Stack\u0026amp; st) { stacksize = st.stacksize; top = st.top; items = new Type[stacksize]; for (int i = 0; i \u0026lt; top; i++) items[i] = st.items[i]; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::Push(const Type\u0026amp; item) { if (top \u0026lt; stacksize) { items[top++] = item; return true; } return false; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::Pop(Type\u0026amp; item) { if (top \u0026gt; 0) { item = items[--top]; return true; } return false; } template \u0026lt;class Type\u0026gt; Stack\u0026lt;Type\u0026gt;\u0026amp; Stack\u0026lt;Type\u0026gt;::operator=(const Stack\u0026lt;Type\u0026gt;\u0026amp; st) { if (this == \u0026amp;st) return *this; delete[] items; stacksize = st.stacksize; top = st.top; items = new Type[stacksize]; for (int i = 0; i \u0026lt; top; i++) items[i] = st.items[i]; return *this; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { Stack\u0026lt;const char*\u0026gt; st(5); const char* inputs[10] = { \u0026#34;Bob\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Amy\u0026#34;, \u0026#34;Amanda\u0026#34;, \u0026#34;Kal\u0026#34;, \u0026#34;Lily\u0026#34;, \u0026#34;Andy\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Kim\u0026#34;, \u0026#34;Ron\u0026#34;}; const char* outputs[10]; st.Push(inputs[0]); st.Push(inputs[1]); st.Push(inputs[2]); st.Push(inputs[3]); st.Pop(outputs[0]); cout \u0026lt;\u0026lt; outputs[0] \u0026lt;\u0026lt; endl; // inputs[3] \u0026#34;Amanda\u0026#34; st.Push(inputs[4]); st.Pop(outputs[1]); cout \u0026lt;\u0026lt; outputs[1] \u0026lt;\u0026lt; endl; // inputs[4] \u0026#34;Kal\u0026#34; // ... } 데이터형이 아닌, 수식 매개변수(expression argument) 조건 (1) 정수형 (2) 열거형 (3) 참조 (4) 포인터 수식 매개변수의 값을 변경하거나 그것의 주소를 얻을 수 없다. 장점 생성자 접근 방식은 new와 delete에 의해 관리되는 힙 메모리를 사용하지만, 수식 매개변수 접근 방식은 스택 메모리를 사용한다. 따라서 더 빠르다. 단점 수식 매개변수가 다르면 자신만의 템플릿을 각각 생성한다. 생성자 접근 방식은 stacksize를 멤버로 가지고 있기 때문에 좀 더 융통성이 있다. 예를 들면, 이것으로 다른 크기의 배열에 대입하거나, 크기를 조절할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 template \u0026lt;class T, int n\u0026gt; // int n은 수식 매개변수이다. class ArrayTP { private: T ar[n]; // 스택을 사용한다. public: ArrayTP() {}; explicit ArrayTP(const T\u0026amp; v); virtual T\u0026amp; operator[](int i); virtual T operator[](int i) const; }; template \u0026lt;class T, int n\u0026gt; ArrayTP\u0026lt;T, n\u0026gt;::ArrayTP(const T\u0026amp; v) { for (int i = 0; i \u0026lt; n; i++) ar[i] = v; } template \u0026lt;class T, int n\u0026gt; T\u0026amp; ArrayTP\u0026lt;T, n\u0026gt;::operator[](int i) { if (i \u0026lt; 0 || i \u0026gt;= n) { std::cerr \u0026lt;\u0026lt; \u0026#34;배열의 경계를 벗어나는 에러: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; --\u0026gt; 잘못된 인덱스입니다. \\n\u0026#34;; std::exit(EXIT_FAILURE); } return ar[i]; } template \u0026lt;class T, int n\u0026gt; T ArrayTP\u0026lt;T, n\u0026gt;::operator[](int i) const { if (i \u0026lt; 0 || i \u0026gt;= n) { std::cerr \u0026lt;\u0026lt; \u0026#34;배열의 경계를 벗어나는 에러: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; --\u0026gt; 잘못된 인덱스입니다. \\n\u0026#34;; std::exit(EXIT_FAILURE); } return ar[i]; } 1 2 3 4 5 6 7 // 12, 13. 수식 매개변수가 다르므로 서로 다른 두개의 클래스 선언을 생성한다. ArrayTP\u0026lt;double, 12\u0026gt; a1; ArrayTP\u0026lt;double, 13\u0026gt; a2; // 하나의 클래스 선언을 생성한다. Stack\u0026lt;double\u0026gt; s1(12); Stack\u0026lt;double\u0026gt; s2(13); 템플릿 클래스의 융통성 (1) 기초 클래스의 역할을 할 수 있다. (2) 성분 클래스가 될 수도 있다. (3) 데이터형 매개변수가 될 수도 있다. (4) 템플릿을 재귀적으로 사용할 수 있다. (5) 하나 이상의 데이터형 매개변수를 사용할 수 있다. (6) 데이터형 매개변수에 디폴트 값을 제공할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;class T\u0026gt; class A { }; template \u0026lt;class T\u0026gt; class B : public A\u0026lt;T\u0026gt; // 1. 템플릿 클래스 A를 상속한다. { }; template \u0026lt;class T\u0026gt; class Other { A\u0026lt;T\u0026gt; a; // 2. 성분으로 사용될 수 있다. }; int main() { A\u0026lt;Other\u0026lt;int\u0026gt;\u0026gt; a1; // 3. 데이터형 매개변수가 될 수 있다. } 1 2 3 ArrayTP\u0026lt;ArrayTP\u0026lt;int, 5\u0026gt;, 10\u0026gt; ar; // 4. 템플릿을 재귀적으로 사용할 수 있다. // int ar[10][5]; 와 동일하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;class T1, class T2\u0026gt; // 5. 하나 이상의 데이터형 매개변수를 사용할 수 있다. class Pair { private: T1 a; T2 b; public: Pair(T1 aVal, T2 bVal) : a(aVal), b(bVal) {} }; int main() { Pair\u0026lt;string, int\u0026gt; p(\u0026#34;이동갈비\u0026#34;, 5); Pair\u0026lt;string, int\u0026gt; p(\u0026#34;태릉갈비\u0026#34;, 5); } 1 2 template\u0026lt;class T1 = string, class T2 = int\u0026gt; // 6. 데이터형 매개변수에 디폴트 값을 제공할 수 있다. class Pair {}; 클래스 템플릿 매개변수와는 다르게, 함수 템플릿 매개변수에는 디폴트 값을 제공할 수 없다. 하지만, 둘 다 데이터형이 아닌(수식) 매개변수에 대해서는 디폴트 값을 제공할 수 있다.\n템플릿 클래스의 특수화 (1) 암시적 구체화 지금까지 살펴 본 예제들과 같이, 객체를 선언하면 컴파일러가 하나의 특수화된 클래스 정의를 생성하는 것이다. 컴파일러는 객체가 요구될 때까지 그 클래스의 암시적 구체화를 생성하지 않는다. 1 2 3 4 ArrayTP\u0026lt;int, 10\u0026gt; ar; // 암시적 구체화 ArrayTP\u0026lt;int, 10\u0026gt; * pt; // 포인터, 아직 객체가 필요없다. pt = new ArrayTP\u0026lt;int, 10\u0026gt; // 이제 객체가 요구된다. (2) 명시적 구체화 template 키워드를 사용하여 클래스를 선언하고, 사용하려는 데이터형을 나타냈을 때 컴파일러는 명시적 구체화를 생성한다. 그 선언은 템플릿 정의와 동일한 이름 공간 안에 있어야 한다. 1 template class ArrayTP\u0026lt;int, 10\u0026gt;; // ArrayTP\u0026lt;int, 10\u0026gt; 클래스를 생성한다. (3) 명시적 특수화 포괄적인 데이터형 대신에 구체적인 하나의 데이터형에 맞게 정의된 템플릿 형식을 취한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template \u0026lt;class T\u0026gt; class SortedArray { //... }; // char *형을 위한 특수화된 템플릿을 제공한다. template \u0026lt;\u0026gt; class SortedArray\u0026lt;char *\u0026gt; { //... }; int main() { SortedArray\u0026lt;int\u0026gt; i; // 포괄적인 정의를 사용한다. SortedArray\u0026lt;char *\u0026gt; c; // 특수화된 정의를 사용한다. } 함수 vs 클래스 특징 함수 클래스 암시적 구체화 Swap(2, 3); ArrayTP\u0026lt;int, 10\u0026gt; a; 명시적 구체화 template void Swap\u0026lt;int\u0026gt;(int, int) template class ArrayTP\u0026lt;int 10\u0026gt; 명시적 특수화 template \u0026lt;\u0026gt; void Swap\u0026lt;int\u0026gt;(int, int) template \u0026lt;\u0026gt; class SortedArray\u0026lt;char *\u0026gt; 부분적인 특수화 템플릿의 포괄성을 일부 제한한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // 포괄적인 템플릿 template \u0026lt;class T1, class T2\u0026gt; class Pair { //... }; // T2를 int로 설정한, 부분적인 특수화 template \u0026lt;class T1\u0026gt; class Pair\u0026lt;T1, int\u0026gt; { //... } 컴파일러는 가장 특수화된 템플릿을 사용한다.\n멤버, 매개변수로써의 템플릿 클래스 템플릿은 구조체, 클래스, 템플릿 클래스의 멤버가 될 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 template \u0026lt;typename T\u0026gt; class Beta { private: template \u0026lt;typename V\u0026gt; // 내포된 템플릿 클래스 멤버 class hold { private: V val; public: hold(V v = 0) : val(v) {} void show() const { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } V Value() const { return val; } }; hold\u0026lt;T\u0026gt; q; // 템플릿 객체 hold\u0026lt;int\u0026gt; n; public: Beta(T t, int i) : q(t), n(i) {} template\u0026lt;typename U\u0026gt; // 템플릿 메서드 U Blab(U u, T t) { return (n.Value() + q.Value()) * u / t; } void Show() const { q.show(); n.show(); } }; int main() { // T가 3.5이므로 double로 설정된다. Beta\u0026lt;double\u0026gt; guy(3.5, 3); guy.Show(); // U가 10이므로 int가 된다. 그래서 리턴형도 int이다. cout \u0026lt;\u0026lt; guy.Blab(10, 2.3) \u0026lt;\u0026lt; endl; // U가 10.0이므로 double이 된다. 그래서 리턴형도 double이다. cout \u0026lt;\u0026lt; guy.Blab(10.0, 2.3) \u0026lt;\u0026lt; endl; } 매개변수 템플릿 데이터형, 수식말고도 템플릿 자체가 템플릿 매개변수로 들어갈 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // template \u0026lt;typename T\u0026gt; class 데이터형인 Thing이 매개변수가 된다. // 이전에 보았던 Stack이 그렇다. template \u0026lt;template \u0026lt;typename T\u0026gt; class Thing\u0026gt; class Crab { private: Thing\u0026lt;int\u0026gt; s1; // Stack\u0026lt;int\u0026gt; s1; Thing\u0026lt;double\u0026gt; s2; // Stack\u0026lt;double\u0026gt; s1; public: Crab() {}; bool push(int a, double x) { return s1.push(a) \u0026amp;\u0026amp; s2.push(x); } bool pop(int\u0026amp; a, double\u0026amp; x) { return s1.pop(a) \u0026amp;\u0026amp; s2.pop(x); } }; int main() { Crab\u0026lt;Stack\u0026gt; nebula; int ni; double nb; cout \u0026lt;\u0026lt; \u0026#34;int, double 쌍을 입력하세요.\u0026#34; \u0026lt;\u0026lt; endl; while (cin \u0026gt;\u0026gt; ni \u0026gt;\u0026gt; nb \u0026amp;\u0026amp; ni \u0026gt; 0 \u0026amp;\u0026amp; nb \u0026gt; 0) { if (!nebula.push(ni, nb)) break; } while (nebula.pop(ni, nb)) cout \u0026lt;\u0026lt; ni \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; nb \u0026lt;\u0026lt; endl; } 템플릿 클래스와 프렌드 함수 템플릿이 아닌 프렌드 함수 바운드 템플릿 프렌드 함수 언바운드 템플릿 프렌드 함수 1. 보통의 프렌드 함수를 템플릿 클래스 안에 넣기\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 template \u0026lt;typename T\u0026gt; class HasFriend { private: T item; static int ct; // T에 따라서 각각의 특별한 특수화가 자신만의 static 멤버를 가질 것이다. public: HasFriend(const T\u0026amp; i) : item(i) { ct++; } ~HasFriend() { ct--; } // friend 함수들 friend void Counts(); friend void Reports(HasFriend \u0026amp;); // (X) HasFriend 객체 같은 건 없다. // HasFriend\u0026lt;int\u0026gt;와 같은 특수화만이 존재할 뿐이다. friend void Reports(HasFriend\u0026lt;T\u0026gt;\u0026amp;); // Report 자체는 템플릿 함수가 아니다. // 따라서 명시적 특수화를 정의해 주어야 한다. }; // staic 멤버를 초기화해준다. template \u0026lt;typename T\u0026gt; int HasFriend\u0026lt;T\u0026gt;::ct = 0; // friend 함수들 void Counts() { cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; HasFriend\u0026lt;int\u0026gt;::ct \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; HasFriend\u0026lt;double\u0026gt;::ct \u0026lt;\u0026lt; endl; } void Reports(HasFriend\u0026lt;int\u0026gt;\u0026amp; hf) { cout \u0026lt;\u0026lt; \u0026#34;HasFriend\u0026lt;int\u0026gt;: \u0026#34; \u0026lt;\u0026lt; hf.item \u0026lt;\u0026lt; endl; } void Reports(HasFriend\u0026lt;double\u0026gt;\u0026amp; hf) { cout \u0026lt;\u0026lt; \u0026#34;HasFriend\u0026lt;double\u0026gt;: \u0026#34; \u0026lt;\u0026lt; hf.item \u0026lt;\u0026lt; endl; } int main() { Counts(); // int: 0, double: 0 HasFriend\u0026lt;int\u0026gt; hfi1(10); Counts(); // int: 1, double: 0 HasFriend\u0026lt;int\u0026gt; hfi2(20); Counts(); // int: 2, double: 0 HasFriend\u0026lt;double\u0026gt; hfdb(10.5); Counts(); // int: 2, double: 1 Reports(hfi1); // 10 Reports(hfi2); // 20 Reports(hfdb); // 10.5 } 2. 클래스의 바깥에서 선언된 템플릿의 템플릿 특수화\n바운드 템플릿 프렌드 함수\n클래스가 구체화될 때 클래스의 데이터형에 의해 프렌드의 데이터형이 결정된다.\n예를 들어, int 클래스 특수화는, int 함수 특수화를 얻는 것이다.\n구현 방법\n(1) 클래스 정의 앞에 템플릿 함수를 선언한다. (2) 클래스의 템플릿 매개변수의 데이터형에 기초한 프렌드를 선언한다. (3) 프렌드의 정의를 제공한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // 1. 클래스 정의 앞에 템플릿 함수를 선언한다. template \u0026lt;typename T\u0026gt; void Counts(); template \u0026lt;typename T\u0026gt; void Reports(T \u0026amp;); template \u0026lt;typename TT\u0026gt; class HasFriend { private: TT item; static int ct; public: HasFriend(const TT\u0026amp; i) : item(i) { ct++; } ~HasFriend() { ct--; } // 2. 클래스의 템플릿 매개변수의 데이터형에 기초한 프렌드를 선언한다. friend void Counts\u0026lt;TT\u0026gt;(); friend void Reports\u0026lt;\u0026gt;(HasFriend\u0026lt;TT\u0026gt; \u0026amp;); }; template \u0026lt;typename T\u0026gt; int HasFriend\u0026lt;T\u0026gt;::ct = 0; // 3. 정의를 제공한다. template \u0026lt;typename T\u0026gt; void Counts() { cout \u0026lt;\u0026lt; \u0026#34;카운트: \u0026#34; \u0026lt;\u0026lt; HasFriend\u0026lt;T\u0026gt;::ct \u0026lt;\u0026lt; endl; } template \u0026lt;typename T\u0026gt; void Reports(T\u0026amp; hf) { cout \u0026lt;\u0026lt; hf.item \u0026lt;\u0026lt; endl; } int main() { Counts\u0026lt;int\u0026gt;(); // int: 0, double: 0 Counts\u0026lt;double\u0026gt;(); HasFriend\u0026lt;int\u0026gt; hfi1(10); Counts\u0026lt;int\u0026gt;(); // int: 1, double: 0 Counts\u0026lt;double\u0026gt;(); HasFriend\u0026lt;int\u0026gt; hfi2(20); Counts\u0026lt;int\u0026gt;(); // int: 2, double: 0 Counts\u0026lt;double\u0026gt;(); HasFriend\u0026lt;double\u0026gt; hfdb(10.5); Counts\u0026lt;int\u0026gt;(); // int: 2, double: 1 Counts\u0026lt;double\u0026gt;(); Reports(hfi1); // 10 Reports(hfi2); // 20 Reports(hfdb); // 10.5 } 3. 클래스의 안에서 선언된 템플릿의 템플릿 특수화\n언바운드 템플릿 프렌드 함수 바운드 템플릿 프렌드 함수와 다르게, 클래스의 데이터형과 다른 프렌드 템플릿 데이터형 매개변수를 갖는다. 모든 함수 특수화는 모든 클래스 특수화에 대해 프렌드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;typename T\u0026gt; class ManyFriend { private: T item; public: ManyFriend(const T\u0026amp; i) : item(i) {} // 클래스의 데이터형 매개변수 T와 다른 C, D가 쓰였다. template \u0026lt;typename C, typename D\u0026gt; friend void ShowTwo(C\u0026amp;, D\u0026amp;); }; // Myfriend의 모든 특수화들에 대해 프렌드이기 때문에 이 함수는 모든 특수화들이 item멤버에 접근할 수 있다. // 그러나 Myfriend\u0026lt;C\u0026gt;와 MyFriend\u0026lt;D\u0026gt; 객체들에 대한 접근만을 사용한다. template \u0026lt;typename C, typename D\u0026gt; void ShowTwo(C\u0026amp; c, D\u0026amp; d) { cout \u0026lt;\u0026lt; c.item \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; d.item \u0026lt;\u0026lt; endl; } int main() { ManyFriend\u0026lt;int\u0026gt; hfi1(10); ManyFriend\u0026lt;int\u0026gt; hfi2(20); ManyFriend\u0026lt;double\u0026gt; hfdb(10.5); ShowTwo(hfi1, hfi2); // 10, 20 ShowTwo(hfdb, hfi2); // 10.5, 20 } 템플릿 별칭 using = typedef를 사용해서 별칭을 생성할 수 있다. 하지만 이것은 특정 템플릿 부분에는 사용할 수 없다. 따라서 using을 사용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;class T1, class T2\u0026gt; class Test { }; typedef Test\u0026lt;int, int\u0026gt; tii; // (O) template\u0026lt;class T\u0026gt; typedef Test\u0026lt;T, int\u0026gt; tti; // (X) typedef는 템플릿에 사용 불가능하다. template\u0026lt;class T\u0026gt; using tti = Test\u0026lt;T, int\u0026gt;; // (O) using은 가능하다. int main() { tti\u0026lt;double\u0026gt; test; // Test\u0026lt;double, int\u0026gt; 이다. } ","date":"2022-03-21T13:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-14-2/","title":"[C++ Primer Plus] Chapter 14. C++ 코드의 재활용 (2) 템플릿"},{"content":" 코드의 재활용성을 높이는 방법 public 상속 (이전 chapter에서 본 것) 컨테인먼트(containment) = 컴포지션(composition) = 레이어링(layering) private 상속 protected 상속 클래스 템플릿 컨테인먼트 - 객체 멤버를 가지는 클래스 valarray 클래스 수치 값들을 다루는 것이 목표인 클래스이다. 배열에 들어 있는 합, 최대값, 최소값을 구하는 것과 같은 동작들을 지원한다. 1 2 3 4 5 6 7 8 9 10 11 valarray\u0026lt;int\u0026gt; v1; // int형의 배열 valarray\u0026lt;int\u0026gt; v2(10); // 10개짜리 배열 valarray\u0026lt;int\u0026gt; v3(3, 10); // 3이 10개인 배열 int arr[15] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }; valarray\u0026lt;int\u0026gt; v4(arr, 10); // arr의 첫 10개의 원소로 초기화된 배열 cout \u0026lt;\u0026lt; v4.sum() \u0026lt;\u0026lt; endl; // 55 cout \u0026lt;\u0026lt; v4.min() \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; v4.max() \u0026lt;\u0026lt; endl; // 10 학생 클래스 만들기 이름과 성적표를 가지고 있는 클래스이다. 이것은 has-a 관계이다. has-a 관계를 모델링하는 일반적인 방법은 컨테인먼트를 사용하는 것이다. 즉, 다른 클래스의 객체들을 멤버로 가지는 클래스를 만드는 것이다. is-a 관계\npublic 상속에서 처럼, 인터페이스와 구현 모두 상속한다. has-a 관계\n인터페이스 없이 구현을 획득한다. Student 객체는 string과 valarray객체를 가지고 있다. (has-a 관계) string과 valarray객체의 구현을 획득해서 사용할 수는 있지만, 인터페이스는 상속하지 않는다. 예를 들어, string operator==()함수를 사용하는 인터페이스는 갖지 않는다. 1 2 3 4 5 6 class Student { private: string name; // string 객체를 가진다. valarray\u0026lt;double\u0026gt; scores; // valarray 객체를 가진다. }; 학생 클래스 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // Student.h class Studentc { private: typedef valarray\u0026lt;double\u0026gt; ArrayDb; // typedef를 사용해서 표기를 단순화하였다. string name; ArrayDb scores; ostream\u0026amp; PrintScores(ostream\u0026amp; os) const; public: Studentc() : name(\u0026#34;Null Studentc\u0026#34;), scores() {} explicit Studentc(const string\u0026amp; s) : name(s), scores() {} explicit Studentc(int n) : name(\u0026#34;Nully\u0026#34;), scores(n) {} Studentc(const string\u0026amp; s, int n) : name(s), scores(n) {} Studentc(const string\u0026amp; s, const ArrayDb\u0026amp; a) : name(s), scores(a) {} Studentc(const char* str, const double* pd, int n) : name(str), scores(pd, n) {} ~Studentc() {} double Average() const; const string\u0026amp; Name() const; double\u0026amp; operator[](int i); double operator[](int i) const; friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is, Studentc\u0026amp; stu); friend istream\u0026amp; getline(istream\u0026amp; is, Studentc\u0026amp; stu); friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Studentc\u0026amp; stu); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // Student.cpp // scores 출력을 위한 private 멤버 함수 ostream\u0026amp; Studentc::PrintScores(ostream\u0026amp; os) const { int i; int lim = scores.size(); if (lim \u0026gt; 0) { for (i = 0; i \u0026lt; lim; i++) { os \u0026lt;\u0026lt; scores[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if (i % 5 == 4) os \u0026lt;\u0026lt; endl; // 5개 출력하고 개행하기 위함 } if (i % 5 != 0) os \u0026lt;\u0026lt; endl; // 혹시 개행이 안 되었을 때 개행하기 위함 } else os \u0026lt;\u0026lt; \u0026#34;빈 배열\u0026#34;; return os; } double Studentc::Average() const { if (scores.size() \u0026gt; 0) return scores.sum() / scores.size(); else return 0; } const string\u0026amp; Studentc::Name() const { return name; } double\u0026amp; Studentc::operator[](int i) { return scores[i]; } double Studentc::operator[](int i) const { return scores[i]; } istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is, Studentc\u0026amp; stu) { is \u0026gt;\u0026gt; stu.name; return is; } istream\u0026amp; getline(istream\u0026amp; is, Studentc\u0026amp; stu) { getline(is, stu.name); return is; } ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Studentc\u0026amp; stu) { os \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 학생의 성적표: \u0026#34; \u0026lt;\u0026lt; endl; stu.PrintScores(os); return os; } explicit 사용 이유 암시적으로 변환하는 것을 막아서 실수를 예방한다. 1 2 3 4 5 Student homer(\u0026#34;Homer\u0026#34;, 10); homer = 5; // homer[0] = 5; 로 점수를 바꾸려고 했는데 실수로 오타가 났다. // explicit이 없다면 맞는 문장이다. // Student(int n) 생성자가 불려서 이름이 Nully가 된다. 멤버 초기자 리스트 문법을 사용해서 내포된 객체를 초기화 했다. 만약 멤버 초기자 리스트 문법을 사용하지 않았다면, string과 valarray 객체의 디폴트 생성자를 사용한다. 순서는 멤버 초기자 리스트 순서가 아니다. 선언된 순서이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student { private: typedef valarray\u0026lt;double\u0026gt; ArrayDb; string name; // name이 먼저 선언되었다. ArrayDb scores; public: Student(const char* str, const double* pd, int n) : scores(pd, n), name(str) {} // scores를 먼저 써도, 선언된 순서가 name 먼저라서 name 먼저 초기화된다. }; 클래스 메서드 안에서 내포된 객체의 인터페이스를 사용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 double Student::Average() const { // valarray의 sum(), size() 사용 if (scores.size() \u0026gt; 0) return scores.sum() / scores.size(); else return 0; } ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Student\u0026amp; stu) { // string의 operator\u0026lt;\u0026lt;()를 사용 os \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 학생의 성적표: \u0026#34; \u0026lt;\u0026lt; endl; //... } private 상속 public 상속\n기초 클래스의 public 메서드가 파생 클래스의 public 메서드가 된다. 즉, 기초 클래스의 인터페이스를 상속한다. is-a private 상속\n기초 클래스의 public 메서드가 파생 클래스의 private 클래스가 된다. 즉, 기초 클래스의 인터페이스를 상속하지 않는다. has-a 디폴트가 private 상속이다. 컨테인먼트와의 차이 컨테인먼트는 객체를 이름이 있는 멤버 객체로 클래스에 추가한다. 반면에 private 상속은 객체를 이름이 없는 멤버 객체로 클래스에 추가한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Student.h class Studenti : private string, private valarray\u0026lt;double\u0026gt; { private: typedef valarray\u0026lt;double\u0026gt; ArrayDb; ostream\u0026amp; PrintScores(ostream\u0026amp; os) const; public: Studenti() : string(\u0026#34;Null Student\u0026#34;), ArrayDb() {} explicit Studenti(const string\u0026amp; s) : string(s), ArrayDb() {} explicit Studenti(int n) : string(\u0026#34;Nully\u0026#34;), ArrayDb(n) {} Studenti(const string\u0026amp; s, int n) : string(s), ArrayDb(n) {} Studenti(const string\u0026amp; s, const ArrayDb\u0026amp; a) : string(s), ArrayDb(a) {} Studenti(const char* str, const double* pd, int n) : string(str), ArrayDb(pd, n) {} ~Studenti() {} double Average() const; double\u0026amp; operator[](int i); double operator[](int i) const; const string\u0026amp; Name() const; friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is, Studenti\u0026amp; stu); friend istream\u0026amp; getline(istream\u0026amp; is, Studenti\u0026amp; stu); friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Studenti\u0026amp; stu); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // Student.cpp ostream\u0026amp; Studenti::PrintScores(ostream\u0026amp; os) const { int i; int lim = ArrayDb::size(); if (lim \u0026gt; 0) { for (i = 0; i \u0026lt; lim; i++) { os \u0026lt;\u0026lt; ArrayDb::operator[](i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if (i % 5 == 4) os \u0026lt;\u0026lt; endl; } if (i % 5 != 0) os \u0026lt;\u0026lt; endl; } else os \u0026lt;\u0026lt; \u0026#34;빈 배열\u0026#34;; return os; } double Studenti::Average() const { if (ArrayDb::size() \u0026gt; 0) return ArrayDb::sum() / ArrayDb::size(); else return 0; } const string\u0026amp; Studenti::Name() const { return (const string\u0026amp;)*this; } double\u0026amp; Studenti::operator[](int i) { return ArrayDb::operator[](i); } double Studenti::operator[](int i) const { return ArrayDb::operator[](i); } istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is, Studenti\u0026amp; stu) { is \u0026gt;\u0026gt; (string\u0026amp;)stu; return is; } istream\u0026amp; getline(istream\u0026amp; is, Studenti\u0026amp; stu) { getline(is, (string\u0026amp;)stu); return is; } ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Studenti\u0026amp; stu) { os \u0026lt;\u0026lt; (const string\u0026amp;)stu \u0026lt;\u0026lt; \u0026#34; 학생의 성적표: \u0026#34; \u0026lt;\u0026lt; endl; stu.PrintScores(os); return os; } 멤버 초기자 리스트 문법을 사용해서 내포된 객체를 초기화 했다. 컨테인먼트는 멤버 이름을 사용했다. 하지만 private 상속은 클래스 이름을 사용한다. 1 2 3 4 5 // 컨테인먼트 - name과 같은 멤버 이름을 사용함. Studentc::Studentc() : name(\u0026#34;Null Student\u0026#34;), scores() {} // private 상속 - string과 같은 클래스 이름을 사용함. Studenti::Studenti() : string(\u0026#34;Null Student\u0026#34;), ArrayDb() {} 클래스 메서드 안에서 기초 클래스의 인터페이스를 사용한다. 컨테인먼트는 멤버의 메서드를 사용한다. 하지만 private 상속은 클래스 이름과 사용 범위 결정 연산자를 사용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // 컨테인먼트 - scores.sum() 처럼 멤버의 메서드를 사용한다. double Studentc::Average() const { if (scores.size() \u0026gt; 0) return scores.sum() / scores.size(); else return 0; } // private 상속 - ArrayDb::sum() 처럼 클래스 이름과 사용 범위 결정 연산자를 사용한다. double Studenti::Average() const { if (ArrayDb::size() \u0026gt; 0) return ArrayDb::sum() / ArrayDb::size(); else return 0; } 기초 클래스 객체에 접근하기 컨테인먼트는 멤버를 사용한다. 하지만 private 상속은 데이터형 변환을 사용해서 기초 클래스로 변환한다. 1 2 3 4 5 6 7 8 9 10 11 // 컨테인먼트 - 멤버인 name을 사용한다. const string\u0026amp; Studentc::Name() const { return name; } // private 상속 - 자기 자신을 기초 클래스 string로 형변환한다. const string\u0026amp; Studenti::Name() const { return (const string\u0026amp;)*this; } 기초 클래스 프렌드에 접근하기 컨테인먼트는 멤버를 사용한다. 하지만 private 상속은 데이터형 변환을 사용해서 기초 클래스로 변환한다. 명시적으로 변환해야 한다. private 상속에서는 명시적인 형변환이 없으면, 파생 클래스에 대한 참조/포인터를 기초 클래스에 대한 참조/포인터에 대입할 수 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 컨테인먼트 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Student\u0026amp; stu) { // string 멤버인 name의 operator\u0026lt;\u0026lt;()를 사용 os \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 학생의 성적표: \u0026#34; \u0026lt;\u0026lt; endl; //... } ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Studenti\u0026amp; stu) { // (const string\u0026amp;)stu으로 매개변수를 형변환 하여 string의 operator\u0026lt;\u0026lt;()를 사용 os \u0026lt;\u0026lt; (const string\u0026amp;)stu \u0026lt;\u0026lt; \u0026#34; 학생의 성적표: \u0026#34; \u0026lt;\u0026lt; endl; //... } has-a를 구현하기 위해서 어떤 것을 사용할까? 컨테인먼트 vs private 상속 컨테인먼트의 장점 사용하기 쉽다. private의 경우에 하나 이상의 기초 클래스를 상속하면 문제가 발생할 수 있다. 같은 클래스를 여러개 내포할 수 있다. (string 멤버가 여러 개) private 상속의 장점 기초 클래스의 protected 멤버에 접근할 수 있다. 가상 함수를 재정의할 수 있다. protected 상속 각 상속의 특성 특성 public 상속 protected 상속 private 상속 기초 클래스의 public 멤버 public protected private 기초 클래스의 protected 멤버 protected protected private 기초 클래스의 private 멤버 접근 불가 접근 불가 접근 불가 기초 클래스로 암시적 업캐스팅 가능하다 파생 클래스 안에서만 가능하다 불가능하다 처음 두 행의 설명 예를 들어, 기초 클래스의 public 멤버의 경우 public 상속일 때는 파생 클래스 안에서 public 멤버가 된다는 말이다. 기초 클래스의 private 멤버의 경우, 기초 클래스의 인터페이스를 통해서만 접근이 가능하다. protected나 private 상속 일 때, 기초 클래스의 메서드를 파생 클래스에서 public으로 사용하는 방법 (1) 메서드를 새롭게 하나 만든다. (2) using 선언을 사용해서 지정한다. 이것은 컨테인먼트일 때는 적용되지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Studenti : private string, private valarray\u0026lt;double\u0026gt; { public: // 방법 2 using valarray\u0026lt;double\u0026gt;::sum; // 방법 1 double Studenti::max() const { return valarray\u0026lt;double\u0026gt;::max(); } //... }; int main() { Studenti s(\u0026#34;Kim\u0026#34;, {1, 2, 3, 4, 5}); cout \u0026lt;\u0026lt; s.max() \u0026lt;\u0026lt; endl; // (O) private 상속이지만 max를 public처럼 사용 가능하다. } 다중 상속 다중 상속 (multiple inheritance; MI)\n직계 인접한 기초 클래스를 하나 이상 가지는 클래스이다. public, protected, private 키워드는 각각의 기초 클래스에 명시해서 제한해야 한다. 명시하지 않으면 디폴트인 private 상속이 된다. 여기서는 public 상속을 중심으로 설명한다.\n다중 상속은 조심스럽게 절제하여 사용해야 한다.\n하나의 조상을 공유하는 다중 상속은 위험하기 때문이다. 예를 들어, 다음과 같은 클래스 구조가 있을 때 문제가 발생한다.\n1 2 3 4 5 Worker ↙ ↘ Singer Waiter ↘ ↙ SingingWaiter 1 2 SingingWaiter sw; Worker * ptr = \u0026amp;sw; // (X) 이 경우 선택지가 두 개가 존재한다.\n하나는 Waiter에 있는 Worker이며, 다른 하나는 Singer에 있는 Worker이다. 또한 Worker 객체의 복사본을 두 개나 가지게 된다.\n해결방법: 가상 기초 클래스 공통 조상의 유일한 객체를 상속하는 방식으로 객체를 파생시킨다. virtual 키워드를 사용해서 상속한다. 그러면, SingingWaiter는 하나의 Worker 객체를 내포한다. 1 2 3 4 5 6 7 class Worker {}; class Waiter : public virtual Worker {}; // public과 virtual의 위치는 상관 없다. class Singer : virtual public Worker {}; // 즉, 이렇게 써도 된다. class SingingWaiter : public Singer, public Waiter {}; 왜 가상 기초 클래스가 디폴트가 아닌가? (1) 기초 클래스 객체의 여러 개의 복사본을 원할 수 있다. (2) 기초 클래스를 가상으로 만드려면 추가적인 작업을 해야한다. (3) 중간 클래스를 통해 기초 클래스에게 자동으로 정보를 전달하는 기능을 못하게 만든다. (3) 가상 기초 클래스를 사용하면 생성자에서 중간 클래스를 통해 기초 클래스에게 자동으로 정보를 전달하는 기능을 못하게 만든다. C(int, int, int)의 호출로 B(int, int)는 호출되지만, 자동으로 A(int)까지 호출하지는 않는다. 따라서 A()의 생성자가 호출된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A의 디폴트 생정자\u0026#34; \u0026lt;\u0026lt; endl; } A(int a) { cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public virtual A { public: B(int a, int b) : A(a) // A(a)가 아니라 A()가 호출된다. { cout \u0026lt;\u0026lt; \u0026#34;B\u0026#34; \u0026lt;\u0026lt; endl; } }; class C : public B { public: C(int a, int b, int c) : B(a, b) { cout \u0026lt;\u0026lt; \u0026#34;C\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { C c(1, 2, 3); } 1 2 3 A의 디폴트 생성자 B C 기초 생성자를 명시적으로 호출함으로써 수정가능하다. 1 2 3 4 5 6 7 8 9 class C : public B { public: // 명시적으로 A(int)의 생성자를 호출한다. C(int a, int b, int c) : A(a), B(a, b) { cout \u0026lt;\u0026lt; \u0026#34;C\u0026#34; \u0026lt;\u0026lt; endl; } }; 1 2 3 A B C 간접적인 가상 기초 클래스를 사용하는 파생 클래스는, 그 파생 클래스의 생성자들이 간접적인 가상 기초 클래스 생성자들을 직접 호출하게 해야 한다.\n(2) 기초 클래스를 가상으로 만드려면 추가적인 작업을 해야한다. 어느 메서드를 사용하는 가? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Worker { public: virtual void Show(); }; class Waiter : virtual public Worker { public: void Show(); } class Singer : virtual public Worker { public: void Show(); } class SingingWaiter : public Waiter, public Singer { } int main() { SingingWaiter sw; sw.Show(); // (X) Singer와 Waiter 중에 어느 메서드인지 모호하다. sw.Singer::Show(); // (O) } 대안 SingingWaiter에서 Show()를 다시 정의하고, 사용할 Show()의 버전을 지정해 준다. 1 2 3 4 void SingingWaiter::Show() { Singer::Show(); } 가상 기초 클레스와 가상이 아닌 기초 클래스의 혼합 다음 예시에서 B와 C에 대해서만 A가 가상 클래스이고, X와 Y에 대해서는 가상 클래스가 아니라면. M은 결과적으로 3개의 클래스 A 종속 객체를 내포하게 되겠다. 1 2 3 4 5 A ↙ ↙ ↘ ↘ [B] [C] X Y ↘ ↘ ↙ ↙ M 가상 기초 클래스와 비교 우위 파생 클래스에 있는 이름은 조상 클래스에 있는 동일한 이름보다 비교 우위를 가진다. 이것은 가시성과는 상관 없다. 아래 예시에서는\u0026hellip; A의 AB()보다 B의 AB()가 우위를 가진다. B와 C에 있는 BC()는 D()의 입장에서 모호하다. 이것은 어느 하나가 private 이든 간에 상관없이 비교 우위를 가지는 것들이다. 즉, B의 AB()가 private이라고 해도 A의 AB()보다 비교 우위를 가진다. 1 2 3 4 5 A ↙ ↘ [B] [C] ↘ ↙ D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class A { public: void AB(); }; class B : public virtual A { public: void AB(); void BC(); } class C : public virtual A { public: void BC(); } class D : public B, public C { public: void Test() { AB(); // B의 AB() 호출 BC(); // (X) 모호하다 } } ","date":"2022-03-21T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-14-1/","title":"[C++ Primer Plus] Chapter 14. C++ 코드의 재활용 (1) 컨테인먼트와 private, protected 상속"},{"content":" 서론 C의 전통적인 함수 라이브러리는\n그 라이브러리의 소스 코드를 제공하지 않는다면, 사용자의 특정 요구에 맞게 그 함수를 확장하거나 수정할 수 없다. C++의 클래스 라이브러리는\n클래스 상속을 사용한다. 이것은 기초 클래스(base class)로 부터 멤버 변수, 함수들을 상속받아서 새로운 파생 클래스(derived class)를 만드는 것이다. 기초 클래스의 소스 코드에 접근할 필요 없이, 상속으로 새로운 기능이나 데이터를 추가하거나, 함수의 동작 방식을 변경할 수 있다. 기초 클래스를 상속 받는 파생 클래스 파생 클래스는 기초 클래스의 구현들을 상속받는다. (데이터 멤버)\n파생 클래스는 기초 클래스의 인터페이스를 상속받는다. (메서드)\n파생 클래스는 자기 자신의 생성자를 필요로 한다.\n파생 클래스는 부가적인 데이터 멤버들과 멤버 함수들을 필요한 만큼 추가할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class BaseClass { private: int baseClassNumber; public: BaseClass() { baseClassNumber = 0; }; BaseClass(int n) { baseClassNumber = n; } int GetBaseClassNumber() const { return baseClassNumber; } }; class DerivedClass : public BaseClass { private: int derivedClassNumber; public: // 기초 클래스의 생성자를 멤버 초기자 리스트 문법을 사용해 먼저 호출한다. DerivedClass(int base, int derived) : BaseClass(base) { derivedClassNumber = derived; } int Sum() { // 기초 클래스의 private 멤버는 public 멤버로 접근할 수 있다. return derivedClassNumber + GetBaseClassNumber(); } }; 생성자 파생 클래스의 생성자는 기초 클래스의 생성자를 사용해야 한다. 프로그램은 기초 클래스의 객체를 생성 한 후, 파생 클래스의 객체를 생성한다. 파생 클래스 생성자의 몸체 안으로 들어가기 전에 기초 클래스 객체를 생성하기 위해 멤버 초기자 리스트 문법을 사용할 수 있다. 1 2 3 4 DerivedClass::DerivedClass(int base, int derived) : BaseClass(base) { derivedClassNumber = derived; } 멤버 초기자 리스트를 생략하면? 디폴트 기초 클래스 생성자를 사용한다. 1 2 3 4 DerivedClass::DerivedClass(int base, int derived) // 이것은 : BaseClass()와 같다. { derivedClassNumber = derived; } 원한다면, 파생 클래스 멤버들에도 멤버 초기자 리스트 문법을 사용할 수 있다. 1 2 3 4 5 DerivedClass::DerivedClass(int base, int derived) : BaseClass(base), derivedClassNumber(derived); { } 파괴자는 반대 순서로 일어난다. 파생 클래스 파괴자의 먼저 호출되고, 기초 클래스의 파괴자라 호출된다. 파생 클래스는 private이 아니면 기초 클래스의 메서드들을 사용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class DerivedClass : public BaseClass { private: int derivedClassNumber; public: // ... int Sum() { // 기초 클래스의 private 멤버는 public 멤버로 접근할 수 있다. return derivedClassNumber + GetBaseClassNumber(); } }; 기초 클래스 포인터, 참조는 명시적 데이터형 변환 없이도 파생 클래스의 객체를 지시, 참조할 수 있다. 반대는 안 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 DerivedClass derivedClass(5, 6); // 기초 클래스로 파생 클래스를 지시, 참조할 수 있다. BaseClass * basePtr = \u0026amp;derivedClass; BaseClass \u0026amp; baseRef = derivedClass; // 기초 클래스의 메서드를 사용할 수 있다. basePtr-\u0026gt;GetBaseClassNumber(); baseRef.GetBaseClassNumber(); // 파생 클래스의 메서드는 사용할 수 없다. basePtr-\u0026gt;Sum(); // (X) baseRef.Sum(); // (X) 1 2 3 4 5 6 BaseClass baseClass(5); // 반대로 // 파생 클래스로 기초 클래스를 지시, 참조할 수 없다. DerivedClass * derivedPtr = \u0026amp;baseClass; // (X) DerivedClass \u0026amp; derivedRef = baseClass; // (X) 따라서 기초 클래스 포인터, 참조를 매개변수를 사용하는 함수는 파생 클래스 객체에도 사용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 void Show(BaseClass \u0026amp; baseRef) { cout \u0026lt;\u0026lt; baseRef.GetBaseClassNumber() \u0026lt;\u0026lt; endl; } int main() { BaseClass baseClass(5); DerivedClass derivedClass(5, 6); Show(baseClass); Show(derivedClass); // (O) } 파생 클래스의 객체로 기초 클래스 객체를 초기화하는 것도 간접적으로나마 허용한다. 초기화하는 생성자의 원형은 BaseClass(const DerivedClass \u0026amp;);일 것이다. 이러한 생성자를 만들지 않았으므로 암시적인 복사 생성자가 그 역할을 대신한다. BaseClass(const BaseClass \u0026amp;); 기초 클래스의 참조는 파생 클래스를 참조할 수 있으므로, 파생 클래스의 멤버들을 복사한다. 1 2 3 4 5 6 7 8 DerivedClass derivedClass(5, 6); BaseClass baseClass(derivedClass); // (O) // 이러한 복사 생성자가 암시적으로 호출되었을 것이다. BaseClass::BaseClass(const BaseClass\u0026amp; b) { baseClassNumber = b.baseClassNumber; } 대입도 마찬가지이다. BaseClass \u0026amp; operator=(const BaseClass \u0026amp;)과 같은 암시적인 오버로딩 대입 연산자를 대입에 사용한다. 1 2 3 DerivedClass derivedClass(5, 6); BaseClass baseClass; baseClass = derivedClass; // (O) is-a 관계 is-a관계는 파생 클래스와 기초 클래스의 특별한 관계를 나타낸다. 바나나와 과일 바나나는 과일이다. 바나나 is a 과일. is-a 관계는 파생 클래스가 기초 클래스이기도 하다는 것을 뜻한다. 바나나(파생 클래스)는 과일(기초 클래스)이다. 점심과 과일 점심은 과일를 가진다. 점심 has a 과일. 점심이 과일인 것은 아니다. 이것은 has-a 관계이다. 점심 클래스는 데이터 멤버로 과일 객체를 가진다. public 다형 상속 호출하는 객체가 어떤 것인가에 따라서 메서드의 행동이 달라질 수 있다.\n메서드가 여러 가지 다른 행동을 할 수 있기 때문에 그러한 행동을 다형이라고 부른다.\n방법\n기초 클래스 메서드를 파생 클래스에서 다시 정의한다. 그리고 virtual 키워드를 사용해서 가상 메서드로 만든다. virtual 키워드\nvirtual 키워드를 사용한 메서드를 가상 메서드라고 한다. virtual 키워드를 사용하면 각각의 클래스에서 서로 다른 행동을 하는 메서드을 만들 수 있다. 만약 같은 행동을 한다면 기초 클래스에 단 한 번만 선언된다. virtual 키워드를 사용하지 않을 경우, 프로그램은 참조형이나 포인터형에 기초하여 메서드를 선택한다. virtual 키워드를 사용할 경우, 프로그램은 참조형이나 포인터형이 지시하는 객체가 무엇인가에 기초하여 메서드를 선택한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Animal { public: virtual void WhatIsThis() { cout \u0026lt;\u0026lt; \u0026#34;이것은 Animal 객체입니다.\u0026#34; \u0026lt;\u0026lt; endl; } }; class Dog : public Animal { public: virtual void WhatIsThis() { cout \u0026lt;\u0026lt; \u0026#34;이것은 Dog 객체입니다.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Animal animal; Dog dog; Animal * aniPtr = \u0026amp;animal; Animal * dogPtr = \u0026amp;dog; aniPtr-\u0026gt;WhatIsThis(); // Animal의 WhatIsThis() 호출 dogPtr-\u0026gt;WhatIsThis(); // Dog의 WhatIsThis() 호출 } 출력 결과 포인터가 실제 어떤 객체를 가리지는 지 판단해서 메서드를 선택한다. 1 2 이것은 Animal 객체입니다. 이것은 Dog 객체입니다. 만약 virtual 키워드를 사용하지 않으면 출력 결과는 다음과 같다. 포인터가 실제 어떤 객체를 가리키는 지에 상관없이 포인터형으로만 메서드를 선택한다. 1 2 이것은 Animal 객체입니다. 이것은 Animal 객체입니다. virtual 파생 클래스 메서드에서 기초 클래스의 메서드를 부르는 방법 사용 범위 결정 연산자를 사용한다. 1 2 3 4 5 6 7 8 9 10 11 class Dog : public Animal { public: virtual void WhatIsThis() { Animal::WhatIsThis(); // Animal 기초 클래스의 메서드를 호출한다. WhatIsThis(); // 이것은 자기 자신을 부르는 재귀호출이다. cout \u0026lt;\u0026lt; \u0026#34;이것은 Dog 객체입니다.\u0026#34; \u0026lt;\u0026lt; endl; } }; 가상 파괴자의 필요성 파괴자가 가상이 아니면, 포인터형에 대한 파괴자만 호출될 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Animal { public: ~Animal() { cout \u0026lt;\u0026lt; \u0026#34;Animal 파괴자 호출됨\u0026#34; \u0026lt;\u0026lt; endl; }; }; class Dog : public Animal { public: ~Dog() { cout \u0026lt;\u0026lt; \u0026#34;Dog 파괴자 호출됨\u0026#34; \u0026lt;\u0026lt; endl; } }; 1 2 3 4 // 예시 1 Animal * ptr = new Animal; delete ptr; // Animal 파괴자 호출 1 2 3 4 // 예시 2 Animal * ptr = new Dog; delete ptr; // Animal 파괴자 호출 1 2 3 4 // 예시 3 Dog * ptr = new Dog; delete ptr; // Dog 파괴자 호출 후, Animal 파괴자 호출 Dog객체를 지시하는 경우에도 Animal 객체의 파괴자만 호출한다. (예시 2번) 하지만, 파괴자를 가상으로 만들면 실제로 지시하는 Dog 객체의 파괴자를 호출한 후 Animal객체의 파괴자를 호출한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Animal { public: virtual ~Animal() // 가상 소멸자 { cout \u0026lt;\u0026lt; \u0026#34;Animal 파괴자 호출됨\u0026#34; \u0026lt;\u0026lt; endl; }; }; class Dog : public Animal { public: ~Dog() { cout \u0026lt;\u0026lt; \u0026#34;Dog 파괴자 호출됨\u0026#34; \u0026lt;\u0026lt; endl; } }; 1 2 3 4 // 예시 2 Animal * ptr = new Dog; delete ptr; // Dog 파괴자 호출 후, Animal 파괴자 호출 일반적으로, 파괴자가 필요 없는 기초 클래스라 하더라도 가상 파괴자를 제공해야 한다.\n정적 바인딩과 동적 바인딩 바인딩(binding; 결합)\n함수가 호출되었을 때 어떤 블록을 실행할지 결합하는 것을 바인딩이라고 한다. 정적 바인딩(static binding) = 초기 바인딩(early binding)\n컴파일 동안 일어나는 바인딩. 동적 바인딩(dynamic binding) = 말기 바인딩(lately binding)\n프로그램 실행 시에 올바른 가상 메서드가 선택되도록 하는 바인딩. C++은 일반적으로 한 데이터형의 주소를 다른 데이터형 포인터에 대입하는 것을 허용하지 않는다. 참조하는 것도 허용하지 않는다. 1 2 3 4 double d = 1.5; int * iPtr = \u0026amp;d; // (X) int \u0026amp; iRef = d; // (X) 그러나 앞서 보았듯이, 상속하는 클래스는 허용된다. 1 2 3 4 DerivedClass d; BaseClass * bPtr = \u0026amp;d; // (O) 업캐스팅 BaseClass \u0026amp; bRef = d; // (O) 업캐스팅(upcasting) 파생 클래스의 참조/포인터를 기초 클래스의 참조/포인터로 변환하는 것을 업캐스팅이라고 한다. public 상속에서는 명시적인 데이터형 변환이 없어도 업캐스팅이 허용된다. 업캐스팅은 전이된다. 예를 들어, DerivedClass를 상속받는 DerivedDerivedClass가 있다면, 이 클래스 또한 BaseClass에 의해 참조될 수 있다. 다운캐스팅(downcasting) 반대로 기초 클래스의 참조/포인터를 파생 클래스의 참조/포인터로 변환하는 것을 다운캐스팅이라고 한다. 다운캐스팅은 명시적인 데이터형 변환 없이는 허용되지 않는다. 왜냐하면 is-a관계는 일반적으로 대칭적이지 않기 때문이다. 예를 들어, 사과 is a 과일이지만, 과일 is a 사과는 아니다. 암시적 업캐스팅 때문에 동적 바인딩이 필요한 것이다. virtual 멤버 함수는 이러한 필요성 때문에 만들어 졌다. 컴파일러는 virtual이 아닌 멤버 함수는 정적 바인딩을 사용한다. 반면 virtual인 멤버 함수는 프로그램이 실행되는 동안에 결정되는 객체형에 따라서 맞는 함수를 바인딩한다. 즉, 동적으로 바인딩한다. 왜 두 종류의 바인딩이 필요한가? 효율성 프로그램이 무언가를 실행 시간에 결정하려면, 기초 클래스 참조/포인터가 지시하는 객체가 무엇인지 추적하는 방법이 필요하다. 이것은 가외의 처리 부담(다음 차례에 설명되어 있다)이 생긴다. 따라서 동적 바인딩이 필요 없는 경우, 정적 바인딩이 좀 더 효율적이며, C++에서는 정적 바인딩이 디폴트로 되어있다. 개념 모델 파생 클래스에서 다시 정의되는 것을 원하지 않는 멤버 함수는 가상이 아닌 함수로 만듦으로써, 다시 정의되면 안 된다는 의도를 드러낸다. 가상 함수는 어떻게 동작하는가? 일반적으로 컴파일러는 각각의 객체에 숨겨진 멤버를 하나씩 추가한다. 그 숨겨진 멤버는 어떤 배열을 지시하는 포인터이다. 배열에는 해당 클래스의 객체들을 위해 선언된 가상 함수들의 주소가 저장되어 있다. 이 배열을 가상 함수 테이블(virtual function table; vtbl) 이라고 한다. 파생 클래스가 가상 함수를 다시 정의하지 않으면, vtbl은 그 함수의 오리지널 버전의 주소를 저장한다. 반면, 파생 클래스가 새로운 함수를 정의하면, 그 주소가 vtbl에 저장된다. 따라서 가상 함수를 호출하면, 프로그램은 객체에 있는 vtbl에 접근한다. 사용하는 함수가 첫 번째 가상 함수라면, 프로그램은 vtbl의 첫 번째 주소를 사용한다. 이렇듯 가상 함수를 사용하면 메모리, 실행 속도 면에서 약간의 부담이 따른다. 각 객체의 크기가 커진다. (vtbl을 가리키는 주소를 저장하므로) 컴파일러는 테이블을 만들어야 한다. 함수 호출 시 테이블에 접근하는 가외의 단계가 더 필요하다. 생성자는 가상으로 선언할 수 없다. 파생 클래스의 객체 생성 (1) 파생 클래스의 생성자를 호출한다. (2) 파생 클래스의 생성자가 기초 클래스의 생성자를 호출한다. 이 시퀀스는 상속 매커니즘과 다르다. 그래서, 파생 클래스는 기초 클래스 생성자를 상속하지 않는다. 따라서 가상으로 만들 이유가 전혀 없다. 파생 클래스가 가상 함수를 다시 정의 하지 않으면? 기초 클래스의 버전을 사용한다. 만약, 파생 클래스가 길게 이어진 파생 사슬의 일부라면? 가장 최근에 정의된 버전을 사용한다. 다만, 기초 클래스의 버전이 은닉되어 있는 경우는 예외이다. 가상 함수를 다시 정의하면, 메서드가 은닉된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class BaseClass { public: virtual void Show(int n) const; // 매개변수 존재 }; class DerivedClass : public BaseClass { public: virtual void Show() const; // 매개변수 없음. }; int main() { DerivedClass derived; derived.Show(); // (O) derived.Show(1); // (X) 매개변수 없는 버전에 의해 가려졌다. } 매개변수가 없는 새로운 정의는 매개변수가 있는 기초 클래스 버전을 가린다.\n다시 말하면, 상속된 메서드를 다시 정의하는 것은 오버로딩과는 다르다. 매개변수 시그내처와는 상관 없이 같은 이름을 가진 모든 기초 클래스 메서드들을 가린다. 따라서 이것 때문에 두 가지 규칙이 성립된다.\n(1) 재정의 시 오리지널 원형과 정확히 일치시켜야 한다. 예외: 리턴형의 공변(covariance) 리턴형이 기초 클래스에 대한 참조/포인터인 경우 파생 클래스에 대한 참조/포인터로 대체 될 수 있다. (2) 기초 클래스 선언이 오버로딩되어 있다면, 파생 클래스에서 모두 재정의해야 한다. 만약 한 가지 버전만 제공하면, 그 한 가지가 나머지를 모두 가린다. 변경이 필요 없다면 다음과 같이 재정의 할 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class BaseClass { public: virtual BaseClass \u0026amp; ReturnTest(); virtual void Show() const; virtual void Show(int n) const; }; class DerivedClass : public BaseClass { public: virtual DerivedClass \u0026amp; ReturnTest(); // (1번 설명 예시) 동일한 함수 시그내처이다. virtual void Show() const; virtual void Show(int n) const { BaseClass::Show(n); // (2번 설명 예시) 필요 없다면, 이렇게 하면 된다. } }; 접근 제어: protected 클래스 접근 제어를 위한 키워드 세 가지\nprivate protected public protected\n바깥 세계에서 바라보면 private처럼 행동하지만, 파생 클래스 입장에서는 public 멤버와 같이 행동한다. 가능하다면 protected 접근 제어보다 private 접근 제어를 사용해서 메서드를 통해 안전하게 기초 클래스의 데이터에 접근하도록 해야한다.\n추상화 기초 클래스 원과 타원 클래스를 만들고자 한다. 원을 타원의 한 종류로 보아 타원을 상속받아서 원 클래스를 만들 수 있겠다. 하지만 타원에 속한 것들 중 대다수는(반장경 변수, 반당경 변수, 회전시키기 함수 등)은 원에는 필요 없는 것들이다. 그냥 따로 각각 클래스를 만드는 게 낫겠다. 아니면 공통적인 것들만 뽑아서 기초 클래스를 만들어보던지? 추상화 기초 클래스(abstract basic class; ABC) 두 클래스의 공통적인 부분만 따로 뽑아서 만든 기초 클래스이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class BaseEllipse { private: double x, y; public: BaseEllipse(double x0 = 0, double y0 = 0) : x(x0), y(y0) {} virtual ~BaseEllipse() {} void Move(int nx, int ny) { x = nx; y = ny; } virtual double Area() const = 0; // 순수 가상 함수 }; Area()는 원과 타원 각각 다르게 구현해야 하므로 순수 가상 함수(pure virual function) 로 만들었다. 순수 가상 함수는 함수 선언 뒤에 =0을 가진다. 순수 가상 함수는 반드시 정의를 할 필요는 없다. 해도 되고, 안 해도 된다. 순수 가상 함수가 들어 있는 클래스는 자신의 객체를 생성할 수 없다. 왜냐하면 순수 가상 함수는 기초 클래스의 역할을 하기 위해서만 존재하기 때문이다. 어떤 클래스가 진짜 ABC가 되려면 순수 가상 함수가 적어도 하나 이상 있어야 한다. 상속과 동적 메모리 대입 1. 파생 클래스가 new를 사용하지 않는 경우.\n기초 클래스는 동적 메모리 대입을 사용한다. 그래서 파괴자, 복사 생성자, 대입 연산자를 가지고 있다.\n하지만 파생 클래스는 동적 메모리 대입을 사용하지 않는다.\n이 때, 파생 클래스에도 명시적 파괴자, 복사 생성자, 대입 연산자를 정의해야 할까?\n정답은 아니오이다. 파괴자\n파생 클래스의 디폴트 파괴자는 기초 클래스의 파괴자를 항상 호출한다. 따라서 디폴트 파괴자로 충분하다. 복사 생성자\n파생 클래스의 디폴트 복사 생성자는 가지고 있는 기초 클래스의 성분을 복사하기 위해, 명시적인 기초 클래스의 복사 생성자를 사용한다. 따라서 파생 클래스의 디폴트 복사 생성자로도 괜찮다. 대입 연산자\n마찬가지로, 기초 클래스의 대입 연산자를 사용하므로 파생 클래스는 명시적으로 대입 연산자를 정의하지 않아도 된다. 2. 파생 클래스가 new를 사용하는 경우\n당연히 명시적 파괴자, 복사 생성자, 대입 연산자를 정의해야 한다.\n파괴자\n파생 클래스에서 사용한 메모리를 해제하는 명시적 파괴자를 만든다. 복사 생성자\n파생 클래스의 복사 생성자는 자신의 데이터에만 접근할 수 있으므로 기초 클래스의 복사 생성자를 호출한다. 1 2 3 4 5 DerivedClass::DerivedClass(const DerivedClass \u0026amp; d) : BaseClass(d) // 기초 클래스의 복사 생성자를 호출한다. { // new로 메모리 할당 후 복사 } 대입 연산자 마찬가지로, 기초 클래스의 대입 연산자를 호출해준다. 1 2 3 4 5 6 7 8 9 10 DerivedClass \u0026amp; DerivedClass::operator=(const DerivedClass \u0026amp; d) { // ... // 기초 클래스의 대입 연산자를 호출한다. // *this = d; 와 같은 효과이다. BaseClass::operator=(d); //... } 기초 클래스의 friend에 접근하는 법 프렌드는 멤버 함수가 아니기 때문에 사용 범위 결정 연산자로 접근할 수 없다. 해결 방법 강제 데이터형 변환을 사용해서 접근한다. 나중에 소개할 dynamic_cast\u0026lt;\u0026gt; 연산자를 사용할 수도 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class BaseClass { public: friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const BaseClass \u0026amp; b) { os \u0026lt;\u0026lt; \u0026#34;기초 클래스\u0026#34;; } }; class DerivedClass : public BaseClass { public: friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const DerivedClass \u0026amp; d) { // 방법 1 os \u0026lt;\u0026lt; (const BaseClass \u0026amp;)d \u0026lt;\u0026lt; \u0026#34; 그리고, 파생 클래스\u0026#34;; // 방법 2 os \u0026lt;\u0026lt; dynamic_cast\u0026lt;const BaseClass \u0026amp;\u0026gt;(d) \u0026lt;\u0026lt; \u0026#34; 그리고, 파생 클래스\u0026#34;; } }; 그 외의 사항들 상속되지 않는 것 생성자 파괴자 대입 연산자 파생 클래스 객체를 기초 클래스 객체에 대입하면 어떻게 될까? 왼쪽에 있는 객체에 의해 호출되므로, 기초 클래스의 대입 연산자가 호출된다. 따라서 파생 클래스가 가지는 값들은 모두 무시된다. 1 2 3 4 BaseClass base; DerivedClass derived; base = derived; // BaseClass의 대입 연산자가 호출된다. 반대로 기초 클래스 객체를 파생 클래스에 대입하면 어떻게 될까? 파생 클래스의 대입 연산자가 호출된다. 파생 클래스의 대입 연산자의 매개변수는 파생 클래스이다. 하지만 파생 클래스는 자동으로 기초 클래스를 참조할 수 없다. 대안 변환 생성자를 만든다. 기초 클래스를 대입하기 위한 또다른 대입 연산자를 만든다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class DerivedClass { public: // 변환 생성자 (방법 1) DerivedClass(const BaseClass \u0026amp; b) { //... } // 대입 연산자 DerivedClass \u0026amp; operator=(const DerivedClass \u0026amp; d) { //... } // 기초 클래스를 대입하기 위한 또다른 대입 연산자 (방법 2) DerivedClass \u0026amp; operator=(const BaseClass \u0026amp; b) { //... } }; int main() { BaseClass base; DerivedClass derived; derived = base; // DerivedClass의 대입 연산자가 호출된다. } 부적절한 코드는 동적 결합을 불가능하게 만들 수 있으므로 주의하자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class BaseClass { public: virtual void View() const; }; class DerivedClass : public BaseClass { public: virtual void View() const; }; void CallByRefernce(const BaseClass \u0026amp; b) { b.View(); } void CallByValue(BaseClass b) { b.View(); } int main() { DerivedClass derived; // 실제 참조하는 객체인 DerivedClass의 View()를 호출된다. CallByRefernce(derived); // BaseClass(const BaseClass \u0026amp;)생성자로 만든 BaseClass의 View()를 호출한다. CallByValue(derived); } 멤버 함수의 특성 함수 상속 멤버 또는 프렌드 디폴트로 생성 가상으로 선언 리턴형 생성자 X 멤버 O X X 파괴자 X 멤버 O O X = X 멤버 O O O \u0026amp; O 둘 중 하나 O O O 변환 O 멤버 X O X () O 멤버 X O O [] O 멤버 X O O -\u0026gt; O 멤버 X O O op= O 둘 중 하나 X O O new O static 멤버 X X void * delete O static 멤버 X X void 기타 연산자 O 둘 중 하나 X O O 기타 멤버 O 멤버 X O O 프렌드 X 프렌드 X X O ","date":"2022-03-20T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-13/","title":"[C++ Primer Plus] Chapter 13. 클래스의 상속"},{"content":" 서론 어떤 사람의 이름을 저장하는 클래스를 만들고 싶다고 하자, 만약 이름 길이가 40자가 넘어가면 어떻할 것인가? 40개를 저장할 수 있는 문자 배열을 만들면 될까? 그럼 극히 일부만 채워지는 멤버 때문에 많은 메모리가 낭비될 것이다. 문자열의 길이가 컴파일 할 때가 아니라 실행할 때 결정되도록 하면 좋겠다. 일반적으로 string 클래스를 사용하면 되지만, new와 delete를 사용해서 메모리에 대해 배워보기 위해 string 클래스와 비슷한 클래스를 직접 만들어보면서 배워보자. 무언가 잘못된 StringBad 클래스 string 클래스와 비슷한 기능을 하는 StringBad 클래스를 만들어보았다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // StringBad.h #include \u0026lt;iostream\u0026gt; using namespace std; class StringBad { private: char * str; int len; // static 클래스 멤버는 생성되는 객체 수와 상관없이 단 하나만 생성된다. static int stringCount; public: StringBad(const char * s); StringBad(); ~StringBad(); friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const StringBad \u0026amp; st); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // StringBad.cpp #include \u0026lt;cstring\u0026gt; #include \u0026#34;StringBad.h\u0026#34; // static 클래스 멤버를 초기화 한다. int StringBad::stringCount = 0; StringBad::StringBad(const char * s) { // str = s로 하면 안 된다. 주소만 저장하기 때문이다. // 아래와 같이 문자열의 복사본을 만들어서 저장해야 한다. len = strlen(s); str = new char[len + 1]; // 문자열은 힙에 저장되겠다. strcpy(str, s); stringCount++; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; 이 생성됨. \u0026#34; \u0026lt;\u0026lt; \u0026#34; stringCount: \u0026#34; \u0026lt;\u0026lt; stringCount \u0026lt;\u0026lt; endl; } StringBad::StringBad() { len = 6; str = new char[6]; strcpy(str, \u0026#34;empty\u0026#34;); stringCount++; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; 이 생성됨. \u0026#34; \u0026lt;\u0026lt; \u0026#34; stringCount: \u0026#34; \u0026lt;\u0026lt; stringCount \u0026lt;\u0026lt; endl; } StringBad::~StringBad() { --stringCount; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; 이 파괴됨. \u0026#34; \u0026lt;\u0026lt; \u0026#34; 남은 stringCount: \u0026#34; \u0026lt;\u0026lt; stringCount \u0026lt;\u0026lt; endl; // 객체를 파괴할 때 객체가 차지하는 메모리는 해제되지만 // 객체의 멤버인 포인터가 가리키는 메모리는 자동으로 해제되지 않는다. // 따라서 아래와 같이 해제해준다. delete [] str; } ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const StringBad \u0026amp; st) { os \u0026lt;\u0026lt; st.str; return os; } static 멤버 변수 해당 클래스로 만들어지는 객체의 전체 수를 카운트해보기 위해 만들었다. 생성되는 객체 수에 상관 없이 이 변수는 단 하나만 생성되고, 공유된다. 초기화를 클래스 선언 안에서 할 수 없다. 왜냐하면 static 멤버 변수는 객체의 일부분으로 저장되는 것이 아니라 별도로 저장되기 때문이다. 그래서 클래스 선언 바깥에서 초기화해주어야 한다. 헤더 파일에서 초기화한다면, 헤더파일이 여러번 포함되어 그 개수만큼 여러번 반복되어 초기화하기 때문에 에러가 발생한다. 따라서 멤버 함수 구현 파일에 넣는다. 정수형/열거형의 const인 경우에는 클래스 선언 안에서 초기화할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // main.cpp #include \u0026lt;iostream\u0026gt; #include \u0026#34;StringBad.h\u0026#34; using namespace std; void CallByReference(StringBad\u0026amp; s) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; 가 참조로 전달되었다\u0026#34; \u0026lt;\u0026lt; endl; } // 값으로 객체를 전달하면, 복사 생성자가 호출된다. void CallByValue(StringBad s) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; 가 값으로 전달되었다\u0026#34; \u0026lt;\u0026lt; endl; } int main() { { StringBad one(\u0026#34;one\u0026#34;); StringBad two(\u0026#34;two\u0026#34;); StringBad three(\u0026#34;three\u0026#34;); cout \u0026lt;\u0026lt; endl; CallByReference(one); cout \u0026lt;\u0026lt; \u0026#34;돌아온 one: \u0026#34; \u0026lt;\u0026lt; one \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; CallByValue(two); cout \u0026lt;\u0026lt; \u0026#34;돌아온 two: \u0026#34; \u0026lt;\u0026lt; two \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; // 하나의 객체를 다른 객체로 초기화하면 복사 생성자가 호출된다. cout \u0026lt;\u0026lt; \u0026#34;three 객체로 초기화하기\u0026#34; \u0026lt;\u0026lt; endl; StringBad three2 = three; cout \u0026lt;\u0026lt; \u0026#34;three2: \u0026#34; \u0026lt;\u0026lt; three2 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; // 하나의 객체러르 다른 객체에 대입하면 대입 연산자가 호출된다. cout \u0026lt;\u0026lt; \u0026#34;one 객체로 대입하기\u0026#34; \u0026lt;\u0026lt; endl; StringBad one2; one2 = one; cout \u0026lt;\u0026lt; \u0026#34;one2: \u0026#34; \u0026lt;\u0026lt; one2 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } } 출력 결과 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 one 이 생성됨. stringCount: 1 two 이 생성됨. stringCount: 2 three 이 생성됨. stringCount: 3 one 가 참조로 전달되었다 돌아온 one: one two 가 값으로 전달되었다 two 이 파괴됨. 남은 stringCount: 2 // 문제 1 돌아온 two: L three 객체로 초기화하기 three2: three one 객체로 대입하기 empty 이 생성됨. stringCount: 3 one2: one one 이 파괴됨. 남은 stringCount: 2 three 이 파괴됨. 남은 stringCount: 1 � 이 파괴됨. 남은 stringCount: 0 signal: aborted (core dumped) // 문제 2 다음과 같은 문제가 있다. (1) 값으로 전달된 후 파괴자가 호출되었다. 그리고 원본 two 객체의 값이 이상해졌다. (2) 블록을 빠져나오면 파괴자가 줄줄이 호출되는데 객체 수가 2개나 부족하다. 무언가 또 다른 것이 파괴자를 호출한 것임에 분명하다. C++이 자동으로 다음과 같은 멤버 함수들을 제공한다.\n(1) 생성자를 전혀 정의하지 않았을 경우에 디폴트 생성자 (2) 디폴트 파괴자를 정의하지 않았을 경우에 디폴트 파괴자 (3) 복사 생성자를 정의하지 않았을 경우에 복사 생성자 (4) 대입 연산자를 정의하지 않았을 경우에 대입 연산자 (5) 주소 연산자를 정의하지 않았을 경우에 주소 연산자 이동 생성자, 이동 대입 연산자 (C++11) (Chapter 18) 암시적 주소 연산자는 호출한 객체(this 포인터의 값)의 주소를 리턴한다.\n이것은 StringBad 클래스의 설계 목적에 합당하다. 하지만 복사 생성자와 대입 연산자는 그렇지 않다. 복사 생성자 원형 1 StringBad(const StringBad \u0026amp;); 복사 생성자가 불리는 경우: 프로그램이 객체의 복사본을 생성할 때 새로운 객체가 생성되어 같은 종류의 기존의 객체로 초기화될 때 함수가 객체를 값으로 전달할 때 함수가 객체를 리턴할 때 임시객체를 생성할 때 1 2 3 4 5 6 StringBad one(\u0026#34;one\u0026#34;) // 초기화 시에는 모두 복사 생성자를 호출한다. StringBad two(one); StringBad three = StringBad(one); StringBad * four = new StringBad(one); 하는 일 static 멤버를 제외한 멤버들을 멤버별로 복사한다(얕은 복사). 각 멤버는 값으로 복사한다. 따라서 아래의 두 코드는 같은 말이다. 1 2 3 4 5 StringBad two = one; // 이것과 StringBad two; // 이것은 같은 말이다. two.str = one.str; two.len = one.len; StringBad 예시에서 값으로 전달된 후에 원본 객체의 값이 이상해진 건 복사 생성자 때문이었다.\nCallByValue()가 호출될 때 값으로 전달되는 매개변수를 초기화하는 데 복사 생성자가 사용된다. CallByValue() 함수가 끝나면서 파괴자를 호출해서 전달된 객체 원본의 메모리를 해제해버린다. StringBad 예시에서 파괴된 객체가 두 개 더 많았던 것 중 하나는 복사 생성자 때문이었다.\nthree2 객체를 three 객체로 초기화할 때 복사 생성자가 사용된다. 우리는 복사 생성자를 정의하지 않았으므로 이 때 불리는 복사 생성자는 stringCount를 올려주지 않는다. 또한 복사 생성자는 문자열 자체를 복사하지 않고 문자열을 지시하는 포인터를 복사한다. 즉, 얕은 복사를 한다. 두 개의 포인터가 하나의 문자열을 가리키는 형상이 되는 것이다. 따라서 다음과 같은 문제가 생겼던 것이다. 그래서 three2의 파괴자가 불렸을 때 three의 메모리를 해제해버린다. 그리고 three의 파괴자는 이미 삭제한 문자열을 다시 삭제하려고 시도한다. 명시적 복사 생성자를 제공함으로써 문제를 해결할 수 있다. 아래의 코드는 깊은 복사를 수행한다. 즉, 문자열 자체를 복사하고, 그 복사본의 주소를 str 멤버에 대입하게 한다. 1 2 3 4 5 6 7 StringBad::StringBad(const StringBad \u0026amp; st) { stringCount++; len = st.len; str = new char[len + 1]; strcpy(str, st.str); } 클래스 멤버 중에 포인터가 있다면 복사 생성자를 필수로 정의해야 한다.\n대입 연산자 원형 1 StringBad \u0026amp; StringBad::operator=(const StringBad \u0026amp;); 대입 연산자가 불리는 경우 하나의 객체를 기존의 다른 객체에 대입할 때 1 2 3 StringBad one(\u0026#34;one\u0026#34;); StringBad one2; one2 = one; 하는 일 복사 생성자와 마찬가지로 static 멤버를 제외한 멤버들을 멤버별로 복사한다(얕은 복사). StringBad 예시에서 파괴된 객체가 두 개 더 많았던 것 중 하나는 대입 연산자 때문이었다. one2 객체를 one 객체로 초기화할 때 대입 연산자가 사용된다. 우리는 대입 연산자를 정의하지 않았으므로 이 때 불리는 대입 연산자는 stringCount를 올려주지 않는다. 또한 대입 연산자는 얕은 복사를 하기 때문에 one2의 파괴자가 불렸을 때 one의 메모리를 해제해버린다. 그리고 one의 파괴자는 이미 삭제한 문자열을 다시 삭제하려고 시도한다. 명시적 대입 연산자를 제공함으로써 문제를 해결할 수 있다. 복사 연산자와의 차이에 유념하며 구현해야 한다. 차이점은 아래와 같다. (1) 이전에 대입된 데이터를 참조하고 있을 수도 있으므로 먼저 해제해주어야 한다. (2) 자기 자신에게 대입하지 못하게 막아야 한다. (3) 호출한 객체에 대한 참조를 리턴해야 한다. 그래야 one = two = three; 와 같은 연산이 가능해진다. 1 2 3 4 5 6 7 8 9 10 11 StringBad \u0026amp; StringBad::operator=(const StringBad \u0026amp; st) { if (this == \u0026amp;st) return *this // 2 delete [] str; // 1 len = st.len; str = new char[len + 1]; strcpy(str, st.str); return *this; // 3 } 대입은 새로운 객체를 만들지 않는다. 따라서 stringCount를 올릴 필요는 없다. 개선된 String 클래스 위와 같은 문제들을 개선한 String 클래스이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // String.h #include \u0026lt;iostream\u0026gt; using namespace std; class String { private: char * str; int len; static int stringCount; static const int CINLIM = 80; // cin 입력 제한 글자수 public: String(const char * s); String(); String(const String \u0026amp;); // 명시적 복사 생성자 ~String(); int length () const { return len; } String \u0026amp; operator=(const String \u0026amp;); // 명시적 대입 연산자 String \u0026amp; operator=(const char *); // 보통의 문자열을 String 객체에 복사하기 위한 대입 연산자 char \u0026amp; operator[](int i); // []표기를 사용해서 개별 문자에 접근하기 const char \u0026amp; operator[](int i) const; // const 객체에 사용하기 위함 friend bool operator\u0026lt;(const String \u0026amp;st, const String \u0026amp;st2); friend bool operator\u0026gt;(const String \u0026amp;st1, const String \u0026amp;st2); friend bool operator==(const String \u0026amp;st, const String \u0026amp;st2); friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const String \u0026amp; st); friend istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp; is, String \u0026amp; st); static int HowMany(); // static 멤버 함수 }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // string1.cpp #include \u0026lt;cstring\u0026gt; #include \u0026#34;String.h\u0026#34; using namespace std; int String::stringCount = 0; // static 멤버 함수 int String::HowMany() { return stringCount; } String::String(const char * s) { len = std::strlen(s); str = new char[len + 1]; std::strcpy(str, s); stringCount++; } // 개선된 디폴트 생성자 String::String() { len = 0; str = new char[1]; str[0] = \u0026#39;\\0\u0026#39;; stringCount++; } String::String(const String \u0026amp; st) // 명시적 복사 생성자 { stringCount++; len = st.len; str = new char [len + 1]; std::strcpy(str, st.str); } String::~String() { --stringCount; delete [] str; } String \u0026amp; String::operator=(const String \u0026amp; st) // 명시적 대입 연산자 { if (this == \u0026amp;st) return *this; delete [] str; len = st.len; str = new char[len + 1]; std::strcpy(str, st.str); return *this; } // 보통의 문자열을 String 객체에 복사하기 위한 대입 연산자 String \u0026amp; String::operator=(const char * s) { delete [] str; len = std::strlen(s); str = new char[len + 1]; std::strcpy(str, s); return *this; } // []표기를 사용해서 개별 문자에 접근하기 char \u0026amp; String::operator[](int i) { return str[i]; } // const 객체에 사용하기 위함 const char \u0026amp; String::operator[](int i) const { return str[i]; } // friend 함수들 bool operator\u0026lt;(const String \u0026amp;st1, const String \u0026amp;st2) { return (std::strcmp(st1.str, st2.str) \u0026lt; 0); } bool operator\u0026gt;(const String \u0026amp;st1, const String \u0026amp;st2) { return st2 \u0026lt; st1; } bool operator==(const String \u0026amp;st1, const String \u0026amp;st2) { return (std::strcmp(st1.str, st2.str) == 0); } ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const String \u0026amp; st) { os \u0026lt;\u0026lt; st.str; return os; } istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp; is, String \u0026amp; st) { char temp[String::CINLIM]; is.get(temp, String::CINLIM); if (is) st = temp; while (is \u0026amp;\u0026amp; is.get() != \u0026#39;\\n\u0026#39;) continue; return is; } 1. 개선된 디폴트 생성자\n1 2 3 4 5 6 7 8 9 10 11 12 13 String::String { len = 0; // 이것은 파괴자에 있는 delete [] str;과 맞추기 위함이다. str = new char[1]; str[0] = \u0026#39;\\0\u0026#39;; // 이렇게 써도 된다. str = nullptr; stringCount++; } 널 포인터 아무것도 가리키는 않는 포인터이다. C++가 소스 코드에서 0을 표현할 때 널 포인터를 사용했다. 하지만 종종 포인터 상수와 정수 모두 0으로 표현하기 때문에 문제가 발생했고 새로운 키워드 nullptr을 제공했다. 이것은 포인터 타입이며 정수형으로 변환할 수 없다. nullptr == 0은 true지만, 예를 들어서 int형 매개변수를 받는 함수에서 0은 통과되지만 nullptr은 컴파일 에러가 난다. 따라서 컴파일러가 분명하고 안전하게 받아들일 수 있도록 nullptr를 사용해야 한다. 2. []표기를 사용해서 개별 문자에 접근하기\n1 2 char name[10] = \u0026#34;Kim\u0026#34;; cout \u0026lt;\u0026lt; name[0] \u0026lt;\u0026lt; endl; name은 첫번째 피연산자이고, []은 연산자이고, 0은 두 번째 피연산자이다. 따라서 []연산자를 다음과 같이 만들 수 있다. 리턴형이 char \u0026amp;이기 때문에 값을 대입하는 것 또한 가능하다. 1 2 3 4 5 6 7 8 char \u0026amp; String::operator[](int i) { return str[i]; } String one(\u0026#34;one\u0026#34;); cout \u0026lt;\u0026lt; one[0] \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; one[0]; // (O) 하지만 const 객체에는 사용이 불가능하다. C++이 const함수 시그내처와 const가 아닌 함수 시그내처를 구별하기 때문이다. 따라서 const String 객체가 사용할 수 있는 제 2의 버전을 제공할 수 있다. 1 2 3 4 5 6 7 8 const char \u0026amp; String::operator[](int i) const { return str[i]; } const String one(\u0026#34;one\u0026#34;); cout \u0026lt;\u0026lt; one[0] \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; one[0]; // (X) const 객체는 쓰기가 불가능하다. 3. 보통의 문자열을 String 객체에 복사하기를 원한다면 어떻게 해야 할까?\n1 2 3 4 String name; char temp[40]; cin.getline(temp, 40); name = temp; 이 예제의 마지막 구문은 이렇게 동작한다.\n(1) String(const char *) 생성자(변환 함수의 역할)를 사용해서 temp를 String 임시 객체로 만든다. (2) String \u0026amp; operator=(const String \u0026amp; ) 함수를 사용해서 String 임시 객체의 내용을 name에 담는다. (3) String 임시 객체를 파괴한다. 따라서 다음과 같은 대입 연산자를 오버로딩하면, 임시 객체를 생성하고 파괴하는 절차가 생략되겠다.\n1 2 3 4 5 6 7 8 String \u0026amp; String::operator=(const char * s) { delete [] str; len = strlen(s); str = new char[len + 1]; strcpy(str, s); return *this; } 4. static 멤버 함수\nstatic 키워드는 함수 선언에 나타나야 한다. 다음과 같은 특징을 가진다. 객체에 의해 호출될 필요가 없다. 클래스 이름과 사용범위 결정 연산자를 사용하여 호출된다. 어떤 특정 객체와도 결합하지 않기 때문에 사용할 수 있는 데이터 멤버는 static 데이터 멤버밖에 없다. 1 2 3 4 5 6 7 8 9 10 11 class String { public: // … static int HowMany() { return stringCount; } // static 멤버에만 접근할 수 있다. }; int main() { int count = String::HowMany(); // static 멤버 함수를 호출한다. } 객체 리턴에 대한 관찰 1. const 객체를 참조 리턴하는 경우\n효율성 측면에서 유리하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 class Vector {}; // 리턴형이 Vector 라면 복사 생성자를 호출할 것이다. // 참조를 리턴함으로써 좀 더 효율적이게 된다. const Vector \u0026amp; Max(const Vector \u0026amp; v1, const Vector \u0026amp; v2) { if (v1.magval() \u0026gt; v2.magval()) return v1; else return v2; } Vector vec1(30, 60); Vector vec2(10, 70); Vector max = Max(vec1, vec2); 2. const가 아닌 객체를 참조 리턴 하는 경우\n대입 연산자 오버로딩 cout과 함께 사용하기 위한 \u0026lt;\u0026lt; 연산자 오버로딩 1 2 3 4 5 6 7 8 9 String s1(\u0026#34;Good Stuff\u0026#34;); String s2, s3; s3 = s2 = s1; // s2 = s1의 리턴 값이 s1의 참조여야 s3 = s1가 가능하다. // 참조가 아니면 복사 생성자가 호출되므로, 참조로 리턴하는 게 효율적이다. cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34; is coming!\u0026#34;; // ostream은 public 복사 생성자를 만들지 않으므로 // 참조가 아니면 동작하지 않는다. 3. const 객체를 리턴하는 경우\n리턴되는 객체가 지역적이면 참조를 리턴하면 안 된다. 1 2 3 4 5 6 7 8 9 Vector vec1(50, 60); Vector vec2(10, 70); Vector sum = vec1 + vec2; // 두 벡터의 합의 결과인 임시벡터를 참조로 리턴하면 안된다. 실제 객체를 리턴해야 한다. Vector Vector::operator+(const Vector \u0026amp; v) const { return Vector(x + v.x, y + v.y); } 4. const가 아닌 객체를 리턴하는 경우\n위의 코드인 경우 아래와 같은 것이 가능해진다. 1 2 3 4 sum = vec1 + vec2; // 이것도 가능하다. vec1 + vec2의 결과로 임시객체를 만들고, 그것에 sum의 값이 대입된다. vec1 + vec2 = sum; 따라서 다음과 같이 리턴형을 const로 하면 두번째 경우는 불가능해 진다. 1 2 3 4 const Vector Vector::operator+(const Vector \u0026amp; v) const { return Vector(x + v.x, y + v.y); } 위치 지정 new와 클래스 1 2 3 4 5 6 7 8 char * buffer = new char[512]; TestClass *t1, *t2; t1 = new (buffer) TestClass(\u0026#34;test one\u0026#34;); t2 = new (buffer) TestClass(\u0026#34;test two\u0026#34;); // t1의 데이터를 덮어쓴다 delete [] buffer; t2의 경우 t1의 데이터를 덮어 쓴다. 이것은 t1에 대한 파괴자가 호출하지 않기 때문에 위험하다. 따라서 다음과 같이 바꿀 수 있겠다. 1 t2 = new (buffer + sizeof(TestClass)) TestClass(\u0026#34;test two\u0026#34;); 이 구현은 t1, t2 객체에 대한 파괴자를 부르지 않는다. delete [] t1; 으로 한다고 해도 t1은 buffer를 해제할 것이다. 따라서 파괴자를 명시적으로 호출할 수 있겠다. (역순으로) 1 2 t2-\u0026gt;~TestClass(); t1-\u0026gt;~TestClass(); 큐 시뮬레이션 만들기 1. 구조체, 클래스, 열거체가 어떤 클래스 안에서 선언되면, 그 선언은 그 클래스의 사용 범위를 가진다.\n데이터 객체를 생성하지 않고, 그 클래스 안에서 내부적으로 사용할 수 있는 데이터형을 서술한다. public 부분에 있다면, 클래스 바깥에서 변수를 선언할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Queue { private: struct PrivateNode { int data; }; public: struct PublicNode { int data; }; }; int main() { PrivateNode n1; // (X) private struct는 그 클래스 안에서만 사용할 수 있다. PublicNode n2; // (X) public struct는 아래 처럼 사용해야 한다. Queue::PublicNode n3; // (O) } 2. 멤버 초기자 리스트\nconst형 멤버를 초기화하기 위해서는 어떻게 해야할까? 1 2 3 4 5 class Queue { private: const int queueSize; // 이것을 0으로 초기화해야 한다. }; 생성자에서 하면 될까? const 변수는 초기화될 수는 있지만, 대입될 수는 없다. 생성자의 중괄호 안의 내용이 실행되기 전에 객체가 먼저 생성된다. 따라서 중괄호 안의 내용은 const 멤버 변수를 초기화하는 것이 아니라 대입하는 것이다. 1 2 3 4 Queue::Queue(int size) { queueSize = size; // (X) 대입이다. 안 된다. } 이럴 경우 객체가 생성될 때 초기화하는 멤버 초기자 리스트를 사용할 수 있다. 1 2 3 4 Queue::Queue(int size) : queueSize(size) { // … } 멤버 초기자 리스트 문법은 생성자만이 사용할 수 있다. 참조로 선언된 클래스 멤버들에 대해서도 이 문법을 사용해야 한다. 참조는 생성될 때만 초기화될 수 있기 때문이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Agency { }; class Agent { private: Agency \u0026amp; belong; // 참조로 선언된 클래스 멤버 public: Agent(Agency \u0026amp; a); }; // 멤버 초기자 리스트를 사용해서 초기화해야 한다. Agent::Agency(Agency \u0026amp; a) : belong(a) { // … } 3. 복사와 대입을 막는 복사 연산자와 대입 연산자를 구현 방법\n지금 당장은 깊은 복사를 하는 복사 연산자와 대입 연산자가 필요 없다. 하지만 위험하므로 복사와 대입은 막고 싶다면? 명목상의 private 메서드로 정의한다. 그러면 바깥에서 사용하지 못하게 된다. 또 다른 방법은 delete 키워드를 사용하는 것이다. (Chapter 18) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Queue { private: // 선점 정의 Queue(const Queue \u0026amp; q) : queueSize(0) { } Queue \u0026amp; operator=(const Queue \u0026amp; q) { return *this; } }; int main() { Queue q1; Queue q2(q1); // (X) Queue q3; q3 = q1; // (X) } ","date":"2022-03-19T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-12/","title":"[C++ Primer Plus] Chapter 12. 클래스와 동적 메모리 대입"},{"content":" 연산자 오버로딩 시그내처(매개변수 리스트)를 다르게 제공하면 이름이 같은 여러 함수를 정의할 수 있다. 이것을 함수 오버로딩 또는 함수 다형이라고 한다. 연산자 오버로딩은 그 개념을 연산자에까지 확장해서 C++ 연산자에 다중적인 의미를 부여하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Time { private: int hours; int minutes; public: Time(); Time(int h, int m = 0); // 두 Time 객체의 시간을 더하는 함수 Sum Time Sum(const Time \u0026amp; other) const { Time result; result.minutes = minutes + other.minutes; result.hours = hours + other.hours + result.minutes / 60; result.minutes %= 60; return result; } // 연산자 오버로딩을 활용한 버전 Time operator+(const Time\u0026amp; other) const { Time result; result.minutes = minutes + other.minutes; result.hours = hours + other.hours + result.minutes / 60; result.minutes %= 60; return result; } }; int main() { Time t1(3, 30); Time t2(2, 50); // 모두 같은 결과이다 Time sumResult1 = t1.Sum(t2); Time sumResult2 = t1.operator+(t2); Time sumResult3 = t1 + t2; Time t3(4, 29); Time sumResult4 = t1 + t2 + t3; // 적법한 문법이다 Time sumResult5 = t1.operator+(t2.operator+(t3)); } 이 예제의 Sum() 함수에서 리턴값은 참조형이 될 수 없다. 리턴되는 객체는 함수 안에서 만들어지므로 함수가 종료되면 사라진다. 따라서 존재하지 않는 객체에 대한 참조가 되어버린다. 오버로딩 제약 적어도 하나의 피연산자가 사용자 정의 데이터형이어야 한다. 예를 들면, 표준 데이터형인 두 개의 int형의 빼기를 다른 식으로 재정의 할 수 없다. 연산자 기호를 새로 만들 수 없다. 본래 그 연산자에 적용되는 문법적인 규칙을 위반할 수 없다. 연산자의 우선순위도 변경할 수 없다.예를 들면, 다음과 같은 연산은 안 된다. 1 2 3 4 int x; Time t; % x; // 나머지 연산자로 사용할 수 없다. % t; // 따라서 오버로딩 연산자로 사용할 수도 없다. 오버로딩 할 수 있는 연산자들 + - * / % ^ \u0026amp; | ~ ! = \u0026lt; \u0026gt; += -= *= /= %= ^= \u0026amp;= |= \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt;= \u0026lt;\u0026lt;= == != \u0026lt;= \u0026gt;= \u0026amp;\u0026amp; || ++ -- , -\u0026gt;* -\u0026gt; () [] new delete new [] delete [] 다음과 같은 연산자들은 멤버함수로만 오버로딩 할 수 있다. 연산자 이름 = 대입 연산자 () 함수 호출 연산자 [] 배열 인덱스 연산자 -\u0026gt; 클래스 멤버 접근 포인터 연산자 프렌드 일반적으로 객체의 private 부분에 접근할 수 있는 유일한 통로는 public 멤버 함수들이다. 하지만 프렌드를 사용하면 객체의 private 부분에도 접근할 수 있다.\n만약, Time 객체와 double 형 데이터를 곱셈하는 연산자가 필요하다면 어떻게 해야할까?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Time { private: int hours; int minutes; public: Time operator*(double d) const { Time result; long totalMinutes = hours * d * 60 + minutes * d; result.hours = totalMinutes / 60; result.minutes = totalMinutes % 60; return result; } } int main() { Time t(10, 2); Time mulResult1 = t * 2.75; Time mulResult2 = 2.75 * t; // 멤버 함수로 구현이 불가능하다. } Time형 객체 * double형 데이터는 operator*멤버함수로 해결 가능하다. 하지만 double형 데이터 * Time형 객체의 연산은 불가능하다. 멤버 함수는 객체를 사용해서만 호출이 가능하기 때문이다. 그렇다면 멤버가 아닌 함수를 만들어볼 수 있다. 멤버가 아닌 오버로딩 연산자 함수는 첫번째 매개변수가 왼쪽 피연산자이며, 두번째 매개변수가 오른쪽 피연산자가 된다. 하지만 멤버가 아닌 함수는 Time의 private 데이터에 접근할 수 없는 또 다른 문제가 생긴다. 1 2 3 4 5 6 7 8 9 10 11 12 Time operator*(double d, const Time \u0026amp; t) { // (X) 멤버가 아닌 함수는 Time의 private 데이터에 접근할 수 없다. Time result; long totalMinutes = t.hours * d * 60 + t.minutes * d; result.hours = totalMinutes / 60; result.minutes = totalMinutes % 60; return result; } 이때, 멤버 함수는 아니지만 private 멤버에 접근할 수 있는 프렌드라는 특별한 함수를 사용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Time { private: // … public: // 앞에 friend를 붙인 함수 원형을 클래스 선언에 넣는다. friend Time operator*(double d, const Time\u0026amp; t); // … } Time operator*(double d, const Time \u0026amp; t) // 정의에는 friend를 넣지 않는다. { // t.operator*(d)를 사용해서 간단하게 만들 수 있다. return t * d; //Time result; // //long totalMinutes = t.hours * d * 60 + t.minutes * d; //result.hours = totalMinutes / 60; //result.minutes = totalMinutes % 60; // //return result; } 프렌드와 \u0026lt;\u0026lt; 연산자 오버로딩 \u0026lt;\u0026lt; 연산자를 오버로딩해서 cout을 사용해서 우리가 만든 Time 클래스를 출력할 수 있다면 좋겠다. 1 2 3 4 5 int number = 1; cout \u0026lt;\u0026lt; number; Time t(10, 2); cout \u0026lt;\u0026lt; t; // 이렇게 만들어 보자 \u0026lt;\u0026lt; 연산자는 비트 조작 연산자 중에 하나이다. ostream 클래스는 이 연산자를 오버로딩해서 출력 도구로 변환시킨다. ostream 클래스 선언에는 기본 데이터형에 맞게 오버로딩된 operator\u0026lt;\u0026lt;() 정의를 가지고 있다. 그래서 cout \u0026lt;\u0026lt; number; 와 같은 구문으로 기본 데이터형을 출력할 수 있다. 그렇기 때문에 기본 데이터형 대신 우리가 만든 Time클래스를 넣어서 ostream에 연산자 함수의 정의를 추가하면, Time 클래스도 cout을 통해 객체의 내용을 출력할 수 있을 것이다. 하지만 직접 iostream 파일에 접근하는 것은 위험한 생각이다. 1 2 3 4 Time t(10, 2); cout \u0026lt;\u0026lt; t; // ostream 클래스 객체인 cout을 첫번째 피연산자로 사용하므로 // 연산자 오버로딩에 대한 정의가 ostream 클래스 내에 있어야 하겠다. 반대로 Time 클래스에게 cout을 사용하는 법을 가르칠 수 있다. 하지만 \u0026lt;\u0026lt; 연산자를 다음과 같이 사용해야 하며 이것은 혼돈을 준다. 1 2 Time t(10, 2); t \u0026lt;\u0026lt; cout; // 헷갈리는 사용법 따라서 프렌드 함수를 이용해 볼 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Time { private: int hours; int minutes; public: friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Time\u0026amp; t); //... }; ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const Time \u0026amp; t) { os \u0026lt;\u0026lt; t.hours \u0026lt;\u0026lt; \u0026#34; 시간, \u0026#34; \u0026lt;\u0026lt; t.minutes \u0026lt;\u0026lt; \u0026#34;분\u0026#34;; return os; } int main() { Time t(10, 2); cout \u0026lt;\u0026lt; t; // 가능 } 연산자 오버로딩 함수의 리턴형이 ostream인 이유는 다음과 같은 경우 때문이다. 1 2 3 Time t1(10, 2); Time t2(20, 3); cout \u0026lt;\u0026lt; t1 \u0026lt;\u0026lt; t2; // (cout \u0026lt;\u0026lt; t1)의 리턴형이 cout이어야 cout \u0026lt;\u0026lt; t2도 가능하겠다. 클래스의 데이터형 변환 기본 데이터형을 특정 클래스로 변환할 수 있을까? 변환 생성자를 사용하면 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class PoundToKg { private: double pounds; int kg; public: PoundToKg(); explicit PoundToKg(double p) // explicit은 암시적 데이터형 변환을 못하게 한다. { kg = p * 0.453592; pounds = p; } ~PoundToKg(); void ShowKg() { cout \u0026lt;\u0026lt; kg \u0026lt;\u0026lt; \u0026#34; kg\u0026#34; \u0026lt;\u0026lt; endl; } void ShowPounds() { cout \u0026lt;\u0026lt; pounds \u0026lt;\u0026lt; \u0026#34; lbs\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { PoundToKg kg; // PoundToKg(double p) 생성자를 사용해서 19.6을 PoundToKg로 변환한다. kg = 19.6; // 암시적 데이터형 변환. explicit로 선언되었다면 (X)이다. kg = PoundToKg(19.6); // 명시적 데이터형 변환. kg = (PoundToKg) 19.6; // 명시적 데이터형 변환의 옛날 방식. } 암시적 데이터형 변환이 가능하면 이런 식으로도 동작 가능하다. 1 2 3 4 5 6 7 8 9 10 void Display(PoundToKg p) { p.ShowKg(); p.ShowPounds(); } int main() { Display(19.6); } 반대로 클래스를 기본 데이터형으로 변환할 수 없을까? 변환 함수를 사용하면 가능하다. 변환 함수 조건 (1) 클래스의 멤버 함수여야 한다. (2) 리턴형을 가지면 안 된다. (3) 매개변수를 가지면 안 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class PoundToKg { private: double pounds; int kg; public: //... explicit operator double() const // explicit은 암시적 데이터형 변환을 못하게 한다. { return pounds; } } int main() { PoundToKg kg(19.6); double dKg; // PoundToKg 클래스형을 operator double() 변환함수를 사용해서 double형으로 변환한다. dKg = kg; // 암시적 데이터형 변환. explicit로 선언되었다면 (X)이다. dKg = double(kg); // 명시적 데이터형 변환. } ","date":"2022-03-17T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-11/","title":"[C++ Primer Plus] Chapter 11. 클래스의 활용"},{"content":" 싱글톤 패턴 (Singleton Pattern) 객체의 인스턴스가 오직 한 개만 생성되는 패턴이다. 한 개의 인스턴스에 대한 전역적인 접근점을 제공한다. 오직 하나의 인스턴스만 생성하기 때문에 메모리 낭비를 방지할 수 있다. 전역적인 접근점을 제공하기 때문에 데이터를 공유하기 쉽다. 고전적인 싱글톤 구현 방법 1 2 3 4 5 6 7 8 9 10 11 12 public class Singleton { static Singleton instance = null; Singleton() { } public static Singleton GetInstance() { if (instance == null) instance = new Singleton(); // 게으른 초기화 return instance; } } 문제점 멀티 스레드 환경에서 동기화처리를 안 하면 문제가 발생할 수 있다. 두 개 이상의 스레드가 인스턴스를 획득하기 위해서 GetInstance() 메서드에 진입해서 경합을 벌이는 과정에서 서로 다른 두 개의 인스턴스가 만들어질 수 있다. 동기화 문제 해결방안 인스턴스를 처음부터 만들어버린다. 1 2 3 4 5 6 7 8 9 10 11 12 public class SingletonEarly { // 이른 초기화. 인스턴스를 처음부터 만들어 버린다. static SingletonEarly instance = new SingletonEarly(); SingletonEarly() { } public static SingletonEarly GetInstance() { return instance; } } 단점: 인스턴스를 미리 만들어버리면 그 인스턴스가 자원을 많이 차지하는 경우에는 시스템 리소스가 쓸데없이 낭비될 가능성이 있다. DCL (Double-Checking Locking)을 사용해서 동기화 한다. Lock을 사용하는 방법. 매번 동기화하지 않고, 인스턴스가 생성되지 않았을 때만 동기화하여 속도를 높인다. 동기화 후, 다시 한 번 인스턴스가 생성되었는지 확인하고 null이라면 인스턴스를 생성한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class SingletonDCL { // volatile 키워드: // instance 변수에 대한 액세스는 모두 캐시되지 않으며, 메모리에 있는 값을 직접 액세스한다. // 다른 스레드로 인해 값이 변경되지만 컴파일러가 이를 인식하지 못할 수 있기 때문에 volatile 키워드를 사용한다. static volatile SingletonDCL instance = null; static readonly object _lock = new object(); SingletonDCL() { } public static SingletonDCL GetInstance() { if (instance == null) // instance가 생성되지 않았을 때만 동기화한다. { lock (_lock) // _lock이 다른 스레드에서 사용 중이면 사용이 끝날 때까지 기다린다. { if (instance == null) instance = new SingletonDCL(); // 다시 한번 null 인지 확인한다. } } return instance; } } Lazy를 사용하는 방법. Lazy\u0026lt;T\u0026gt;는 선언할 때 인스턴스가 생성되지 않고, 접근하려고 할 때 생성한다. 내부적으로 DCL 패턴을 사용 하고 있기 때문에 멀티 스레딩에 안전하다. 1 2 3 4 5 6 7 8 9 10 11 12 public class SingletonLazy { // Lazy\u0026lt;T\u0026gt;는 사용하기 전까지는 인스턴스를 미리 생성하지 않는다. 멀티 스레드에서도 안전하다. static readonly Lazy\u0026lt;SingletonLazy\u0026gt; instance = new Lazy\u0026lt;SingletonLazy\u0026gt;(() =\u0026gt; new SingletonLazy()); SingletonLazy() { } public static SingletonLazy GetInstance() { return instance.Value; } } ","date":"2022-03-16T17:00:00+09:00","permalink":"https://sopod.github.io/p/design-pattern-01/","title":"[Design Pattern] 행동 패턴 1. 싱글톤 패턴 (Singleton Pattern)"},{"content":" 클래스 추상화란 어떤 정보를 사용자 인터페이스로 표현하는 것이다. 따라서 클래스는 추상화 인터페이스를 구현하는 사용자 정의 데이터형이라고 볼 수 있다. public으로 정의된 인터페이스를 통해서만 접근이 가능하다. 클래스는 데이터와 메서드를 하나로 결합한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // cpp 파일에서 클래스의 정의를 제공한다. // = 캡슐화(세부적인 구현들을 추상화와 분리한다) class Stock // 사용자 정의 데이터형인 class. { private: // 정보 은닉. 데이터 무결성을 보호한다. = 캡슐화 char company[30]; int shares; double shareVal; double totalVal; void SetTotal() { totalVal = shares * shareVal; } public: // 설계를 추상화하여 인터페이스로 제공한다 void Acquire (const char * co, int n, double pr); void Buy (int num, double price); void Sell (int num, double price); void Update (double price); void Show (); }; 구조체와 클래스의 차이점 구조체는 디폴트 접근 제어가 public이지만, 클래스는 private이다. 인라인 메서드 클래스 선언 안에 정의를 가지는 모든 함수는 자동으로 인라인 함수가 된다. 원한다면, 선언 외부에 함수를 정의하고 inline 키워드를 넣어서 인라인 함수로 만들 수 있다. 1 2 3 4 5 6 7 8 9 10 11 class Stock { private: void SetTotal(); //… }; inline void Stock::SetTotal() { //… } 객체는 각기 자체의 데이터를 갖지만 동일한 클래스 메서드 집합을 공유한다. 1 2 3 4 5 Stock s1; // 각각의 데이터 공간을 가진다. Stock s2; s2.Show(); // 하나의 멤버 함수를 공유한다. s2.Show(); 클래스의 생성자 클래스의 데이터들은 private 접근제어를 가지고 있기 때문에 프로그램이 직접 데이터 멤버에 접근할 수 없다. 따라서 struct와 같은 방법으로 초기화할 수가 없다. 1 2 3 4 5 6 7 8 struct Student { char* name; int age; }; Student s = { \u0026#34;John\u0026#34;, 12 }; Stock ss = { \u0026#34;Sukie\u0026#34;, 200, 50.25 } // (X) 컴파일 에러. ss객체의 private 데이터에 접근 불가. 그렇기 때문에 C++은 객체를 생성할 때 자동으로 초기화하는 특별한 멤버함수인 \u0026lsquo;클래스 생성자\u0026rsquo;를 제공한다. 프로그램이 객체를 선언할 때 자동으로 생성자가 호출된다. 생성자는 리턴값을 가질 수 없으며, 명시적, 암시적으로 호출할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Stock { public: Stock(const string\u0026amp; co, int n, double pr); //… }; Stock s1 = Stock(\u0026#34;Sukie\u0026#34;, 200, 50.25); // 명시적 호출 Stock s2 (\u0026#34;Sukie\u0026#34;, 200, 50.25); // 암시적 호출 Stock* s3 = new Stock(\u0026#34;Sukie\u0026#34;, 200, 50.25); // 동적 객체 // C++11에서 허용 (초기화 리스트를 사용) Stock s4 = Stock{\u0026#34;Sukie\u0026#34;, 200, 50.25}; Stock s5 {\u0026#34;Sukie\u0026#34;, 200, 50.25}; Stock* s6 = new Stock{\u0026#34;Sukie\u0026#34;, 200, 50.25}; 디폴트 생성자는 명시적인 초기화값을 제공하지 않을 때 사용하는 생성자이다. C++는 사용자가 생성자를 제공하지 않을 때 자동으로 디폴트 생성자를 제공한다. 만약, 다른 생성자를 사용자가 만들었다면 디폴트 생성자를 제공하지 않는다. 1 2 Stock s1 = Stock(); // 디폴트 생성자를 사용한다. 만약 다른 생성자가 있다면 에러가 발생한다. Stock s2; 디폴트 생성자 정의 방법 생성자의 모든 매개변수에 디폴트 값을 제공한다. 함수 오버로딩을 사용하여 매개변수가 없는 또 하나의 생성자를 정의한다. 그러나 두 가지 방법을 동시에 사용하는 것은 안 된다. 1 2 3 4 5 6 7 class Stock { public: Stock(const string\u0026amp; co = \u0026#34;Error\u0026#34;, int n = 0, double pr = 0.0); // 방법1 Stock(); // 방법2 //... }; 클래스의 파괴자 객체의 수명이 끝나는 시점에서 프로그램은 파괴자를 자동으로 호출한다. 파괴자는 클래스 이름 앞에 틸데(~)가 붙으며 매개변수와 리턴값을 가질 수 없다. 사용자가 명시적으로 파괴자를 호출하면 안 된다. 파괴자는 컴파일러에 의해 자동으로 불려지는 것이다. 예를 들어, 정적 기억 공간에 클래스 객체를 생성한다면, 프로그램이 종료될 때 자동으로 파괴자가 호출된다. 파괴자는 반드시 있어야 하며, 사용자가 파괴자를 제공하지 않으면 컴파일러가 디폴트 파괴자를 선언한다. 이미 존재하는 객체에 생성자를 사용하면, 생성자가 새로운 임시객체를 생성하고, 새로 생성된 임시 객체의 내용이 복사된다. 그리고 임시객체의 파괴자가 호출된다. 1 2 Stock s = Stock(\u0026#34;Sukie\u0026#34;, 200, 50.25); s = Stock(\u0026#34;Nifty\u0026#34;, 100, 20.5); // 임시 객체를 생성하고, s 객체에 복사한 후, 임시 객체를 파괴한다. const 멤버 함수 어떤 멤버함수가 호출 객체를 변경하지 않는다고 약속하기 위해 const를 함수 괄호 뒤에 넣는다. 1 2 3 4 5 6 class Stock { public: void Show() const; //... }; this 포인터 this 포인터는 멤버 함수를 호출하는 데 사용된 객체를 지시한다. 일반적으로, 모든 클래스의 멤버 함수들은 this를 가지며, this는 그 해당 객체의 주소로 설정된다. 따라서 *this는 해당 객체 자체를 의미한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Stock { public: //… // 매개변수로 전달된 Stock 객체와 비교해서 totalVal이 높은 객체를 리턴한다 const Stock\u0026amp; TopValue(const Stock\u0026amp; s) const { if (s.totalVal \u0026gt; totalVal) // totalVal은 this-\u0026gt;totalVal의 약식 표기이다. return s; else return *this // 이 멤버함수를 호출한 객체 s1을 리턴한다 } }; Stock s1 = Stock(\u0026#34;Sukie\u0026#34;, 200, 50.25); Stock s2 = Stock(\u0026#34;Nifty\u0026#34;, 100, 20.5); s1.TopValue(s2); // this 포인터를 s1 객체의 주소로 설정하고, TopValue에서 그 포인터를 사용할 수 있게 한다. 객체 배열 표준 데이터형의 배열을 선언하는 것과 동일한 방법으로 선언한다. 1 2 3 4 5 6 7 Stock myStocks1 [4]; // 배열 각 원소 마다 디폴트 생성자가 호출된다. Stock myStocks2 [4] = { Stock(\u0026#34;NanoSmart\u0026#34;, 12, 20), Stock(\u0026#34;Boffo\u0026#34;, 200, 2.0), Stock(\u0026#34;Monolithic\u0026#34;, 130, 3.27), Stock(\u0026#34;Fleep\u0026#34;, 60, 6.5) }; 클래스 사용 범위 C++ 클래스는 전역 사용 범위와 지역 사용 범위와 다르게 클래스 사용 범위라는 새로운 종류의 사용 범위를 가지고 있다. 클래스 사용 범위를 갖는 것들은 클래스 안에는 알려지지만 클래스 바깥에는 알려지지 않는다.\n그렇다면 클래스 사용 범위를 가지는 기호 상수는 어떻게 만들 수 있을까?\n1 2 3 4 5 6 7 class Stock { private: const int Months = 12; double costs[Months]; // (X) //… }; 클래스를 선언하는 것은 객체가 어떻게 생겼는지 서술하는 것이지, 그 객체를 생성하는 것은 아니다. 따라서 값을 저장할 기억 공간은 객체가 생성될 때까지 마련되지 않는다. 그렇기 때문에 위의 예제는 실패한다. 이러한 문제의 해결 방안은 두 가지가 있다. 클래스 안에 열거체를 선언한다. 단, 각 객체는 그 안에 열거체를 담지 않는다. 컴파일 할 때 클래스 사용 범위에 있는 코드에서 기호이름 Months가 발견되면, 컴파일러는 그것을 단순히 12로 대체할 뿐이다. static 키워드를 사용하여 정적 클래스 멤버를 선언한다. 그래서 해당 클래스의 모든 객체들이 하나의 상수를 공유한다. 1 2 3 4 5 6 7 8 9 class Stock { private: enum { Months = 12 }; // 방법 1 static const int Months = 12; // 방법 2 double costs[Months]; // (O) //… }; 범위가 정해진 열거 (C++11) 전통적인 열거 방식은 다음과 같은 경우 충돌한다는 문제점을 안고 있다. 1 2 enum Egg { Small, Medium, Large }; enum Shirts { Small, Medium, Large }; 따라서 class 키워드를 사용해서 열거자에게 클래스 사용 범위를 갖게 함으로써 해결할 수 있다. 이 경우 열거자를 사용하려면 이름을 사용해야 한다. 그러나 이 경우 int형으로의 암시적 변환이 이루어지지 않는다. 1 2 3 4 5 6 7 8 enum class Egg { Small, Medium, Large }; // class 키워드 사용 enum class Shirts { Small, Medium, Large }; Egg e = Egg::Large; // 사용하려면 열거자 이름을 사용해야 함 Shirts s = Shirts::Large; int number1 = e; // (X) int형으로의 암시적 변환 불가능 int number2 = int(e); // (O) 명시적 변환은 가능 범위가 정해진 열거의 내재적 형태는 int형이다. 이것을 선택적으로 바꿀 수도 있다. 1 enum class : short Pizza { Small, Medium, Large }; // : short 는 기본형이 short형임을 의미한다. ","date":"2022-03-16T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-10/","title":"[C++ Primer Plus] Chapter 10. 객체와 클래스"},{"content":" 분할 컴파일 형식 설명 #include \u0026lt; ... \u0026gt; 컴파일러가 표준 헤더 파일이 들어 있는 호스트 시스템의 파일 시스템 영역에서 찾는다. #include \u0026quot; ... \u0026quot; 컴파일러가 현재 작업 디렉토리나 소스 코드 디렉토리에서 찾는다. 그곳에서 찾지 못하면 표준 위치에서 찾는다. 따라서 사용자가 만든 헤더 파일을 포함할 때는 큰 따옴표를 사용해야 한다. 서로 다른 컴파일러는 하나의 동일한 함수에 대해 다르게 장식한 이름을 만들어 낸다. 따라서 컴파일 된 모듈을 링크시켜야 할 때는 각각의 목적파일이나 라이브러리들이 같은 컴파일러로 만들어진 것인 것 반드시 확인해야 한다. 헤더 파일은 단 한 번만 포함시켜야 하므로 다음과 같이 중복을 방지할 수 있다. 1 2 3 4 5 6 #ifndef MYHEADER_H_ #def MYHEADER_H_ // ... #endif 기억 존속 시간 (storage duration) C++은 네 가지 유형으로 데이터를 저장한다. 이 네 가지 유형은 메모리에 데이터를 존속시키는 시간에서 차이가 난다. 유형 설명 자동 기억 존속 시간 (automatic) 함수 정의 안에 선언된 변수. 함수 안에서만 유효하다. 정적 기억 존속 시간 (static) 함수 바깥에서 선언된 변수, 혹은 static 키워드로 선언된 변수. 프로그램 실행 중에 유효하다. 쓰레드 존속 시간 (Theard) 여러 작업을 동시에 실행할 수 있는 CPU(멀티코어 프로세서)를 사용해서 연산 작업을 쓰레드 단위로 쪼개서 처리한다. 동적 기억 존속 시간 (dynamic) new를 통해 할당되고, delete를 통해 해제된다. 사용범위 (scope) 어떤 이름이 하나의 파일(번역 단위) 안에서 얼마나 널리 알려지는가를 의미한다. 유형 설명 지역 사용범위 = 블록 사용범위 (local) 그 변수를 정의한 블록 안에만 알려진다. 전역 사용범위 = 파일 사용범위 (global) 파일 전체에 알려진다. 함수 원형 사용 범위 함수 안에서만 알려진다. 클래스 사용 범위 클래스 안에서만 알려진다. 이름 공간 사용 범위 이름 공간 안에서만 알려진다. 링크 (linkage) 서로 다른 파일(번역 단위)들이 이름을 공유하는 것을 말한다. 유형 설명 외부 링크 (external) 여러 파일들이 이름을 공유할 수 있다. 내부 링크 (internal) 한 파일 안에서 이름을 공유할 수 있다. 링크 없음 한 블록 안에서만 이름을 공유할 수 있다. 네 가지 종류의 변수들 분류1 분류2 기억존속시간 사용 범위 링크 선언 방법 자동 변수 지역 변수 (local) 자동 지역 없음 블록 안에서 선언 정적 변수 외부 변수 전역 변수 (global) 정적 전역 외부 어떤 블록에도 속하지 않는 바깥에 선언 정적 변수 정적 전역 내부 어떤 블록에도 속하지 않는 바깥에 선언 + static 키워드 정적 변수 정적 지역 없음 블록 안에서 선언 + static 키워드 1. 자동 변수\n블록 안에서 선언된 변수이다. auto 키워드는 자동 변수에만 사용할 수 있다. register 키워드는 C++11이전에 레지스터를 사용해서 자동 변수를 저장함으로써 좀 더 빠르게 접근하게 만들기 위해서 나온 것이었다. 스택과 두개의 포인터를 사용해서 관리된다. 포인터 중 하나는 스택의 시작점인 바닥을, 하나는 스택의 다음 메모리 저장위치인 꼭대기를 가리킨다. 함수가 호출되었다가 종료되면 꼭대기를 가리키는 포인터가 이전 위치를 지시한다. 값들은 지워지지 않는다. 2. 정적 변수\n정적 변수를 명시적으로 초기화하지 않으면, 컴파일러가 자동으로 0으로 초기화한다. 2-1. 전역 변수\n어떤 블록에도 속하지 않는 바깥에 선언 여러 파일에서 똑같은 이름의 전역 변수를 사용한다면 extern 키워드를 넣어준다. 1 2 // 파일 1에서 전역 변수 num을 선언한다. extern을 생략해도 된다. extern int num = 20; 1 2 3 4 5 6 7 8 9 10 11 12 13 // 파일 2에서 전역 변수 num을 사용하기 위해 extern 키워드를 사용한다. extern int num; void Global() { extern int num; // 함수 안에서 선택적으로 재선언해서 전역 변수를 사용 할 수도 있다. } void Local() { int num = 10; // 지역 변수가 전역 변수를 가린다. cout \u0026lt;\u0026lt; ::num; // 전역 변수 사용을 위한 사용 범위 결정 연산자 :: } 2-2. 내부 링크 정적 변수\n어떤 블록에도 속하지 않는 바깥에 선언 + static 키워드 서로 다른 파일에서 같은 이름으로 각각 다른 변수를 만들 수 있다. 1 2 // 파일 1에서 전역 변수를 선언한다. int num = 10; 1 2 // 파일 2에서 내부 링크를 가진 정적 변수를 선언한다. 이 파일에서만 쓰는 또 다른 변수이다. static int num = 14; 2-3. 링크 없음 정적 변수\n블록 안에서 선언 + static 키워드 프로그램이 시작할 때 한번만 초기화 된다. 함수가 호출될 때 누적되는 값으로 사용할 수 있다. 1 2 3 4 5 6 void Function() { // 블록 안에서 링크가 없는 정적 변수를 선언한다. static total = 0; total += 1; } CV-제한자 const 메모리가 초기화 된 후에는 프로그램이 그 메모리를 변경할 수 없다. 특이한 점은, const 전역변수는 외부링크가 아니라 내부링크가 디폴트라는 점이다. 따라서 외부링크인 const 전역변수를 만들고 싶으면 extern 키워드를 사용한다. 1 2 // 파일 1에서 const 전역변수를 extern 키워드를 사용해서 선언한다. extern const int states = 10; 1 2 // 파일 2에서 states을 사용하기 위해서 extern 키워드를 사용한다. extern const int states; volatile 외부적인 요인으로 그 변수의 값이 언제든지 바뀔 수 있음을 뜻한다. 컴파일러의 최적화를 막아서 레지스터에 로드된 값을 사용하지 않고 매번 메모리를 참조하게 만든다. 같은 변수를 여러 번 대입하면 마지막 대입만 의미 있다. 따라서 컴파일러는 나머지 앞의 불필요한 구문을 누락시킴으로써 최적화한다. volatile 제한자는 이러한 최적화를 막는다. 기억 공간 제한자 auto (C++11에서는 의미 변경) 1 2 auto int a = 3; // (X) auto는 더 이상 자동 변수라는 의미의 선언이 아니다. auto b = 3; // (O) auto는 자동 형변환에 사용한다. register (C++11에서는 의미 변경) 변수를 RAM이 아니라, 가능한 Register에 저장하도록 요청한다. C++11에서는 단순히 자동 변수임을 명시하는 방법이다. static 바깥에 선언하면 내부 링크, 블록 안에 선언하면 링크 없음. extern 다른 파일에 존재하는 전역변수를 사용할 수 있게 한다. thread_local (C++11에서 추가됨) thread_local 키워드로 선언한 변수는 그 존속 시간이 변수를 포함하는 쓰레드의 존속 시간이 된다. mutable 특정 구조체나 클래스가 const로 선언되어 있더라도 그 안의 특정 멤버를 변경할 수 있음을 나타낸다. 함수 정적 기억 존속 시간, 외부 링크\nstatic 키워드로 내부 링크를 부여할 수 있다. 이것은 함수의 사용 범위를 파일 하나로 제한한다.\n1 2 3 4 // static 키워드로 내부 링크를 가진 함수를 만든다. static void Function(); // 함수 원형 static void Function() {} // 함수 정의 함수는 모두 하나의 정의만을 가진다. 하지만 인라인 함수는 각각의 파일에서 모두 인라인함수의 정의를 가진다. 언어 링크 각 언어의 컴파일러는 각기 다른 방식으로 함수들의 이름을 장식한다.\n만약 C++프로그램에서 C 라이브러리의 미리 컴파일된 함수를 사용하고 싶다면, 사용할 프로토콜을 알려주는 함수 원형을 사용할 수 있다.\n1 extern \u0026#34;C\u0026#34; void Function(int); 동적 메모리 동적메모리는 사용 범위나 링크 규칙이 아닌, new와 delete에 의해 관리된다. 1 int * ptr = new int; 4바이트의 메모리가 new에 의해 대입된다. delete에 의해 해제될 때까지 메모리에 유지된다. 반면 ptr은 선언된 함수가 종료될 때 사라진다. new 연산자를 이용한 초기화 1 2 3 int * ptr = new int (10); int * ptr = new int {10}; int * ptr = new int[5] {10, 11, 12, 13, 14}; new는 필요한 메모리 양을 확보할 수 없는 경우 std::bad_alloc 예외를 반환한다. 위치 지정 new 사용할 메모리를 프로그래머가 지정할 수 있는 new이다. 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;new\u0026gt; struct StructSample { // ... }; char buffer[50]; // 정적 메모리인 buffer를 사용한다. delete는 안 한다. StructSample * ptr = new (buffer) StructSample; 이름 공간 새로운 종류의 선언영역을 정의하는 것이다.\n전역위치나 다른 이름 공간 안에 놓일 수 있다. 하지만 블록 안에는 놓일 수 없다.\n기본적으로 외부 링크를 가진다.\n1 2 3 4 5 6 7 namespace Jack { int jackNum = 10; int isJackHome = false; } Jack::jackNum = 20; // 사용 범위 결정 연산자 ::를 사용해서 이름공간 안에 이름을 접근한다. using 선언과 using 지시자 using 선언 using 선언으로 특정 이름을 선언된 영역에 추가할 수 있다. 1 2 3 4 5 using Jack::jackNum; // using 선언 jackNum = 20; int jackNum = 10; // (X) using 지시자 using 선언이 하나의 이름만을 사용할 수 있게 만든다면, using 지시자는 모든 이름을 사용할 수 있게 만든다. using 선언은 그 위치에 그 이름을 선언하는 것이라면, using 지시자는 해당 범위에 namespace를 넣는 것이다. 따라서 똑같은 이름을 이후에 재선언했을 때 그 전에 using 선언을 했다면 에러가 나지만, using 지시자의 경우에는 namespace의 변수를 가리기만 한다. 따라서 일반적으로 using 선언이 좀 더 안전하다. 1 2 3 4 5 6 using namespace Jack; // using 지시자 jackNum = 20; isTrue = true; int jackNum = 10; // (O) 이름공간의 대용이름 1 2 3 4 5 namespace J = Jack; // 이렇게 대용이름을 만들 수도 있다. using J::jackNum; jackNum = 20; 명명하지 않은 이름공간 다른 파일에서 사용할 수 없다. 마치 내부링크를 가진 정적변수와 같다. 1 2 3 4 namespace // static int count;와 같다. { int count; }; ","date":"2022-03-10T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-09/","title":"[C++ Primer Plus] Chapter 9. 메모리 모델과 이름공간"},{"content":" 참조 변수 실제 변수의 대용이름. 함수의 매개변수에 사용한다. 포인터와 달리 초기화로만 참조를 설정할 수 있다. 참조 매개변수가 const일 경우 다음 조건일 때 임시변수가 생성된다. 그래서 원본 데이터가 변하지 않는다. (1) 올바른 데이터형이지만 lvalue가 아닐 때 (2) 잘못된 데이터형이지만 올바른 데이터형으로 변환할 수 있을 때 1 2 3 4 5 6 7 8 9 10 11 double RefCube( const double \u0026amp; ref ) { return ref * ref * ref; } double dNum = 5.0; long lNum = 5L; RefCube( lNum ); // 2 RefCube( dNum + 5.0 ); // 1 RefCube( 7.0 ); // 1 rvalue 참조는 \u0026amp;\u0026amp;를 사용한다. lvalue는 단일 표현식 이후에도 없어지지 않고 지속되는 객체이다. rvalue는 표현식 종료 이후에는 더 이상 존재하지 않는 암시적인 값이다. rvalue 참조는 Chapter 18에 나올 move semantics에 쓰인다. 1 2 3 double \u0026amp;\u0026amp; rref1 = 13.0; // 리터럴 상수 double \u0026amp;\u0026amp; rref2 = 2.0 + dNum; // 표현식 double \u0026amp;\u0026amp; rref3 = sqrt(2.0); // rvalue를 반환하는 함수 매개변수에 const 사용이 좋은 이유 실수로 데이터형 변경을 막을 수 있다. const와 const가 아닌 매개변수를 모두 처리할 수 있다. 참조로 매개변수가 전달되면 임시변수를 생성해서 사용할 수 있다. 구조체 참조 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct Student { //... } Student\u0026amp; Func(Student\u0026amp; s) { //... } Student s1, s2; // 대입 구문으로 값이 복사된다. s1 = Func(s2); // 만약 Func 함수의 리턴값이 const이면 안 되는 구문이다. // 리턴 값이 const이면 상수 참조이기 때문이다. Func(s2) = s1; 구조체를 참조로 리턴하는 경우 전체 구조체를 임시 장소에 복사한 후 다시 복사하는 과정이 없고, 직접적으로 복사되기 때문에 보다 효율적이다. 함수가 종료될 때 수명이 끝나는 임시 변수를 참조로 리턴하지 않도록 주의해야 한다. 해결 방안은 매개변수로 전달된 참조를 리턴하거나, 포인터를 사용하는 방법이 있다. 1 2 3 4 5 6 7 8 9 10 11 12 struct Student { //... } const Student\u0026amp; Func(Student\u0026amp; s) { Student *ptr = new Student; // delete를 까먹을 수 있다. (unique_ptr이 괜찮은 대안이다) *ptr = s; return *ptr; // 포인터를 사용해서 구조체를 참조로 리턴한다. } string 객체 참조 매개변수에 C 스타일 문자열 매개변수 전달하기 string 클래스가 char *형을 string으로 변환한다. const 참조 형식의 매개변수라면 임시 변수를 만들게 된다. 1 2 3 4 5 6 void Func(string str) // str과 “Hello”는 서로 주소가 다르다. { //... } Func(\u0026#34;Hello\u0026#34;); 객체의 상속과 참조 ostream을 상속받는 ofstream형 객체들은 ostream \u0026amp; 참조형으로 받을 수가 있다. 1 2 3 4 5 6 ios_base::fmtflags initial; initial = cout.setf(ios_base::fixed); // 고정소수점 표기. 바꾸기 전 포맷팅 설정을 리턴한다. cout.precision(1); // 소수점 이하 숫자 개수 cout.setf(ios::showpoint); // 0이더라도 소수점 표시 cout.width(17); // 필드 폭 설정 ( 한번 출력 후 초기화됨) cout.setf(initial); // 이전 포맷팅 설정 복원 참조 매개변수를 사용하는 이유 전달되는 데이터 객체의 변경을 위해 객체 대신 참조를 전달해서 속도를 높이기 위해 매개변수가 배열이라면 참조 매개변수는 배열의 크기를 구체적으로 명시해야 하므로, 포인터가 유일한 대안이겠다. 디폴트 매개변수 함수의 원형에 명시한다. 어떤 매개변수를 디폴트 매개변수로 만들려면, 그 오른쪽에 있는 모든 매개변수를 디폴트 매개변수로 만들어야 한다. 1 2 3 4 5 6 void Func(int one, int two = 2, int three = 3) { //... } Func (1, ,3); // (X) 매개변수를 건너뛸 수는 없다. 함수 오버로딩 (함수의 다형) 서로 다른 여러 개의 함수가 하나의 이름을 공유하는 것. 함수를 호출하면 매개변수 리스트(= 함수 시그내처)에 따라 알맞은 시그내처를 가진 함수원형을 찾아준다. 리턴형이 달라도, 시그내처가 같으면 오버로딩이 불가능하다. 반면, 시그내처가 다르면 다른 리턴형을 가질 수 있다. 함수 오버로딩이 되어서 여러 개의 함수가 존재하는데, 알맞은 시그내처가 없을 경우 컴파일 에러가 난다. 1 2 3 4 5 6 7 8 9 10 11 12 void Solution (int num) { //... } void Solution (float num) { //... } double test = 5.0; Solution(test); // double형 매개변수를 가진 시그내처가 없으므로 컴파일 에러 데이터형과 그 참조는 서로 같은 것으로 친다. const와 const가 아닌 변수는 구별된다. 이름장식 컴파일러는 오버로딩된 함수들의 이름을 알아보기 어려운 내부 형식으로 변환하여 암호화한다. 이것으로 서로 구분한다. 오버로딩 참조 매개변수 변경가능 lvalue ( x ) const lvalue ( 1 ) rvalue ( x + y ) void Solution ( int \u0026amp; num ); O X X void Solution ( const int \u0026amp; num ); O O O void Solution ( int \u0026amp;\u0026amp; num ); X X O 함수 템플릿 1 2 3 4 5 6 7 8 9 10 // 함수 템플릿 원형. class 대신 typename을 사용해도 된다. template \u0026lt;class T\u0026gt; void Swap (T \u0026amp; a, T \u0026amp; b); // 함수 템플릿 정의 template \u0026lt;class T\u0026gt; void Swap (T \u0026amp; a, T \u0026amp; b) { //... } 함수 템플릿의 제한 1 2 3 4 5 template \u0026lt;typename T\u0026gt; int Add(T a, T b) { return a + b; } 이경우 T가 struct라면 작동하지 않는다. 대안은\u0026hellip;? 연산자를 오버로드한다. 특별한 형에 대하여 특화된 템플릿을 정의한다. (명시적 특수화) 명시적 특수화 다른 Swap() 템플릿을 사용하지 말고, 주어진 형에 맞게 특별히 명시적으로 정의된 이 함수 정의를 사용해라. 조건 매개변수 동일 반환형 동일 앞에 template \u0026lt;\u0026gt; 붙이기 1 2 3 4 5 6 7 8 9 10 struct Student { //... } // \u0026lt;Student\u0026gt;에서 Student 생략가능. template \u0026lt;\u0026gt; void Swap\u0026lt;Student\u0026gt;(Student \u0026amp; s1, Student \u0026amp; s2) { //... } 암시적 구체화, 명시적 구체화 구체화: 컴파일러가 특정 데이터형에 맞는 함수 정의를 생성하기 위해 템플릿을 사용한 결과.\nSwap() 템플릿을 사용해서, 주어진 형에 맞는 함수 정의를 생성해라.\n암시적 구체화: 컴파일러에게 암시적으로 Swap() 템플릿을 사용해서, x, y 형에 맞는 함수 정의를 생성하라고 알린다.\n명시적 구체화: 컴파일러에게 명시적으로 Swap() 템플릿을 사용해서, int 형에 맞는 함수 정의를 생성하라고 알린다.\n1 2 3 4 5 6 // 암시적 구체화 Swap(x, y); // 명시적 구체화 template void Swap\u0026lt;int\u0026gt; (int, int); Swap\u0026lt;int\u0026gt; (x, y); 컴파일러는 어떤 함수를 선택할까? 순서 일반 함수 \u0026gt; 명시적 특수화 \u0026gt; 일반 템플릿 가능한 함수가 둘 이상이면 모호하기 때문에 에러가 발생한다. 사용자가 컴파일러에게 적절한 함수를 사용하도록 리드할 수 있다. 1 2 Swap\u0026lt;\u0026gt;(x, y); // \u0026lt;\u0026gt;는 템플릿 함수를 선택해야한다는 것을 의미한다. Swap\u0026lt;int\u0026gt;(x, y); decltype 키워드 declared type의 줄임말이다. 특정 인스턴스가 생성되기 전까지 타입을 결정할 수 없을 때 템플릿을 정의하는 데 사용하는 특별한 방법이다. 내부 괄호로 한번 더 묶으면 그 안의 표현식을 lvalue참조로 본다. 1 2 3 4 5 6 7 8 int x = 1, y = 2; decltype (x + y) xpy; // x+y과 동일한 타입의 xpy를 만들어라 xpy = x + y; decltype (x + y) xpy = x + y; // 위와 같은 구문 decltype ((x)) xr = x; // int \u0026amp; 타입 1 2 3 4 5 template\u0026lt;class T1, class T2\u0026gt; auto Solution(T1 x, T2 y) -\u0026gt; decltype(x + y) // 적절한 x + y의 리턴형을 선언할 수 있다. { return x + y; } ","date":"2022-03-09T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-08/","title":"[C++ Primer Plus] Chapter 8. 함수의 활용"},{"content":" 함수 1 2 3 4 5 6 7 8 double Solution(int); // 원형 Solution(num); // 호출 double Solution(int num) // 정의 { return num * 3.0f } 함수의 원형이 필요한 이유 함수의 원형은 컴파일러에게 함수의 인터페이스를 알려준다. 즉, 리턴값과 매개변수의 데이터형을 알려준다. 함수는 자신의 리턴값을 CPU의 지정된 레지스터/메모리에 복사한다. 어떤 형의 값인지는 자신의 정의를 본다. 호출한 함수가 그 위치에서 값을 꺼내온다. 함수 원형을 보면 리턴값이 뭔지 알 수 있으므로 컴파일러는 그 위치에서 몇 바이트를 꺼내야 하는 지 알고 있다. 함수 원형의 매개변수 1 2 3 4 5 6 7 8 double Solution(int); // 매개변수 이름을 생략해도 된다. double Solution(...); // 매개변수 리스트가 무엇인지 확인하지 않겠다는 뜻이다. double Solution(int x); Solution(5); // 5 = 실제 매개변수 = 함수에 전달되는 값 = argument // x = 형식 매개변수 = 전달되는 값을 넘겨받는데 쓰는 변수 = parameter // 매개변수란 argument가 parameter에 대입되는 것이다. 배열 매개변수 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int nums [3] = {1, 2, 3}; Solution(nums, 3); void Solution(int arr [] , int size); void Solution(int * arr , int size); // 같은 의미이다. // 이렇게 할 수도 있다. Solution(nums, nums + 3); void Solution(int * begin, int * end) cout \u0026lt;\u0026lt; sizeof(nums) \u0026lt;\u0026lt; endl; // 12. 배열 전체의 크기. cout \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; // 4. 포인터 변수의 크기. // 따라서 매개변수로 배열의 크기를 넘겨주려면 따로 추가적인 매개변수가 필요하다. // 배열의 값을 변경하는 걸 원하지 않으면 const로 선언해준다. void Solution(const int arr []); 포인터와 const 표기 ptr = \u0026amp;other; *ptr = 3; 의미 const int * ptr O X ptr을 이용해서 num의 값 변경 불가. int * const ptr X O ptr이 가리키는 값을 변경 불가. 1 2 3 4 5 6 7 8 int num1 = 5; const int * ptr = \u0026amp;num1; // 만약 num이 const라면 ptr은 무조건 const여야 한다. int num2 = 3; ptr = \u0026amp;num2 // (O) ptr에 새로운 val이라는 값을 가리키게 할 수는 있다. *ptr = 3; // (X) 하지만 ptr을 이용해서 그 값 자체를 바꿀 수는 없다. 1 2 3 4 5 6 7 8 int num1 = 5; int * const ptr = \u0026amp;num1; *ptr = 3; // (O) num의 값을 변경할 수는 있다. int num2 = 3; ptr = \u0026amp;num2; // (X) 하지만 ptr을 이용해서 다른 값을 가리키게 할 수는 없다. 2차원 배열 매개변수의 전달 배열 포인터 1 2 3 // 포인터다. 4개의 int형 원소들을 가지고 있는 배열을 지시하는 포인터다. int (*arr) [4]; int arr[][4]; 포인터 배열 1 2 // 배열이다. 4개의 int형 포인터들을 가지고 있는 배열이다. int *arr [4]; arr[3][4] == *(*(arr + 3) + 4) arr[3] == *(arr + 3) 4개의 원소를 가지고 있는 3번째 행 배열의 이름이다. (sizeof(arr[3])하면 16바이트) C스타일 문자열의 전달 1 2 3 4 5 6 7 void Solution(const char * str); // 문자열은 마지막이 널문자이므로 배열 크기를 넘길 필요가 없다. char name[4] = \u0026#34;Kim\u0026#34;; Solution(name); char * nik = \u0026#34;KeKe\u0026#34;; Solution(nik); 구조체, string의 전달 일반 변수처럼 값으로 전달된다. array 객체의 전달 1 2 3 4 5 6 7 8 9 10 11 12 std::array\u0026lt;double, 4\u0026gt; expenses; Solution(expenses); void Solution(std::array\u0026lt;double, 4\u0026gt; * exp) { cout \u0026lt;\u0026lt; (*exp)[0] \u0026lt;\u0026lt; endl; } // exp는 포인터다. // *exp는 객체이다. // (*exp)[0] 은 그 객체에 있는 원소이다. 함수 포인터의 전달 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 double Function(int num); // pf는 함수를 지시하는 포인터, *pf는 함수 자체. // 함수 포인터 void Solution(double (*pf) (int)) { double result = pf(5); // (*pf)(5) } // 함수 포인터들의 배열 void Solution(double (*pf [3]) (int)) { double result = pf[0](5); // (*pf[0])(5) } // 함수 포인터의 포인터 void Solution(double (**pf) (int)) { double result = pf[0](5); // (*pf[0])(5) } // 함수 포인터들의 배열의 포인터 void Solution(double (*(*pf) [3]) (int)) { double result = (*pf)[0](5); // (*(*pf)[0])(5) } // pf를 함수 포인터형으로 쓸 수 있다. typedef double (*pf) (int); pf function = f1; ","date":"2022-03-08T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-07/","title":"[C++ Primer Plus] Chapter 7. 함수"},{"content":" 연산자 우선순위 연산자 결합규칙 :: (괄호묶기, 함수호출, 값 생성) [] . -\u0026gt; ++ -- const_cast dynamic_cast reinterpret_cast static_cast typeid → ! ~ + - ++ -- \u0026amp; * (형변환) sizeof alignof new delete noexcept ← .* -\u0026gt;* → * / % → + - → \u0026lt;\u0026lt; \u0026gt;\u0026gt; → \u0026lt; \u0026lt;= \u0026gt;= \u0026gt; → == != → \u0026amp; → ^ → | → \u0026amp;\u0026amp; → || → :? ← = *= /= %= += -= \u0026amp;= ^= != \u0026lt;\u0026lt;= \u0026gt;\u0026gt;= ← throw → , → cctype 라이브러리 함수명 쓰임새 isalpha 영문자인가? isdigit 숫자인가? tolower 소문자로 toupper 대문자로 switch 구문 case 레이블은 그 값이 int형이어야 한다. (enum 가능) 많은 구현체들이 switch문을 jump table로 구현하기 때문에 if else보다 실행 속도면에서 효율적이다. 보통 if문이 3개일때까지는 if else문이 빠르고 그 이상은 switch문이 빠르다. 하지만 그 속도 차이가 미미해서 가독성을 더 고려하는 것이 좋겠다. 루프로 읽기 1 2 int n; cin \u0026gt;\u0026gt; n; 여기서 수 대신 문자를 입력하면 벌어지는 일\n(1) n의 값은 변하지 않는다. (2) 입력 큐에 잘못된 입력이 그대로 유지된다. (3) cin 객체에 에러 플래그가 설정된다. (4) cin 메서드 호출이 false(bool형으로 변환된다면)를 리턴한다. 따라서 다시 입력을 재개하려면\n(1) cin을 초기화한다. (2) 불량입력을 제거한다. 1 2 3 4 5 while (!(cin \u0026gt;\u0026gt; golf[i])) // 제대로 입력하면 종료 하고 아니면 다시 입력 재개 { cin.clear(); while( cin.get() != \u0026#39;\\n\u0026#39; ) continue; } 텍스트 파일 쓰고 읽기 쓰기 1 2 3 4 5 6 7 8 9 #include \u0026lt;fstream\u0026gt; ofstream outFile; outFile.open(\u0026#34;text.txt\u0026#34;); outFile \u0026lt;\u0026lt; \u0026#34;안녕\u0026#34;; outFile.close(); 읽기 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;fstream\u0026gt; ifstream inFile; inFile.open(\u0026#34;text.txt\u0026#34;); if (!inFile.isopen) exit(EXIT_FAILURE); if (inFile.good()) inFile \u0026gt;\u0026gt; str; inFile.close(); open() 을 하면 새 파일을 만든다. 기존 파일이 존재하면 내용이 모두 지운다. inFile.eof() 는 파일의 끝에 도달하면 true inFile.fail() 은 데이터형 불일치나 파일의 끝에 도달하면 true inFile.bad() 는 파일이 깨지거나 하드웨어 실패하면 true inFile.good() 은 잘못된 것이 하나도 없으면 true ","date":"2022-03-07T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-06/","title":"[C++ Primer Plus] Chapter 6. 분기 구문과 논리 연산자"},{"content":" 표현식 대입 표현식은 값을 가지기 때문에 이런 구문도 가능하다. 1 x = y = z = 0; 표현식에 세미콜론을 붙이면 구문이 된다. statement = expression + semicolon 시퀀스 포인트 (Sequence Point) 시퀀스 포인트란 프로그램의 실행이 다음 단계로 넘어가기 전에, 모든 부수 효과(변수 값 변경 등)들이 확실하게 평가되는 포인트이다. 예를 들면 세미콜론, 완전 수식(while문의 조건문)의 끝, || 연사자 등은 시퀀스 포인트이다. 따라서 아래 예제에서는 시퀀스 포인트에서 다음 명령을 실행하기 전에 증가 연산자로 인해 값이 증가한다. 1 2 3 4 5 6 7 int point = 1; point++; // 여기 while(point++ \u0026lt; 10) // 여기 { //… } 접두어와 접미어 방식 내장 데이터형의 경우에는 둘 다 결과적으로 동일한 결과를 가져온다. 하지만 클래스와 같이 사용자 정의 데이터형인 경우에는 접두어 방식이 효율적이다. 왜냐하면 접미어 방식은 복사본을 만들어서 값을 증가시키고 복사본을 리턴하는 방식으로 동작하기 때문이다. 포인터와 증가/감소 연산자 표기 설명 *++pt 오른쪽부터 왼쪽으로 결합하므로, ++pt는 주소 증가, 그 후 *(++pt)는 값 출력. ++*pt *pt는 값이므로, ++(*pt)는 값이 증가. (*pt)++ *pt는 값이므로, (*pt)++는 다음 단계로 넘어가면서 값이 증가. *pt++ pt++는 주소 증가지만 다음 단계로 넘어갈 때 증가. *(pt++)는 현재 주소의 값 출력. 그 후 다음 단계로 넘어가면서 주소 증가. 콤마 연산자로 두 개의 표현식 넣기 1 2 3 4 5 // temp를 사용해서 i인덱스와 j인덱스에 해당하는 값을 교환하여 거꾸로 만들기 int i, j, temp; for (i = 0, j = size - 1; i \u0026lt; j; i++, j--) // ...\ttemp가 바깥에 선언되었다. 매 주기마다 새로 대입하고 해제되지 않아도 돼서 좋다. i, j가 바깥에 선언되었다. int i = 0, j = size - 1에서 콤마는 연산자가 아닌 분리자가 된다. 그래서 for 제어문 안에서 선언할 수 없다. 문자열 비교 C스타일 strcmp()를 사용한다. 같으면 0, 첫문자가 앞순서면 -1, 뒷순서면 1을 리턴 대문자가 소문자보다 앞이다. 1 2 3 char word[5] = \u0026#34;word\u0026#34;; if (strcmp(word, \u0026#34;mate\u0026#34;) == 0) //... string 관계 연산자를 사용한다. 1 2 3 string word = \u0026#34;word\u0026#34;; if (word == \u0026#34;mate\u0026#34;) //... 시간지연 루프 프로세스 성능에 따라 1초에 반복되는 루프문의 수가 달라질 수 있다. 그래서 똑같은 시간을 재기 위해서는 클록 수를 카운트한다. clock() 프로그램 실행 순간부터 이 함수가 호출될 때 까지의 클록 수 CLOCK_PER_SEC 1초 당 클록 수 clock_t형 clock()의 리턴 데이터형이 시스템마다 달라질 수 있는데 그것을 모두 수용할 수 있는 데이터형이다. 1 2 3 4 clock_t delay = 10 * CLOCK_PER_SEC; // 10초 지연한다. clock_t start = clock(); while(clock() - start \u0026lt; delay) 루프와 텍스트 입력 cin \u0026gt;\u0026gt; ch\n빈칸, 탭, 개행을 무시하고 건너뛴다. 입력: Do you need# 출력: Doyouneed cin.get(ch);\n빈칸, 탭, 개행을 포함한다. 입력: Do you need# 출력: Do you need 운영 체제들이 리디렉션(표준 스트림을 사용자 지정 위치로 우회할 수 있는 것) 기능을 제공하기 때문에, 파일 입력 대신 키보드 입력을 바탕으로 프로그램을 실행할 수 있다. 키보드로 Ctrl + Z를 입력하면 EOF를 나타낼 수 있다. 1 2 3 4 5 // cin.get(ch)는 cin을 리턴하고. cin은 읽기가 성공하면 true를 리턴한다. while (cin.get(ch)) // cin.get()은 문자를 읽어서 리턴한다. 그 문자가 EOF이면 -1이겠다. while ((ch = cin.get()) != EOF) cin은 EOF(파일의 끝; End Of File; -1)를 탐지했을 때 eofbit와 failbit를 1로 설정한다. cin.eof()는 eofbit가 1이면 true를 리턴한다. cin.fail()는 eofbit 혹은 failbit이 1이면 true를 리턴한다. EOF가 설정되면 cin이 더 이상 입력을 받지 않는다. 따라서 다시 입력을 받으려면 cin.clear()를 해주어야 한다. ","date":"2022-03-05T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-05/","title":"[C++ Primer Plus] Chapter 5. 루프와 관계표현식"},{"content":" 배열 배열을 선언할 때 원소의 개수는 다음 중에 하나여야 한다. 값 정수 상수 상수 수식 1 2 3 4 5 6 int values1[40]; // 1 const int length = 40; int values2[length]; // 2 int values3[10 * sizeof(int)]; // 3 생성과 동시에 초기화할 수 있다. 반면, 초기화를 나중에 할 수는 없다. 1 int arr[3] = {1, 2, 3}; 초기화할 때 처음 원소를 명시적으로 하면 나머지는 알아서 0이 된다. 1 int arr[3] = {0}; [] 속을 비우면 초기화 개수 대로 배열이 만들어진다. 배열의 원소 개수는 sizeof(arr) / sizeof(int) 로 구할 수 있다. 1 int arr[] = {1, 2, 3}; // 3개의 int형 데이터를 가진 배열로 만들어진다. 배열 초기화 시 = 가 없어도 된다. 중괄호 공백으로 0으로 다 초기화할 수 있다. 초기화 시 narrowing은 안 된다. 1 2 3 int arr[] {1, 2, 3, 4}; int arr[] {}; int arr[] {1, 2, 3.3333, 4}; // (X) 문자열 모든 문자열의 마지막 문자는 널 문자(\\0)여야 한다. 문자열 상수로 배열을 초기화할 때 널 문자까지 고려해야 한다. [] 속을 배우면 알아서 널 문자까지 고려 해 준다. 배열이 문자열 상수보다 더 크면 널 문자로 계속 채운다. 1 char arr[] = \u0026#34;Hello\u0026#34;; // 6개의 char형 데이터를 가진 배열로 만들어진다. ‘S’는 문자이다. \u0026quot;S\u0026quot;는 문자열이며 S문자와 널 문자가 합쳐진 두 개의 문자로 이루어진 문자열이다. 따라서 아래와 같은 것은 안 된다. 1 char keyword = \u0026#34;S\u0026#34;; (X) White space(빈칸, 탭, 캐리지리턴)로 분리된 두 개의 문자열 상수는 하나의 문자열 상수로 결합된다. 1 cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026#34;My friend\u0026#34;; // \u0026#34;Hello My friend\u0026#34; \u0026lt;cstring\u0026gt; 헤더 파일에 있는 strlen()함수는 배열의 전체 크기가 아니라 배열에 저장된 문자열의 크기를 리턴한다. 널 문자는 제외한다. 문자열 읽기 cin은 White Space를 문자열의 끝으로 간주한다. 그래서 중간에 White Space가 있는 문자열을 입력하면 White Space 전까지만 저장하고 그 이후 문자들은 입력 큐에 남겨 놓는다. 그러면 다음 cin에서는 사용자 입력을 받지 않고 입력 큐에 남아있던 문자들을 저장한다. 전체 한 줄의 문자열을 저장하기 위해서는\u0026hellip; cin.getline(배열이름, 배열크기) getline은 매개변수로 입력받은 (배열크기 – 1)크기를 넘어서거나, 개행 문자를 만나면 개행 문자를 널 문자로 교체하고 입력한 후 읽기를 종료한다. getline이 지정된 배열 크기를 넘어서는 문자를 입력받으면 나머지는 입력 큐에 남겨두고, failbit를 설정한다. cin.get(배열이름, 배열크기) get은 개행 문자를 입력 큐에 남겨둔다. 다음 입력이 개행 문자를 입력하는 것을 방지하기 위해 cin.get()을 사용해 문자 하나를 읽어버릴 수 있다. 아니면 cin.get(배열이름, 배열크기).get() 이렇게 할 수도 있다. get이 빈 행을 읽으면 failbit라는 것이 설정되어서 추가적은 입력을 막는다. 이것을 복원하려면 cin.clear()를 해주어야 한다. 함수 입력 버퍼남김 무엇을 읽으면 failbit? cin White Space 이전까지 개행 문자 cin.getline(배열이름, 크기) 개행까지 X (개행은 널로 대체) 초과 크기의 문자열 cin.get(배열이름, 크기) 개행까지 개행 문자 빈 행 1 2 3 4 5 if (cin.fail() == 1) { cin.clear(); // 내부 상태 플러그 초기화 cin.ignore(INT_MAX, \u0026#39;\\n\u0026#39;); // 해당 길이 만큼 or 개행 문자까지 읽어서 입력 버퍼를 비운다. } string 클래스 리스트 초기화가 가능하다. 1 2 char arr[] = {\u0026#34;Hello\u0026#34;}; string str = {\u0026#34;Hello\u0026#34;}; 문자배열 string 크기 선언만 하면 크기가 제각각이다. 이후에 cin으로 입력을 저장하면 지정된 크기 만큼만 저장된다. 선언만 하면 크기가 0이다. 이후에 cin으로 입력을 저장해도 자동으로 크기를 조절해 문자열을 넣는다. 대입과 추가 C라이브러리 \u0026lt;cstring\u0026gt;를 사용해서 strcpy(arr1, arr2)로 복사한다. strcat(arr1, arr2)로 덧붙인다. =로 대입한다. +, += 으로 덧붙인다. 길이구하기 길이는 strlen(arr) 로 구할 수 있다. 길이는 str.size() 로 구할 수 있다. 1 2 3 4 5 6 // 문자배열 cin.getline(arr, arrSize); // string // \u0026lt;istream\u0026gt;은 string형을 인식하지 못한다. getline(cin, str); 다른 형태의 문자열 상수 wchar_t, char16_t, char32_t L, u, U 접두사를 사용해서 문자열 상수로 초기화할 수 있다. 1 wchar_t arr[] = L\u0026#34;Hello\u0026#34;; 접두사 R을 붙여서 raw 문자열을 사용할 수도 있다. 구조체 여러 종류의 데이터를 모아서 하나의 단위로 묶어서 저장할 수 있다. 함수도 멤버로 가질 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Student { char name[20]; int age; }; Student s1 = { \u0026#34;KimKim\u0026#34;, 1 }; Student s2 {}; // =를 생략할 수도 있다, 0으로 모두 초기화. cout \u0026lt;\u0026lt; s1.age; struct // 데이터형 이름 없음. 구조체의 정의와 동시에 변수생성. { char name[20]; int age; } s1, s2; 구조체 배열 1 Student sArr[2] = { { \u0026#34;KimKim\u0026#34;, 1 }, { \u0026#34;SoSo\u0026#34;, 2 } }; 공용체 여러 종류의 데이터를 모아서 하나의 단위로 묶었지만, 하나의 데이터만 보관할 수 있다. 공용체의 크기 = 제일 큰 멤버의 크기 1 2 3 4 5 union OneForAll { int Num; char Name[20]; }; 열거체 0부터 순서대로 대입되며, 명시적으로 지정하면 기본값은 무시된다. 1 enum Color { Red, Orange, Yellow, Blue, Green, Purple }; int형으로 자동으로 승급될 수 있다. 1 int number = 3 + Red; 반대로 int형이 자동으로 enum형으로 되진 않는다. 1 Color c = Color (3); 대입연산자만 사용할 수 있고, 산술 연산자는 안 된다. 1 ++c; // (X) 주로 기호 상수들을 정의하는 용도로 사용되므로 이름을 생략할 수도 있다. 1 enum { Red, Orange, Yellow, Blue, Green, Purple }; 어떤 정수값이 열거체 값 범위 안에 들어있으면, 그 값이 열거자 값이 아니더라도, 데이터형 변환을 통해서 열거체 변수에 대입할 수 있다. 포인터 int * 이든 double *이든 그 크기는 같다. (컴퓨터 시스템에 따라 다름) 1 2 3 4 5 6 7 int number = 7; int * pointer = \u0026amp;number; // *pointer == number == number의 값 // pointer == \u0026amp;number == number의 주소값 int * ptr, num; // ptr은 포인터형으로 num은 int형으로 생성된다. 포인터에 직접 주소를 대입할 수 있다. 데이터형을 반드시 명시해야 한다. 1 int * number = (int *) 0xB8000000; new연산자로 런타임에 메모리 할당 (C의 malloc 대체) 1 int * ptr = new int; 여기서 ptr이 가리키고 있는 메모리의 이름(number같은 변수 이름)이 없다. 그냥 메모리 블록을 가리키고 있다. 그래서 ptr을 통해서만 메모리 접근이 가능하다. 컴퓨터 메모리가 부족해서 new의 메모리 할당 요청을 허용할 수 없으면 new는 0을 리턴한다. 이렇게 값이 0인 포인터는 널 포인터라고 부른다. 널 포인터는 무언가 일이 잘못되었다는 것을 나타낼 때 사용된다. delete 연산자로 메모리 해제 1 2 int * ptr = new int; delete ptr; 메모리 누수를 방지하기 위해 다 쓴 메모리는 delete 연산자를 사용해 메모리를 해제해 주어야한다. delete로 해제된 메모리를 또 다시 delete로 해제하면 안 된다. 보통의 변수로 대입한 메모리도 delete로 해제할 수 없다. 널 포인터를 delete하면 아무일도 일어나지 않는다 (안전하다) new를 사용해 생성한 동적 배열 (동적 바인딩) 1 2 int * ptr = new int [10]; delete [] ptr; *ptr이나 ptr[0]으로 배열의 첫번째 원소에 접근 가능 하다. ptr + 1을 하면 ptr이 가리키는 데이터형의 크기만큼 한 칸 뒤로 가서, ptr[0]은 두번째 원소인 ptr[1]을 가리키게 된다. 포인터와 배열 1 2 int numbers[3] = {1, 2, 3}; int * ptr = numbers; numbers == \u0026amp;numbers[0]\nnumbers 배열의 첫 번째 원소의 주소값 numbers != \u0026amp;numbers\n\u0026amp;numbers는 배열 전체의 주소값이다. 따라서 numbers + 1은 다음 원소의 주소값이지만, \u0026amp;numbers + 1을 하면 전체 배열을 넘어간 다음의 주소값이다. *numbers == numbers[0]\nnumbers 배열의 첫 번째 원소의 값 *(numbers + 1) == numbers[1]\nnumbers 배열의 두 번째 원소의 값 여기서 numbers 대신 ptr을 넣어도 똑같다. 다른점: (1) ptr은 값을 변경할 수 있지만 배열 이름인 numbers는 값을 변경할 수 없다. (2) sizeof(numbers)는 배열 전체의 크기이지만 sizeof(ptr)은 포인터의 크기이다. 포인터 배열과 배열 포인터 1 2 short * ptr [20];\t// short* 형 포인터가 20개 있는 배열 short (*ptr)[20];\t// short 형 자료가 20개 있는 배열을 가리키는 포인터 포인터와 문자열 배열의 이름, 포인터, 문자열 상수 모두 동등하게 첫번째 문자열의 주소를 나타낸다. 1 2 3 4 5 6 7 char arr[10] = \u0026#34;beautiful\u0026#34;; cout \u0026lt;\u0026lt; arr; char * ptr = \u0026#34;beautiful\u0026#34;; cout \u0026lt;\u0026lt; ptr; cout \u0026lt;\u0026lt; \u0026#34;beautiful\u0026#34; 문자열 상수나 초기화되지 않은 포인터를 문자열 입력에 절대 사용하지 않아야 한다. 포인터의 경우, 초기회되지 않았다면, 입력된 문자가 어디에 저장될지 알 수 없어진다. 1 2 3 4 5 const char * ptr1 = \u0026#34;notgood\u0026#34;; cin \u0026gt;\u0026gt; ptr1; char * ptr2; cin \u0026gt;\u0026gt; ptr2 //(X) strncpy(arr1, arr2, 최대 문자 수); 이것은 최대 문자수가 다 안 담기면 널 문자를 추가하지 않는다. 따라서 반드시 수기로 추가해야 한다. new를 사용한 동적 구조체 생성 연산자 형식 도트 멤버 연산자 [구조체의 이름.멤버], [(*포인터).멤버] 화살표 멤버 연산자 [구조체를 지시하는 포인터-\u0026gt;멤버] 1 2 3 4 5 6 7 8 9 10 11 12 13 struct Flower { char name[20]; double price; }; Flower * f = new Flower; cin.get(f-\u0026gt;name, 20); cin \u0026gt;\u0026gt; f-\u0026gt;price; cin \u0026gt;\u0026gt; (*f).price; delete f; 데이터 저장을 위한 메모리 공간의 종류 자동 공간(automatic) 변수들이 자신이 정의되어있는 함수가 호출되는 순간에 생겨나서, 함수가 종료되는 시점까지만 존재한다. (블록 안에서만 유효하다) 스택에 저장된다. 따라서 순차적으로 저장되고 역순으로 해제된다. 정적 공간(static) 프로그램이 실행되는 동안에 지속적으로 존재하는 공간이다. 함수 외부에서 변수를 정의하거나 static 키워드로 정의하면 된다. 1 static double fee = 56.5; 동적 공간(힙)(dynamic) new와 delete을 사용해서 동적으로 메모리를 할당하고 해제한다. 힙에 저장된다. 배열의 대안 vector 템플릿 클래스 string 클래스처럼 자동으로 런타임에 메모리가 할당/해제 된다. (힙) 1 2 3 4 vector\u0026lt;int\u0026gt; vec(10); // 10개 원소를 가진 int형 배열. // 10자리에 변수가능. // 자동으로 0으로 모두 초기화 됨. array 템플릿 클래스 크기가 고정되어 크기를 런타임에 바꿀 수 없다. (스택) 1 array\u0026lt;int, 10\u0026gt; arr; // 10자리에 변수 불가능. ","date":"2022-03-04T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-04/","title":"[C++ Primer Plus] Chapter 4. 복합 데이터형"},{"content":" 변수 이름 규칙 영문자, 숫자, 밑줄만 사용 가능 대문자와 소문자는 구별됨 첫 문자가 숫자일 수는 없음 C++의 키워드는 사용 못함 예약어는 사용 못함 길이 제한은 없음 비트와 바이트 비트 컴퓨터 메모리를 구성하는 기본 단위 바이트 8비트. C++에서는 컴파일러의 기본 문자 세트를 수용할 수 있는 최소한의 연속된 비트들로 구성한다. sizeof 연산자 데이터형의 크기를 바이트 단위로 리턴한다. climits 헤더파일 컴파일러에 알맞은 최대값들을 정의해놓은 헤더파일 (INT_MAX 등) 변수 초기화 문법 1 2 3 4 int var = 10; int var = {10}; int var {10}; int var (10); 진법 진법 조건 10진수 첫 숫자가 1~9 8진수 첫 숫자가 0이고 두번째 숫자가 1~7 16진수 첫 두 문자가 0x 혹은 0X 조정자 hex, oct를 사용하면 16진법, 8진법으로 출력가능 1 2 cout \u0026lt;\u0026lt; hex cout \u0026lt;\u0026lt; oct 정수형 상수의 데이터형을 결정하는 방법 접미어를 붙이면 해당 데이터형으로 10진 정수 int \u0026lt; long \u0026lt; long long형 중에서 크기가 작은 것으로 8진, 16진 정수 int, unsigned int \u0026lt; long, unsigned long \u0026lt; long long, unsigned long long 중에서 크기가 작은 것으로 문자 이스케이프 시퀀스(escape sequence)\n'\\n' \u0026quot;\\n\u0026quot; 개행은 정식 문자로 취급된다. 유니버셜 코드 네임(universal character names)\n\\u나 \\U 뒤에 16진수 숫자가 온다. 이 숫자들은 특정 문자에 해당하는 ISO10646코드를 나타낸다. 이것으로 어떤 문자도 영어가 아니어도 소스코드 안에 쓸 수 가 있다. char형을 수에 쓰려고 한다면 unsigned char와 signed char가 중요해진다. 하지만 문자라면 단순히 char라고만 하면 된다.\n1바이트로 표현할 수 없는 한국어 문자 세트 같은 경우는 확장문자 세트를 제공한다. wchar_t이다. 이것은 기초 데이터형과 동일한 크기와 부호 속성을 가진다. 이 문자의 스트림을 처리하기 위해 wcout, wcin이 존재하고, 문자열 앞에 L을 붙여 나타낸다. const 상수를 기호 이름으로 나타내기 위해서는 #define과 const를 사용할 수 있다. 하지만 const가 나은 이유는\u0026hellip; (1) 데이터형을 명시 가능 (2) 특정 함수나 파일에서만 사용 하게 가능 (3) 복잡한 데이터형도 가능 부동 소수점형 3.14 : 가수, 16 : 지수 유효숫자: 의미 있는 숫자 (3.14이므로 3개), 유효숫자의 개수: 정밀도 지수 허용범위 고정 소수점 표기로 결과를 출력한다. (소수점 6자리까지) 1 cout.setf(ios_base::fixed, ios_base::floatfield) 부동 소수점형 상수의 데이터형을 결정하는 방법 기본은 double형 float로 하고 싶으면 f, F를 붙이고 long double형으로 하고 싶으면 l, L을 접미어로 붙인다. 산술 연산자 %연산자의 두개의 피연산자는 모두 정수여야한다. 아니면 컴파일 에러가 발생한다. /연산자의 두개의 피연산자 중 한 개이상이 부동 소수점형이면 결과도 부동 소수점형이다. 수식에서의 데이터 형 변환 bool, char, unsigned char, signed char, short형은 int로 정수 승급된다. 서로 다른 데이터형을 혼합하면 큰 크기의 데이터형으로 변환된다 데이터형 변환자 강제로 데이터형을 변환시킨다. 1 2 (int) var; int (var); 정수 데이터형 모든 컴퓨터에서 사용하기 위해 데이터의 폭(width, 메모리의 크기)은 최소 크기만 정한다. 데이터형 크기 bool 1바이트 char 1바이트. 시스템의 기본 문자세트의 어떤 문자라도 저장할 만큼 커야 함 signed char -128~127 unsigned char 0~255 short 최소한 2바이트 unsigned short int 4바이트. 최소한 short만큼은 크다 unsigned int long 최소한 4바이트의 폭, int만큼은 크다 unsigned long long long 최소한 8바이트의 폭, long만큼은 크다 부동 소수점 데이터형 데이터형 크기 float 4바이트 double 8바이트. 최소한 float만큼은 크다 long double 16바이트. 최소한 double만큼은 크다 ","date":"2022-03-03T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-03/","title":"[C++ Primer Plus] Chapter 3. 데이터 처리"},{"content":" C++ C++은 다음과 같은 요소를 합쳐서 만든 것이다.\n(1) C의 절차적 프로그래밍\n알고리즘(컴퓨터가 따라가야 할 절차)을 강조함 (2) 객체 지향 프로그래밍\n데이터를 강조함(문제 특성에 맞는 데이터형을 설계힘: Class) (3) 일반화 프로그래밍\n알고리즘을 강조함(데이터형과 무관한 코드를 작성할 수 있게함: Template) 객체 지향 프로그래밍 클래스 데이터 형식과 그것이 사용되는 방법을 서술하는 것. 객체 클래스가 실제로 생성된 구체물. 실행 파일 생성 순서 (1) 전처리기가 선행처리문자(#)로 시작하는 선행처리지시문을 처리한다. (2) 컴파일러가 전처리기문이 사라진 소스코드를 어셈블리 코드로 변환한다. (3) 어셈블러가 목적 코드로 만든다. (4) 링커가 모든 오브젝트 파일들을 연결해서 실행 코드를 만든다. 컴파일러 번역 순서 (1) 어휘 분석(Lexical) 정규 문법에 따라 소스 코드를 토큰(token; 한 행에서 더 이상 분리할 수 없는 기본 요소)의 집합으로 변환한다. (2) 구문 분석 (Syntax) 소스 코드의 문법이 올바른지 분석한다. (3) 의미 분석 (Semantic) 정수와 문자열의 덧셈, 값을 0으로 나누는 행동 등과 같이 의미적으로 올바르지 않은 코드의 존재 유무를 검사한다. (4) 중간코드 생성 (5) 코드 최적화 코드를 좀 더 효율적으로 만든다. (6) 목적코드 생성 함수 함수 원형(prototype) 함수의 인터페이스만 알려주는 것 함수 정의(definition) 실제 코드 ","date":"2022-03-02T12:00:00+09:00","permalink":"https://sopod.github.io/p/cpp-primer-plus-01/","title":"[C++ Primer Plus] Chapter 1, 2. 시작하기"}]